package xpr

import (
	"fmt"
	"reflect"
	"sys/bsc/bnd"
	"sys/err"
	"sys/lng/pro/trm"
	"sys/lng/pro/trm/prs"
	"sys/lng/pro/xpr/knd"
)

type (
	Xprr struct {
		trm.Trmr
	}
	Xpr interface {
		Xpr()
	}
	LogLogrXpr interface {
		Xpr()
		LogLogrXpr()
	}
	StrStrXpr interface {
		Xpr()
		StrStrXpr()
	}
	BolBolXpr interface {
		Xpr()
		BolBolXpr()
	}
	FltFltXpr interface {
		Xpr()
		FltFltXpr()
	}
	UntUntXpr interface {
		Xpr()
		UntUntXpr()
	}
	IntIntXpr interface {
		Xpr()
		IntIntXpr()
	}
	TmeTmeXpr interface {
		Xpr()
		TmeTmeXpr()
	}
	BndBndXpr interface {
		Xpr()
		BndBndXpr()
	}
	FltRngXpr interface {
		Xpr()
		FltRngXpr()
	}
	TmeRngXpr interface {
		Xpr()
		TmeRngXpr()
	}
	StrsStrsXpr interface {
		Xpr()
		StrsStrsXpr()
	}
	BolsBolsXpr interface {
		Xpr()
		BolsBolsXpr()
	}
	FltsFltsXpr interface {
		Xpr()
		FltsFltsXpr()
	}
	UntsUntsXpr interface {
		Xpr()
		UntsUntsXpr()
	}
	IntsIntsXpr interface {
		Xpr()
		IntsIntsXpr()
	}
	TmesTmesXpr interface {
		Xpr()
		TmesTmesXpr()
	}
	BndsBndsXpr interface {
		Xpr()
		BndsBndsXpr()
	}
	TmeRngsXpr interface {
		Xpr()
		TmeRngsXpr()
	}
	AnaTrdXpr interface {
		Xpr()
		AnaTrdXpr()
	}
	AnaTrdsXpr interface {
		Xpr()
		AnaTrdsXpr()
	}
	AnaPrfmXpr interface {
		Xpr()
		AnaPrfmXpr()
	}
	AnaPrfmsXpr interface {
		Xpr()
		AnaPrfmsXpr()
	}
	AnaPrfmDltXpr interface {
		Xpr()
		AnaPrfmDltXpr()
	}
	AnaPortXpr interface {
		Xpr()
		AnaPortXpr()
	}
	HstPrvXpr interface {
		Xpr()
		HstPrvXpr()
	}
	HstInstrXpr interface {
		Xpr()
		HstInstrXpr()
	}
	HstInrvlXpr interface {
		Xpr()
		HstInrvlXpr()
	}
	HstSideXpr interface {
		Xpr()
		HstSideXpr()
	}
	HstStmXpr interface {
		Xpr()
		HstStmXpr()
	}
	HstCndXpr interface {
		Xpr()
		HstCndXpr()
	}
	HstStgyXpr interface {
		Xpr()
		HstStgyXpr()
	}
	HstPrvsXpr interface {
		Xpr()
		HstPrvsXpr()
	}
	HstInstrsXpr interface {
		Xpr()
		HstInstrsXpr()
	}
	HstInrvlsXpr interface {
		Xpr()
		HstInrvlsXpr()
	}
	HstSidesXpr interface {
		Xpr()
		HstSidesXpr()
	}
	HstStmsXpr interface {
		Xpr()
		HstStmsXpr()
	}
	HstCndsXpr interface {
		Xpr()
		HstCndsXpr()
	}
	HstStgysXpr interface {
		Xpr()
		HstStgysXpr()
	}
	RltPrvXpr interface {
		Xpr()
		RltPrvXpr()
	}
	RltInstrXpr interface {
		Xpr()
		RltInstrXpr()
	}
	RltInrvlXpr interface {
		Xpr()
		RltInrvlXpr()
	}
	RltSideXpr interface {
		Xpr()
		RltSideXpr()
	}
	RltStmXpr interface {
		Xpr()
		RltStmXpr()
	}
	RltCndXpr interface {
		Xpr()
		RltCndXpr()
	}
	RltStgyXpr interface {
		Xpr()
		RltStgyXpr()
	}
	RltPrvsXpr interface {
		Xpr()
		RltPrvsXpr()
	}
	RltInstrsXpr interface {
		Xpr()
		RltInstrsXpr()
	}
	RltInrvlsXpr interface {
		Xpr()
		RltInrvlsXpr()
	}
	RltSidesXpr interface {
		Xpr()
		RltSidesXpr()
	}
	RltStmsXpr interface {
		Xpr()
		RltStmsXpr()
	}
	RltCndsXpr interface {
		Xpr()
		RltCndsXpr()
	}
	RltStgysXpr interface {
		Xpr()
		RltStgysXpr()
	}
	FntFntXpr interface {
		Xpr()
		FntFntXpr()
	}
	ClrClrXpr interface {
		Xpr()
		ClrClrXpr()
	}
	PenPenXpr interface {
		Xpr()
		PenPenXpr()
	}
	PenPensXpr interface {
		Xpr()
		PenPensXpr()
	}
	PltPltXpr interface {
		Xpr()
		PltPltXpr()
	}
	PltPltsXpr interface {
		Xpr()
		PltPltsXpr()
	}
	PltTmeAxisXXpr interface {
		Xpr()
		PltTmeAxisXXpr()
	}
	PltFltAxisYXpr interface {
		Xpr()
		PltFltAxisYXpr()
	}
	PltStmXpr interface {
		Xpr()
		PltStmXpr()
		PltPltXpr()
	}
	PltFltsSctrXpr interface {
		Xpr()
		PltFltsSctrXpr()
		PltPltXpr()
	}
	PltFltsSctrDistXpr interface {
		Xpr()
		PltFltsSctrDistXpr()
		PltPltXpr()
	}
	PltHrzXpr interface {
		Xpr()
		PltHrzXpr()
		PltPltXpr()
	}
	PltVrtXpr interface {
		Xpr()
		PltVrtXpr()
		PltPltXpr()
	}
	PltDpthXpr interface {
		Xpr()
		PltDpthXpr()
		PltPltXpr()
	}
	SysIdnXpr interface {
		Xpr()
		SysIdnXpr()
	}
	SysMuXpr interface {
		Xpr()
		SysMuXpr()
	}
	StrStrLit struct {
		Trm trm.StrLit
	}
	BolBolLit struct {
		Trm trm.BolLit
	}
	FltFltLit struct {
		Trm trm.FltLit
	}
	UntUntLit struct {
		Trm trm.UntLit
	}
	IntIntLit struct {
		Trm trm.IntLit
	}
	TmeTmeLit struct {
		Trm trm.TmeLit
	}
	BndBndLit struct {
		Trm trm.BndLit
	}
	FltRngLit struct {
		Trm trm.FltRngLit
	}
	TmeRngLit struct {
		Trm trm.TmeRngLit
	}
	StrsStrsLit struct {
		Trm trm.StrsLit
	}
	BolsBolsLit struct {
		Trm trm.BolsLit
	}
	FltsFltsLit struct {
		Trm trm.FltsLit
	}
	UntsUntsLit struct {
		Trm trm.UntsLit
	}
	IntsIntsLit struct {
		Trm trm.IntsLit
	}
	TmesTmesLit struct {
		Trm trm.TmesLit
	}
	BndsBndsLit struct {
		Trm trm.BndsLit
	}
	TmeRngsLit struct {
		Trm trm.TmeRngsLit
	}
	StrStrAsn struct {
		Trm   bnd.Bnd
		X     StrStrXpr
		Idn   bnd.Bnd
		Depth int
	}
	StrStrAcs struct {
		Trm bnd.Bnd
	}
	BolBolAsn struct {
		Trm   bnd.Bnd
		X     BolBolXpr
		Idn   bnd.Bnd
		Depth int
	}
	BolBolAcs struct {
		Trm bnd.Bnd
	}
	FltFltAsn struct {
		Trm   bnd.Bnd
		X     FltFltXpr
		Idn   bnd.Bnd
		Depth int
	}
	FltFltAcs struct {
		Trm bnd.Bnd
	}
	UntUntAsn struct {
		Trm   bnd.Bnd
		X     UntUntXpr
		Idn   bnd.Bnd
		Depth int
	}
	UntUntAcs struct {
		Trm bnd.Bnd
	}
	IntIntAsn struct {
		Trm   bnd.Bnd
		X     IntIntXpr
		Idn   bnd.Bnd
		Depth int
	}
	IntIntAcs struct {
		Trm bnd.Bnd
	}
	TmeTmeAsn struct {
		Trm   bnd.Bnd
		X     TmeTmeXpr
		Idn   bnd.Bnd
		Depth int
	}
	TmeTmeAcs struct {
		Trm bnd.Bnd
	}
	BndBndAsn struct {
		Trm   bnd.Bnd
		X     BndBndXpr
		Idn   bnd.Bnd
		Depth int
	}
	BndBndAcs struct {
		Trm bnd.Bnd
	}
	FltRngAsn struct {
		Trm   bnd.Bnd
		X     FltRngXpr
		Idn   bnd.Bnd
		Depth int
	}
	FltRngAcs struct {
		Trm bnd.Bnd
	}
	TmeRngAsn struct {
		Trm   bnd.Bnd
		X     TmeRngXpr
		Idn   bnd.Bnd
		Depth int
	}
	TmeRngAcs struct {
		Trm bnd.Bnd
	}
	StrsStrsAsn struct {
		Trm   bnd.Bnd
		X     StrsStrsXpr
		Idn   bnd.Bnd
		Depth int
	}
	StrsStrsAcs struct {
		Trm bnd.Bnd
	}
	StrsStrsEach struct {
		Trm  bnd.Bnd
		X    StrsStrsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	StrsStrsPllEach struct {
		Trm  bnd.Bnd
		X    StrsStrsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	BolsBolsAsn struct {
		Trm   bnd.Bnd
		X     BolsBolsXpr
		Idn   bnd.Bnd
		Depth int
	}
	BolsBolsAcs struct {
		Trm bnd.Bnd
	}
	BolsBolsEach struct {
		Trm  bnd.Bnd
		X    BolsBolsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	BolsBolsPllEach struct {
		Trm  bnd.Bnd
		X    BolsBolsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	FltsFltsAsn struct {
		Trm   bnd.Bnd
		X     FltsFltsXpr
		Idn   bnd.Bnd
		Depth int
	}
	FltsFltsAcs struct {
		Trm bnd.Bnd
	}
	FltsFltsEach struct {
		Trm  bnd.Bnd
		X    FltsFltsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	FltsFltsPllEach struct {
		Trm  bnd.Bnd
		X    FltsFltsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	UntsUntsAsn struct {
		Trm   bnd.Bnd
		X     UntsUntsXpr
		Idn   bnd.Bnd
		Depth int
	}
	UntsUntsAcs struct {
		Trm bnd.Bnd
	}
	UntsUntsEach struct {
		Trm  bnd.Bnd
		X    UntsUntsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	UntsUntsPllEach struct {
		Trm  bnd.Bnd
		X    UntsUntsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	IntsIntsAsn struct {
		Trm   bnd.Bnd
		X     IntsIntsXpr
		Idn   bnd.Bnd
		Depth int
	}
	IntsIntsAcs struct {
		Trm bnd.Bnd
	}
	IntsIntsEach struct {
		Trm  bnd.Bnd
		X    IntsIntsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	IntsIntsPllEach struct {
		Trm  bnd.Bnd
		X    IntsIntsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	TmesTmesAsn struct {
		Trm   bnd.Bnd
		X     TmesTmesXpr
		Idn   bnd.Bnd
		Depth int
	}
	TmesTmesAcs struct {
		Trm bnd.Bnd
	}
	TmesTmesEach struct {
		Trm  bnd.Bnd
		X    TmesTmesXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	TmesTmesPllEach struct {
		Trm  bnd.Bnd
		X    TmesTmesXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	BndsBndsAsn struct {
		Trm   bnd.Bnd
		X     BndsBndsXpr
		Idn   bnd.Bnd
		Depth int
	}
	BndsBndsAcs struct {
		Trm bnd.Bnd
	}
	BndsBndsEach struct {
		Trm  bnd.Bnd
		X    BndsBndsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	BndsBndsPllEach struct {
		Trm  bnd.Bnd
		X    BndsBndsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	TmeRngsAsn struct {
		Trm   bnd.Bnd
		X     TmeRngsXpr
		Idn   bnd.Bnd
		Depth int
	}
	TmeRngsAcs struct {
		Trm bnd.Bnd
	}
	TmeRngsEach struct {
		Trm  bnd.Bnd
		X    TmeRngsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	TmeRngsPllEach struct {
		Trm  bnd.Bnd
		X    TmeRngsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	AnaTrdAsn struct {
		Trm   bnd.Bnd
		X     AnaTrdXpr
		Idn   bnd.Bnd
		Depth int
	}
	AnaTrdAcs struct {
		Trm bnd.Bnd
	}
	AnaTrdsAsn struct {
		Trm   bnd.Bnd
		X     AnaTrdsXpr
		Idn   bnd.Bnd
		Depth int
	}
	AnaTrdsAcs struct {
		Trm bnd.Bnd
	}
	AnaTrdsEach struct {
		Trm  bnd.Bnd
		X    AnaTrdsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	AnaTrdsPllEach struct {
		Trm  bnd.Bnd
		X    AnaTrdsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	AnaPrfmAsn struct {
		Trm   bnd.Bnd
		X     AnaPrfmXpr
		Idn   bnd.Bnd
		Depth int
	}
	AnaPrfmAcs struct {
		Trm bnd.Bnd
	}
	AnaPrfmsAsn struct {
		Trm   bnd.Bnd
		X     AnaPrfmsXpr
		Idn   bnd.Bnd
		Depth int
	}
	AnaPrfmsAcs struct {
		Trm bnd.Bnd
	}
	AnaPrfmsEach struct {
		Trm  bnd.Bnd
		X    AnaPrfmsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	AnaPrfmsPllEach struct {
		Trm  bnd.Bnd
		X    AnaPrfmsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	AnaPrfmDltAsn struct {
		Trm   bnd.Bnd
		X     AnaPrfmDltXpr
		Idn   bnd.Bnd
		Depth int
	}
	AnaPrfmDltAcs struct {
		Trm bnd.Bnd
	}
	AnaPortAsn struct {
		Trm   bnd.Bnd
		X     AnaPortXpr
		Idn   bnd.Bnd
		Depth int
	}
	AnaPortAcs struct {
		Trm bnd.Bnd
	}
	HstPrvAsn struct {
		Trm   bnd.Bnd
		X     HstPrvXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstPrvAcs struct {
		Trm bnd.Bnd
	}
	HstInstrAsn struct {
		Trm   bnd.Bnd
		X     HstInstrXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstInstrAcs struct {
		Trm bnd.Bnd
	}
	HstInrvlAsn struct {
		Trm   bnd.Bnd
		X     HstInrvlXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstInrvlAcs struct {
		Trm bnd.Bnd
	}
	HstSideAsn struct {
		Trm   bnd.Bnd
		X     HstSideXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstSideAcs struct {
		Trm bnd.Bnd
	}
	HstStmAsn struct {
		Trm   bnd.Bnd
		X     HstStmXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstStmAcs struct {
		Trm bnd.Bnd
	}
	HstCndAsn struct {
		Trm   bnd.Bnd
		X     HstCndXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstCndAcs struct {
		Trm bnd.Bnd
	}
	HstStgyAsn struct {
		Trm   bnd.Bnd
		X     HstStgyXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstStgyAcs struct {
		Trm bnd.Bnd
	}
	HstPrvsAsn struct {
		Trm   bnd.Bnd
		X     HstPrvsXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstPrvsAcs struct {
		Trm bnd.Bnd
	}
	HstPrvsEach struct {
		Trm  bnd.Bnd
		X    HstPrvsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstPrvsPllEach struct {
		Trm  bnd.Bnd
		X    HstPrvsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstInstrsAsn struct {
		Trm   bnd.Bnd
		X     HstInstrsXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstInstrsAcs struct {
		Trm bnd.Bnd
	}
	HstInstrsEach struct {
		Trm  bnd.Bnd
		X    HstInstrsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstInstrsPllEach struct {
		Trm  bnd.Bnd
		X    HstInstrsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstInrvlsAsn struct {
		Trm   bnd.Bnd
		X     HstInrvlsXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstInrvlsAcs struct {
		Trm bnd.Bnd
	}
	HstInrvlsEach struct {
		Trm  bnd.Bnd
		X    HstInrvlsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstInrvlsPllEach struct {
		Trm  bnd.Bnd
		X    HstInrvlsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstSidesAsn struct {
		Trm   bnd.Bnd
		X     HstSidesXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstSidesAcs struct {
		Trm bnd.Bnd
	}
	HstSidesEach struct {
		Trm  bnd.Bnd
		X    HstSidesXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstSidesPllEach struct {
		Trm  bnd.Bnd
		X    HstSidesXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstStmsAsn struct {
		Trm   bnd.Bnd
		X     HstStmsXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstStmsAcs struct {
		Trm bnd.Bnd
	}
	HstStmsEach struct {
		Trm  bnd.Bnd
		X    HstStmsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstStmsPllEach struct {
		Trm  bnd.Bnd
		X    HstStmsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstCndsAsn struct {
		Trm   bnd.Bnd
		X     HstCndsXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstCndsAcs struct {
		Trm bnd.Bnd
	}
	HstCndsEach struct {
		Trm  bnd.Bnd
		X    HstCndsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstCndsPllEach struct {
		Trm  bnd.Bnd
		X    HstCndsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstStgysAsn struct {
		Trm   bnd.Bnd
		X     HstStgysXpr
		Idn   bnd.Bnd
		Depth int
	}
	HstStgysAcs struct {
		Trm bnd.Bnd
	}
	HstStgysEach struct {
		Trm  bnd.Bnd
		X    HstStgysXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	HstStgysPllEach struct {
		Trm  bnd.Bnd
		X    HstStgysXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltPrvAsn struct {
		Trm   bnd.Bnd
		X     RltPrvXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltPrvAcs struct {
		Trm bnd.Bnd
	}
	RltInstrAsn struct {
		Trm   bnd.Bnd
		X     RltInstrXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltInstrAcs struct {
		Trm bnd.Bnd
	}
	RltInrvlAsn struct {
		Trm   bnd.Bnd
		X     RltInrvlXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltInrvlAcs struct {
		Trm bnd.Bnd
	}
	RltSideAsn struct {
		Trm   bnd.Bnd
		X     RltSideXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltSideAcs struct {
		Trm bnd.Bnd
	}
	RltStmAsn struct {
		Trm   bnd.Bnd
		X     RltStmXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltStmAcs struct {
		Trm bnd.Bnd
	}
	RltCndAsn struct {
		Trm   bnd.Bnd
		X     RltCndXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltCndAcs struct {
		Trm bnd.Bnd
	}
	RltStgyAsn struct {
		Trm   bnd.Bnd
		X     RltStgyXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltStgyAcs struct {
		Trm bnd.Bnd
	}
	RltPrvsAsn struct {
		Trm   bnd.Bnd
		X     RltPrvsXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltPrvsAcs struct {
		Trm bnd.Bnd
	}
	RltPrvsEach struct {
		Trm  bnd.Bnd
		X    RltPrvsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltPrvsPllEach struct {
		Trm  bnd.Bnd
		X    RltPrvsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltInstrsAsn struct {
		Trm   bnd.Bnd
		X     RltInstrsXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltInstrsAcs struct {
		Trm bnd.Bnd
	}
	RltInstrsEach struct {
		Trm  bnd.Bnd
		X    RltInstrsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltInstrsPllEach struct {
		Trm  bnd.Bnd
		X    RltInstrsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltInrvlsAsn struct {
		Trm   bnd.Bnd
		X     RltInrvlsXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltInrvlsAcs struct {
		Trm bnd.Bnd
	}
	RltInrvlsEach struct {
		Trm  bnd.Bnd
		X    RltInrvlsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltInrvlsPllEach struct {
		Trm  bnd.Bnd
		X    RltInrvlsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltSidesAsn struct {
		Trm   bnd.Bnd
		X     RltSidesXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltSidesAcs struct {
		Trm bnd.Bnd
	}
	RltSidesEach struct {
		Trm  bnd.Bnd
		X    RltSidesXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltSidesPllEach struct {
		Trm  bnd.Bnd
		X    RltSidesXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltStmsAsn struct {
		Trm   bnd.Bnd
		X     RltStmsXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltStmsAcs struct {
		Trm bnd.Bnd
	}
	RltStmsEach struct {
		Trm  bnd.Bnd
		X    RltStmsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltStmsPllEach struct {
		Trm  bnd.Bnd
		X    RltStmsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltCndsAsn struct {
		Trm   bnd.Bnd
		X     RltCndsXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltCndsAcs struct {
		Trm bnd.Bnd
	}
	RltCndsEach struct {
		Trm  bnd.Bnd
		X    RltCndsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltCndsPllEach struct {
		Trm  bnd.Bnd
		X    RltCndsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltStgysAsn struct {
		Trm   bnd.Bnd
		X     RltStgysXpr
		Idn   bnd.Bnd
		Depth int
	}
	RltStgysAcs struct {
		Trm bnd.Bnd
	}
	RltStgysEach struct {
		Trm  bnd.Bnd
		X    RltStgysXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	RltStgysPllEach struct {
		Trm  bnd.Bnd
		X    RltStgysXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	FntFntAsn struct {
		Trm   bnd.Bnd
		X     FntFntXpr
		Idn   bnd.Bnd
		Depth int
	}
	FntFntAcs struct {
		Trm bnd.Bnd
	}
	ClrClrAsn struct {
		Trm   bnd.Bnd
		X     ClrClrXpr
		Idn   bnd.Bnd
		Depth int
	}
	ClrClrAcs struct {
		Trm bnd.Bnd
	}
	PenPenAsn struct {
		Trm   bnd.Bnd
		X     PenPenXpr
		Idn   bnd.Bnd
		Depth int
	}
	PenPenAcs struct {
		Trm bnd.Bnd
	}
	PenPensAsn struct {
		Trm   bnd.Bnd
		X     PenPensXpr
		Idn   bnd.Bnd
		Depth int
	}
	PenPensAcs struct {
		Trm bnd.Bnd
	}
	PenPensEach struct {
		Trm  bnd.Bnd
		X    PenPensXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	PenPensPllEach struct {
		Trm  bnd.Bnd
		X    PenPensXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	PltPltAsn struct {
		Trm   bnd.Bnd
		X     PltPltXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltPltAcs struct {
		Trm bnd.Bnd
	}
	PltPltsAsn struct {
		Trm   bnd.Bnd
		X     PltPltsXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltPltsAcs struct {
		Trm bnd.Bnd
	}
	PltPltsEach struct {
		Trm  bnd.Bnd
		X    PltPltsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	PltPltsPllEach struct {
		Trm  bnd.Bnd
		X    PltPltsXpr
		Idn  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
	PltStmAsn struct {
		Trm   bnd.Bnd
		X     PltStmXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltStmAcs struct {
		Trm bnd.Bnd
	}
	PltFltsSctrAsn struct {
		Trm   bnd.Bnd
		X     PltFltsSctrXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltFltsSctrAcs struct {
		Trm bnd.Bnd
	}
	PltFltsSctrDistAsn struct {
		Trm   bnd.Bnd
		X     PltFltsSctrDistXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltFltsSctrDistAcs struct {
		Trm bnd.Bnd
	}
	PltHrzAsn struct {
		Trm   bnd.Bnd
		X     PltHrzXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltHrzAcs struct {
		Trm bnd.Bnd
	}
	PltVrtAsn struct {
		Trm   bnd.Bnd
		X     PltVrtXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltVrtAcs struct {
		Trm bnd.Bnd
	}
	PltDpthAsn struct {
		Trm   bnd.Bnd
		X     PltDpthXpr
		Idn   bnd.Bnd
		Depth int
	}
	PltDpthAcs struct {
		Trm bnd.Bnd
	}
	SysMuAsn struct {
		Trm   bnd.Bnd
		X     SysMuXpr
		Idn   bnd.Bnd
		Depth int
	}
	SysMuAcs struct {
		Trm bnd.Bnd
	}
	BolBolThen struct {
		Trm  bnd.Bnd
		X    BolBolXpr
		Xprs []Xpr
		Scp  *Scp
	}
	BolBolElse struct {
		Trm  bnd.Bnd
		X    BolBolXpr
		Xprs []Xpr
		Scp  *Scp
	}
	AnaPrfmPnlPctGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmScsPctGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPipPerDayGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmUsdPerDayGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmScsPerDayGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmOpnPerDayGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPnlUsdGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPipAvgGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPipMdnGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPipMinGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPipMaxGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmPipSumGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDurAvgGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDurMdnGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDurMinGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDurMaxGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmLosLimMaxGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDurLimMaxGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDayCntGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmTrdCntGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmTrdPctGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmCstTotUsdGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmCstSpdUsdGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmCstComUsdGet struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
	}
	AnaPrfmDltPnlPctAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPnlPctBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPnlPctDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltScsPctAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltScsPctBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltScsPctDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipPerDayAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipPerDayBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipPerDayDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltUsdPerDayAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltUsdPerDayBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltUsdPerDayDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltScsPerDayAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltScsPerDayBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltScsPerDayDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltOpnPerDayAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltOpnPerDayBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltOpnPerDayDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPnlUsdAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPnlUsdBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPnlUsdDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipAvgAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipAvgBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipAvgDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMdnAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMdnBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMdnDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMinAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMinBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMinDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMaxAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMaxBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipMaxDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipSumAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipSumBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPipSumDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurAvgAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurAvgBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurAvgDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMdnAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMdnBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMdnDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMinAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMinBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMinDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMaxAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMaxBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltDurMaxDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltTrdCntAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltTrdCntBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltTrdCntDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltTrdPctAGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltTrdPctBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltTrdPctDltGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	AnaPrfmDltPthBGet struct {
		Trm bnd.Bnd
		X   AnaPrfmDltXpr
	}
	PenPenClrSetGet struct {
		Trm bnd.Bnd
		X   PenPenXpr
		I0  ClrClrXpr
	}
	PenPenWidSetGet struct {
		Trm bnd.Bnd
		X   PenPenXpr
		I0  UntUntXpr
	}
	PltFltAxisYMinSetGet struct {
		Trm bnd.Bnd
		X   PltFltAxisYXpr
		I0  FltFltXpr
	}
	PltFltAxisYMaxSetGet struct {
		Trm bnd.Bnd
		X   PltFltAxisYXpr
		I0  FltFltXpr
	}
	PltFltAxisYEqiDstSetGet struct {
		Trm bnd.Bnd
		X   PltFltAxisYXpr
		I0  FltFltXpr
	}
	PltStmTitleSetGet struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  StrStrXpr
	}
	PltFltsSctrYGet struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
	}
	PltFltsSctrTitleSetGet struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  StrStrXpr
	}
	PltFltsSctrOutlierSetGet struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  BolBolXpr
	}
	PltHrzPltsGet struct {
		Trm bnd.Bnd
		X   PltHrzXpr
	}
	PltVrtPltsGet struct {
		Trm bnd.Bnd
		X   PltVrtXpr
	}
	PltDpthPltsGet struct {
		Trm bnd.Bnd
		X   PltDpthXpr
	}
	StrZero struct {
		Trm bnd.Bnd
	}
	StrEmpty struct {
		Trm bnd.Bnd
	}
	BolZero struct {
		Trm bnd.Bnd
	}
	BolFls struct {
		Trm bnd.Bnd
	}
	BolTru struct {
		Trm bnd.Bnd
	}
	FltZero struct {
		Trm bnd.Bnd
	}
	FltOne struct {
		Trm bnd.Bnd
	}
	FltNegOne struct {
		Trm bnd.Bnd
	}
	FltHndrd struct {
		Trm bnd.Bnd
	}
	FltMin struct {
		Trm bnd.Bnd
	}
	FltMax struct {
		Trm bnd.Bnd
	}
	FltTiny struct {
		Trm bnd.Bnd
	}
	UntZero struct {
		Trm bnd.Bnd
	}
	UntOne struct {
		Trm bnd.Bnd
	}
	UntMin struct {
		Trm bnd.Bnd
	}
	UntMax struct {
		Trm bnd.Bnd
	}
	IntZero struct {
		Trm bnd.Bnd
	}
	IntOne struct {
		Trm bnd.Bnd
	}
	IntNegOne struct {
		Trm bnd.Bnd
	}
	IntMin struct {
		Trm bnd.Bnd
	}
	IntMax struct {
		Trm bnd.Bnd
	}
	TmeZero struct {
		Trm bnd.Bnd
	}
	TmeOne struct {
		Trm bnd.Bnd
	}
	TmeNegOne struct {
		Trm bnd.Bnd
	}
	TmeMin struct {
		Trm bnd.Bnd
	}
	TmeMax struct {
		Trm bnd.Bnd
	}
	TmeSecond struct {
		Trm bnd.Bnd
	}
	TmeMinute struct {
		Trm bnd.Bnd
	}
	TmeHour struct {
		Trm bnd.Bnd
	}
	TmeDay struct {
		Trm bnd.Bnd
	}
	TmeWeek struct {
		Trm bnd.Bnd
	}
	TmeS1 struct {
		Trm bnd.Bnd
	}
	TmeS5 struct {
		Trm bnd.Bnd
	}
	TmeS10 struct {
		Trm bnd.Bnd
	}
	TmeS15 struct {
		Trm bnd.Bnd
	}
	TmeS20 struct {
		Trm bnd.Bnd
	}
	TmeS30 struct {
		Trm bnd.Bnd
	}
	TmeS40 struct {
		Trm bnd.Bnd
	}
	TmeS50 struct {
		Trm bnd.Bnd
	}
	TmeM1 struct {
		Trm bnd.Bnd
	}
	TmeM5 struct {
		Trm bnd.Bnd
	}
	TmeM10 struct {
		Trm bnd.Bnd
	}
	TmeM15 struct {
		Trm bnd.Bnd
	}
	TmeM20 struct {
		Trm bnd.Bnd
	}
	TmeM30 struct {
		Trm bnd.Bnd
	}
	TmeM40 struct {
		Trm bnd.Bnd
	}
	TmeM50 struct {
		Trm bnd.Bnd
	}
	TmeH1 struct {
		Trm bnd.Bnd
	}
	TmeD1 struct {
		Trm bnd.Bnd
	}
	TmeResolution struct {
		Trm bnd.Bnd
	}
	ClrBlack struct {
		Trm bnd.Bnd
	}
	ClrWhite struct {
		Trm bnd.Bnd
	}
	ClrRed50 struct {
		Trm bnd.Bnd
	}
	ClrRed100 struct {
		Trm bnd.Bnd
	}
	ClrRed200 struct {
		Trm bnd.Bnd
	}
	ClrRed300 struct {
		Trm bnd.Bnd
	}
	ClrRed400 struct {
		Trm bnd.Bnd
	}
	ClrRed500 struct {
		Trm bnd.Bnd
	}
	ClrRed600 struct {
		Trm bnd.Bnd
	}
	ClrRed700 struct {
		Trm bnd.Bnd
	}
	ClrRed800 struct {
		Trm bnd.Bnd
	}
	ClrRed900 struct {
		Trm bnd.Bnd
	}
	ClrRedA100 struct {
		Trm bnd.Bnd
	}
	ClrRedA200 struct {
		Trm bnd.Bnd
	}
	ClrRedA400 struct {
		Trm bnd.Bnd
	}
	ClrRedA700 struct {
		Trm bnd.Bnd
	}
	ClrPink50 struct {
		Trm bnd.Bnd
	}
	ClrPink100 struct {
		Trm bnd.Bnd
	}
	ClrPink200 struct {
		Trm bnd.Bnd
	}
	ClrPink300 struct {
		Trm bnd.Bnd
	}
	ClrPink400 struct {
		Trm bnd.Bnd
	}
	ClrPink500 struct {
		Trm bnd.Bnd
	}
	ClrPink600 struct {
		Trm bnd.Bnd
	}
	ClrPink700 struct {
		Trm bnd.Bnd
	}
	ClrPink800 struct {
		Trm bnd.Bnd
	}
	ClrPink900 struct {
		Trm bnd.Bnd
	}
	ClrPinkA100 struct {
		Trm bnd.Bnd
	}
	ClrPinkA200 struct {
		Trm bnd.Bnd
	}
	ClrPinkA400 struct {
		Trm bnd.Bnd
	}
	ClrPinkA700 struct {
		Trm bnd.Bnd
	}
	ClrPurple50 struct {
		Trm bnd.Bnd
	}
	ClrPurple100 struct {
		Trm bnd.Bnd
	}
	ClrPurple200 struct {
		Trm bnd.Bnd
	}
	ClrPurple300 struct {
		Trm bnd.Bnd
	}
	ClrPurple400 struct {
		Trm bnd.Bnd
	}
	ClrPurple500 struct {
		Trm bnd.Bnd
	}
	ClrPurple600 struct {
		Trm bnd.Bnd
	}
	ClrPurple700 struct {
		Trm bnd.Bnd
	}
	ClrPurple800 struct {
		Trm bnd.Bnd
	}
	ClrPurple900 struct {
		Trm bnd.Bnd
	}
	ClrPurpleA100 struct {
		Trm bnd.Bnd
	}
	ClrPurpleA200 struct {
		Trm bnd.Bnd
	}
	ClrPurpleA400 struct {
		Trm bnd.Bnd
	}
	ClrPurpleA700 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple50 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple100 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple200 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple300 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple400 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple500 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple600 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple700 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple800 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurple900 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurpleA100 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurpleA200 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurpleA400 struct {
		Trm bnd.Bnd
	}
	ClrDeepPurpleA700 struct {
		Trm bnd.Bnd
	}
	ClrIndigo50 struct {
		Trm bnd.Bnd
	}
	ClrIndigo100 struct {
		Trm bnd.Bnd
	}
	ClrIndigo200 struct {
		Trm bnd.Bnd
	}
	ClrIndigo300 struct {
		Trm bnd.Bnd
	}
	ClrIndigo400 struct {
		Trm bnd.Bnd
	}
	ClrIndigo500 struct {
		Trm bnd.Bnd
	}
	ClrIndigo600 struct {
		Trm bnd.Bnd
	}
	ClrIndigo700 struct {
		Trm bnd.Bnd
	}
	ClrIndigo800 struct {
		Trm bnd.Bnd
	}
	ClrIndigo900 struct {
		Trm bnd.Bnd
	}
	ClrIndigoA100 struct {
		Trm bnd.Bnd
	}
	ClrIndigoA200 struct {
		Trm bnd.Bnd
	}
	ClrIndigoA400 struct {
		Trm bnd.Bnd
	}
	ClrIndigoA700 struct {
		Trm bnd.Bnd
	}
	ClrBlue50 struct {
		Trm bnd.Bnd
	}
	ClrBlue100 struct {
		Trm bnd.Bnd
	}
	ClrBlue200 struct {
		Trm bnd.Bnd
	}
	ClrBlue300 struct {
		Trm bnd.Bnd
	}
	ClrBlue400 struct {
		Trm bnd.Bnd
	}
	ClrBlue500 struct {
		Trm bnd.Bnd
	}
	ClrBlue600 struct {
		Trm bnd.Bnd
	}
	ClrBlue700 struct {
		Trm bnd.Bnd
	}
	ClrBlue800 struct {
		Trm bnd.Bnd
	}
	ClrBlue900 struct {
		Trm bnd.Bnd
	}
	ClrBlueA100 struct {
		Trm bnd.Bnd
	}
	ClrBlueA200 struct {
		Trm bnd.Bnd
	}
	ClrBlueA400 struct {
		Trm bnd.Bnd
	}
	ClrBlueA700 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue50 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue100 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue200 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue300 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue400 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue500 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue600 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue700 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue800 struct {
		Trm bnd.Bnd
	}
	ClrLightBlue900 struct {
		Trm bnd.Bnd
	}
	ClrLightBlueA100 struct {
		Trm bnd.Bnd
	}
	ClrLightBlueA200 struct {
		Trm bnd.Bnd
	}
	ClrLightBlueA400 struct {
		Trm bnd.Bnd
	}
	ClrLightBlueA700 struct {
		Trm bnd.Bnd
	}
	ClrCyan50 struct {
		Trm bnd.Bnd
	}
	ClrCyan100 struct {
		Trm bnd.Bnd
	}
	ClrCyan200 struct {
		Trm bnd.Bnd
	}
	ClrCyan300 struct {
		Trm bnd.Bnd
	}
	ClrCyan400 struct {
		Trm bnd.Bnd
	}
	ClrCyan500 struct {
		Trm bnd.Bnd
	}
	ClrCyan600 struct {
		Trm bnd.Bnd
	}
	ClrCyan700 struct {
		Trm bnd.Bnd
	}
	ClrCyan800 struct {
		Trm bnd.Bnd
	}
	ClrCyan900 struct {
		Trm bnd.Bnd
	}
	ClrCyanA100 struct {
		Trm bnd.Bnd
	}
	ClrCyanA200 struct {
		Trm bnd.Bnd
	}
	ClrCyanA400 struct {
		Trm bnd.Bnd
	}
	ClrCyanA700 struct {
		Trm bnd.Bnd
	}
	ClrTeal50 struct {
		Trm bnd.Bnd
	}
	ClrTeal100 struct {
		Trm bnd.Bnd
	}
	ClrTeal200 struct {
		Trm bnd.Bnd
	}
	ClrTeal300 struct {
		Trm bnd.Bnd
	}
	ClrTeal400 struct {
		Trm bnd.Bnd
	}
	ClrTeal500 struct {
		Trm bnd.Bnd
	}
	ClrTeal600 struct {
		Trm bnd.Bnd
	}
	ClrTeal700 struct {
		Trm bnd.Bnd
	}
	ClrTeal800 struct {
		Trm bnd.Bnd
	}
	ClrTeal900 struct {
		Trm bnd.Bnd
	}
	ClrTealA100 struct {
		Trm bnd.Bnd
	}
	ClrTealA200 struct {
		Trm bnd.Bnd
	}
	ClrTealA400 struct {
		Trm bnd.Bnd
	}
	ClrTealA700 struct {
		Trm bnd.Bnd
	}
	ClrGreen50 struct {
		Trm bnd.Bnd
	}
	ClrGreen100 struct {
		Trm bnd.Bnd
	}
	ClrGreen200 struct {
		Trm bnd.Bnd
	}
	ClrGreen300 struct {
		Trm bnd.Bnd
	}
	ClrGreen400 struct {
		Trm bnd.Bnd
	}
	ClrGreen500 struct {
		Trm bnd.Bnd
	}
	ClrGreen600 struct {
		Trm bnd.Bnd
	}
	ClrGreen700 struct {
		Trm bnd.Bnd
	}
	ClrGreen800 struct {
		Trm bnd.Bnd
	}
	ClrGreen900 struct {
		Trm bnd.Bnd
	}
	ClrGreenA100 struct {
		Trm bnd.Bnd
	}
	ClrGreenA200 struct {
		Trm bnd.Bnd
	}
	ClrGreenA400 struct {
		Trm bnd.Bnd
	}
	ClrGreenA700 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen50 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen100 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen200 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen300 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen400 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen500 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen600 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen700 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen800 struct {
		Trm bnd.Bnd
	}
	ClrLightGreen900 struct {
		Trm bnd.Bnd
	}
	ClrLightGreenA100 struct {
		Trm bnd.Bnd
	}
	ClrLightGreenA200 struct {
		Trm bnd.Bnd
	}
	ClrLightGreenA400 struct {
		Trm bnd.Bnd
	}
	ClrLightGreenA700 struct {
		Trm bnd.Bnd
	}
	ClrLime50 struct {
		Trm bnd.Bnd
	}
	ClrLime100 struct {
		Trm bnd.Bnd
	}
	ClrLime200 struct {
		Trm bnd.Bnd
	}
	ClrLime300 struct {
		Trm bnd.Bnd
	}
	ClrLime400 struct {
		Trm bnd.Bnd
	}
	ClrLime500 struct {
		Trm bnd.Bnd
	}
	ClrLime600 struct {
		Trm bnd.Bnd
	}
	ClrLime700 struct {
		Trm bnd.Bnd
	}
	ClrLime800 struct {
		Trm bnd.Bnd
	}
	ClrLime900 struct {
		Trm bnd.Bnd
	}
	ClrLimeA100 struct {
		Trm bnd.Bnd
	}
	ClrLimeA200 struct {
		Trm bnd.Bnd
	}
	ClrLimeA400 struct {
		Trm bnd.Bnd
	}
	ClrLimeA700 struct {
		Trm bnd.Bnd
	}
	ClrYellow50 struct {
		Trm bnd.Bnd
	}
	ClrYellow100 struct {
		Trm bnd.Bnd
	}
	ClrYellow200 struct {
		Trm bnd.Bnd
	}
	ClrYellow300 struct {
		Trm bnd.Bnd
	}
	ClrYellow400 struct {
		Trm bnd.Bnd
	}
	ClrYellow500 struct {
		Trm bnd.Bnd
	}
	ClrYellow600 struct {
		Trm bnd.Bnd
	}
	ClrYellow700 struct {
		Trm bnd.Bnd
	}
	ClrYellow800 struct {
		Trm bnd.Bnd
	}
	ClrYellow900 struct {
		Trm bnd.Bnd
	}
	ClrYellowA100 struct {
		Trm bnd.Bnd
	}
	ClrYellowA200 struct {
		Trm bnd.Bnd
	}
	ClrYellowA400 struct {
		Trm bnd.Bnd
	}
	ClrYellowA700 struct {
		Trm bnd.Bnd
	}
	ClrAmber50 struct {
		Trm bnd.Bnd
	}
	ClrAmber100 struct {
		Trm bnd.Bnd
	}
	ClrAmber200 struct {
		Trm bnd.Bnd
	}
	ClrAmber300 struct {
		Trm bnd.Bnd
	}
	ClrAmber400 struct {
		Trm bnd.Bnd
	}
	ClrAmber500 struct {
		Trm bnd.Bnd
	}
	ClrAmber600 struct {
		Trm bnd.Bnd
	}
	ClrAmber700 struct {
		Trm bnd.Bnd
	}
	ClrAmber800 struct {
		Trm bnd.Bnd
	}
	ClrAmber900 struct {
		Trm bnd.Bnd
	}
	ClrAmberA100 struct {
		Trm bnd.Bnd
	}
	ClrAmberA200 struct {
		Trm bnd.Bnd
	}
	ClrAmberA400 struct {
		Trm bnd.Bnd
	}
	ClrAmberA700 struct {
		Trm bnd.Bnd
	}
	ClrOrange50 struct {
		Trm bnd.Bnd
	}
	ClrOrange100 struct {
		Trm bnd.Bnd
	}
	ClrOrange200 struct {
		Trm bnd.Bnd
	}
	ClrOrange300 struct {
		Trm bnd.Bnd
	}
	ClrOrange400 struct {
		Trm bnd.Bnd
	}
	ClrOrange500 struct {
		Trm bnd.Bnd
	}
	ClrOrange600 struct {
		Trm bnd.Bnd
	}
	ClrOrange700 struct {
		Trm bnd.Bnd
	}
	ClrOrange800 struct {
		Trm bnd.Bnd
	}
	ClrOrange900 struct {
		Trm bnd.Bnd
	}
	ClrOrangeA100 struct {
		Trm bnd.Bnd
	}
	ClrOrangeA200 struct {
		Trm bnd.Bnd
	}
	ClrOrangeA400 struct {
		Trm bnd.Bnd
	}
	ClrOrangeA700 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange50 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange100 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange200 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange300 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange400 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange500 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange600 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange700 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange800 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrange900 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrangeA100 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrangeA200 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrangeA400 struct {
		Trm bnd.Bnd
	}
	ClrDeepOrangeA700 struct {
		Trm bnd.Bnd
	}
	ClrBrown50 struct {
		Trm bnd.Bnd
	}
	ClrBrown100 struct {
		Trm bnd.Bnd
	}
	ClrBrown200 struct {
		Trm bnd.Bnd
	}
	ClrBrown300 struct {
		Trm bnd.Bnd
	}
	ClrBrown400 struct {
		Trm bnd.Bnd
	}
	ClrBrown500 struct {
		Trm bnd.Bnd
	}
	ClrBrown600 struct {
		Trm bnd.Bnd
	}
	ClrBrown700 struct {
		Trm bnd.Bnd
	}
	ClrBrown800 struct {
		Trm bnd.Bnd
	}
	ClrBrown900 struct {
		Trm bnd.Bnd
	}
	ClrGrey50 struct {
		Trm bnd.Bnd
	}
	ClrGrey100 struct {
		Trm bnd.Bnd
	}
	ClrGrey200 struct {
		Trm bnd.Bnd
	}
	ClrGrey300 struct {
		Trm bnd.Bnd
	}
	ClrGrey400 struct {
		Trm bnd.Bnd
	}
	ClrGrey500 struct {
		Trm bnd.Bnd
	}
	ClrGrey600 struct {
		Trm bnd.Bnd
	}
	ClrGrey700 struct {
		Trm bnd.Bnd
	}
	ClrGrey800 struct {
		Trm bnd.Bnd
	}
	ClrGrey900 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey50 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey100 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey200 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey300 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey400 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey500 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey600 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey700 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey800 struct {
		Trm bnd.Bnd
	}
	ClrBlueGrey900 struct {
		Trm bnd.Bnd
	}
	PenBlack struct {
		Trm bnd.Bnd
	}
	PenWhite struct {
		Trm bnd.Bnd
	}
	PenRed50 struct {
		Trm bnd.Bnd
	}
	PenRed100 struct {
		Trm bnd.Bnd
	}
	PenRed200 struct {
		Trm bnd.Bnd
	}
	PenRed300 struct {
		Trm bnd.Bnd
	}
	PenRed400 struct {
		Trm bnd.Bnd
	}
	PenRed500 struct {
		Trm bnd.Bnd
	}
	PenRed600 struct {
		Trm bnd.Bnd
	}
	PenRed700 struct {
		Trm bnd.Bnd
	}
	PenRed800 struct {
		Trm bnd.Bnd
	}
	PenRed900 struct {
		Trm bnd.Bnd
	}
	PenRedA100 struct {
		Trm bnd.Bnd
	}
	PenRedA200 struct {
		Trm bnd.Bnd
	}
	PenRedA400 struct {
		Trm bnd.Bnd
	}
	PenRedA700 struct {
		Trm bnd.Bnd
	}
	PenPink50 struct {
		Trm bnd.Bnd
	}
	PenPink100 struct {
		Trm bnd.Bnd
	}
	PenPink200 struct {
		Trm bnd.Bnd
	}
	PenPink300 struct {
		Trm bnd.Bnd
	}
	PenPink400 struct {
		Trm bnd.Bnd
	}
	PenPink500 struct {
		Trm bnd.Bnd
	}
	PenPink600 struct {
		Trm bnd.Bnd
	}
	PenPink700 struct {
		Trm bnd.Bnd
	}
	PenPink800 struct {
		Trm bnd.Bnd
	}
	PenPink900 struct {
		Trm bnd.Bnd
	}
	PenPinkA100 struct {
		Trm bnd.Bnd
	}
	PenPinkA200 struct {
		Trm bnd.Bnd
	}
	PenPinkA400 struct {
		Trm bnd.Bnd
	}
	PenPinkA700 struct {
		Trm bnd.Bnd
	}
	PenPurple50 struct {
		Trm bnd.Bnd
	}
	PenPurple100 struct {
		Trm bnd.Bnd
	}
	PenPurple200 struct {
		Trm bnd.Bnd
	}
	PenPurple300 struct {
		Trm bnd.Bnd
	}
	PenPurple400 struct {
		Trm bnd.Bnd
	}
	PenPurple500 struct {
		Trm bnd.Bnd
	}
	PenPurple600 struct {
		Trm bnd.Bnd
	}
	PenPurple700 struct {
		Trm bnd.Bnd
	}
	PenPurple800 struct {
		Trm bnd.Bnd
	}
	PenPurple900 struct {
		Trm bnd.Bnd
	}
	PenPurpleA100 struct {
		Trm bnd.Bnd
	}
	PenPurpleA200 struct {
		Trm bnd.Bnd
	}
	PenPurpleA400 struct {
		Trm bnd.Bnd
	}
	PenPurpleA700 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple50 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple100 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple200 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple300 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple400 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple500 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple600 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple700 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple800 struct {
		Trm bnd.Bnd
	}
	PenDeepPurple900 struct {
		Trm bnd.Bnd
	}
	PenDeepPurpleA100 struct {
		Trm bnd.Bnd
	}
	PenDeepPurpleA200 struct {
		Trm bnd.Bnd
	}
	PenDeepPurpleA400 struct {
		Trm bnd.Bnd
	}
	PenDeepPurpleA700 struct {
		Trm bnd.Bnd
	}
	PenIndigo50 struct {
		Trm bnd.Bnd
	}
	PenIndigo100 struct {
		Trm bnd.Bnd
	}
	PenIndigo200 struct {
		Trm bnd.Bnd
	}
	PenIndigo300 struct {
		Trm bnd.Bnd
	}
	PenIndigo400 struct {
		Trm bnd.Bnd
	}
	PenIndigo500 struct {
		Trm bnd.Bnd
	}
	PenIndigo600 struct {
		Trm bnd.Bnd
	}
	PenIndigo700 struct {
		Trm bnd.Bnd
	}
	PenIndigo800 struct {
		Trm bnd.Bnd
	}
	PenIndigo900 struct {
		Trm bnd.Bnd
	}
	PenIndigoA100 struct {
		Trm bnd.Bnd
	}
	PenIndigoA200 struct {
		Trm bnd.Bnd
	}
	PenIndigoA400 struct {
		Trm bnd.Bnd
	}
	PenIndigoA700 struct {
		Trm bnd.Bnd
	}
	PenBlue50 struct {
		Trm bnd.Bnd
	}
	PenBlue100 struct {
		Trm bnd.Bnd
	}
	PenBlue200 struct {
		Trm bnd.Bnd
	}
	PenBlue300 struct {
		Trm bnd.Bnd
	}
	PenBlue400 struct {
		Trm bnd.Bnd
	}
	PenBlue500 struct {
		Trm bnd.Bnd
	}
	PenBlue600 struct {
		Trm bnd.Bnd
	}
	PenBlue700 struct {
		Trm bnd.Bnd
	}
	PenBlue800 struct {
		Trm bnd.Bnd
	}
	PenBlue900 struct {
		Trm bnd.Bnd
	}
	PenBlueA100 struct {
		Trm bnd.Bnd
	}
	PenBlueA200 struct {
		Trm bnd.Bnd
	}
	PenBlueA400 struct {
		Trm bnd.Bnd
	}
	PenBlueA700 struct {
		Trm bnd.Bnd
	}
	PenLightBlue50 struct {
		Trm bnd.Bnd
	}
	PenLightBlue100 struct {
		Trm bnd.Bnd
	}
	PenLightBlue200 struct {
		Trm bnd.Bnd
	}
	PenLightBlue300 struct {
		Trm bnd.Bnd
	}
	PenLightBlue400 struct {
		Trm bnd.Bnd
	}
	PenLightBlue500 struct {
		Trm bnd.Bnd
	}
	PenLightBlue600 struct {
		Trm bnd.Bnd
	}
	PenLightBlue700 struct {
		Trm bnd.Bnd
	}
	PenLightBlue800 struct {
		Trm bnd.Bnd
	}
	PenLightBlue900 struct {
		Trm bnd.Bnd
	}
	PenLightBlueA100 struct {
		Trm bnd.Bnd
	}
	PenLightBlueA200 struct {
		Trm bnd.Bnd
	}
	PenLightBlueA400 struct {
		Trm bnd.Bnd
	}
	PenLightBlueA700 struct {
		Trm bnd.Bnd
	}
	PenCyan50 struct {
		Trm bnd.Bnd
	}
	PenCyan100 struct {
		Trm bnd.Bnd
	}
	PenCyan200 struct {
		Trm bnd.Bnd
	}
	PenCyan300 struct {
		Trm bnd.Bnd
	}
	PenCyan400 struct {
		Trm bnd.Bnd
	}
	PenCyan500 struct {
		Trm bnd.Bnd
	}
	PenCyan600 struct {
		Trm bnd.Bnd
	}
	PenCyan700 struct {
		Trm bnd.Bnd
	}
	PenCyan800 struct {
		Trm bnd.Bnd
	}
	PenCyan900 struct {
		Trm bnd.Bnd
	}
	PenCyanA100 struct {
		Trm bnd.Bnd
	}
	PenCyanA200 struct {
		Trm bnd.Bnd
	}
	PenCyanA400 struct {
		Trm bnd.Bnd
	}
	PenCyanA700 struct {
		Trm bnd.Bnd
	}
	PenTeal50 struct {
		Trm bnd.Bnd
	}
	PenTeal100 struct {
		Trm bnd.Bnd
	}
	PenTeal200 struct {
		Trm bnd.Bnd
	}
	PenTeal300 struct {
		Trm bnd.Bnd
	}
	PenTeal400 struct {
		Trm bnd.Bnd
	}
	PenTeal500 struct {
		Trm bnd.Bnd
	}
	PenTeal600 struct {
		Trm bnd.Bnd
	}
	PenTeal700 struct {
		Trm bnd.Bnd
	}
	PenTeal800 struct {
		Trm bnd.Bnd
	}
	PenTeal900 struct {
		Trm bnd.Bnd
	}
	PenTealA100 struct {
		Trm bnd.Bnd
	}
	PenTealA200 struct {
		Trm bnd.Bnd
	}
	PenTealA400 struct {
		Trm bnd.Bnd
	}
	PenTealA700 struct {
		Trm bnd.Bnd
	}
	PenGreen50 struct {
		Trm bnd.Bnd
	}
	PenGreen100 struct {
		Trm bnd.Bnd
	}
	PenGreen200 struct {
		Trm bnd.Bnd
	}
	PenGreen300 struct {
		Trm bnd.Bnd
	}
	PenGreen400 struct {
		Trm bnd.Bnd
	}
	PenGreen500 struct {
		Trm bnd.Bnd
	}
	PenGreen600 struct {
		Trm bnd.Bnd
	}
	PenGreen700 struct {
		Trm bnd.Bnd
	}
	PenGreen800 struct {
		Trm bnd.Bnd
	}
	PenGreen900 struct {
		Trm bnd.Bnd
	}
	PenGreenA100 struct {
		Trm bnd.Bnd
	}
	PenGreenA200 struct {
		Trm bnd.Bnd
	}
	PenGreenA400 struct {
		Trm bnd.Bnd
	}
	PenGreenA700 struct {
		Trm bnd.Bnd
	}
	PenLightGreen50 struct {
		Trm bnd.Bnd
	}
	PenLightGreen100 struct {
		Trm bnd.Bnd
	}
	PenLightGreen200 struct {
		Trm bnd.Bnd
	}
	PenLightGreen300 struct {
		Trm bnd.Bnd
	}
	PenLightGreen400 struct {
		Trm bnd.Bnd
	}
	PenLightGreen500 struct {
		Trm bnd.Bnd
	}
	PenLightGreen600 struct {
		Trm bnd.Bnd
	}
	PenLightGreen700 struct {
		Trm bnd.Bnd
	}
	PenLightGreen800 struct {
		Trm bnd.Bnd
	}
	PenLightGreen900 struct {
		Trm bnd.Bnd
	}
	PenLightGreenA100 struct {
		Trm bnd.Bnd
	}
	PenLightGreenA200 struct {
		Trm bnd.Bnd
	}
	PenLightGreenA400 struct {
		Trm bnd.Bnd
	}
	PenLightGreenA700 struct {
		Trm bnd.Bnd
	}
	PenLime50 struct {
		Trm bnd.Bnd
	}
	PenLime100 struct {
		Trm bnd.Bnd
	}
	PenLime200 struct {
		Trm bnd.Bnd
	}
	PenLime300 struct {
		Trm bnd.Bnd
	}
	PenLime400 struct {
		Trm bnd.Bnd
	}
	PenLime500 struct {
		Trm bnd.Bnd
	}
	PenLime600 struct {
		Trm bnd.Bnd
	}
	PenLime700 struct {
		Trm bnd.Bnd
	}
	PenLime800 struct {
		Trm bnd.Bnd
	}
	PenLime900 struct {
		Trm bnd.Bnd
	}
	PenLimeA100 struct {
		Trm bnd.Bnd
	}
	PenLimeA200 struct {
		Trm bnd.Bnd
	}
	PenLimeA400 struct {
		Trm bnd.Bnd
	}
	PenLimeA700 struct {
		Trm bnd.Bnd
	}
	PenYellow50 struct {
		Trm bnd.Bnd
	}
	PenYellow100 struct {
		Trm bnd.Bnd
	}
	PenYellow200 struct {
		Trm bnd.Bnd
	}
	PenYellow300 struct {
		Trm bnd.Bnd
	}
	PenYellow400 struct {
		Trm bnd.Bnd
	}
	PenYellow500 struct {
		Trm bnd.Bnd
	}
	PenYellow600 struct {
		Trm bnd.Bnd
	}
	PenYellow700 struct {
		Trm bnd.Bnd
	}
	PenYellow800 struct {
		Trm bnd.Bnd
	}
	PenYellow900 struct {
		Trm bnd.Bnd
	}
	PenYellowA100 struct {
		Trm bnd.Bnd
	}
	PenYellowA200 struct {
		Trm bnd.Bnd
	}
	PenYellowA400 struct {
		Trm bnd.Bnd
	}
	PenYellowA700 struct {
		Trm bnd.Bnd
	}
	PenAmber50 struct {
		Trm bnd.Bnd
	}
	PenAmber100 struct {
		Trm bnd.Bnd
	}
	PenAmber200 struct {
		Trm bnd.Bnd
	}
	PenAmber300 struct {
		Trm bnd.Bnd
	}
	PenAmber400 struct {
		Trm bnd.Bnd
	}
	PenAmber500 struct {
		Trm bnd.Bnd
	}
	PenAmber600 struct {
		Trm bnd.Bnd
	}
	PenAmber700 struct {
		Trm bnd.Bnd
	}
	PenAmber800 struct {
		Trm bnd.Bnd
	}
	PenAmber900 struct {
		Trm bnd.Bnd
	}
	PenAmberA100 struct {
		Trm bnd.Bnd
	}
	PenAmberA200 struct {
		Trm bnd.Bnd
	}
	PenAmberA400 struct {
		Trm bnd.Bnd
	}
	PenAmberA700 struct {
		Trm bnd.Bnd
	}
	PenOrange50 struct {
		Trm bnd.Bnd
	}
	PenOrange100 struct {
		Trm bnd.Bnd
	}
	PenOrange200 struct {
		Trm bnd.Bnd
	}
	PenOrange300 struct {
		Trm bnd.Bnd
	}
	PenOrange400 struct {
		Trm bnd.Bnd
	}
	PenOrange500 struct {
		Trm bnd.Bnd
	}
	PenOrange600 struct {
		Trm bnd.Bnd
	}
	PenOrange700 struct {
		Trm bnd.Bnd
	}
	PenOrange800 struct {
		Trm bnd.Bnd
	}
	PenOrange900 struct {
		Trm bnd.Bnd
	}
	PenOrangeA100 struct {
		Trm bnd.Bnd
	}
	PenOrangeA200 struct {
		Trm bnd.Bnd
	}
	PenOrangeA400 struct {
		Trm bnd.Bnd
	}
	PenOrangeA700 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange50 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange100 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange200 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange300 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange400 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange500 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange600 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange700 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange800 struct {
		Trm bnd.Bnd
	}
	PenDeepOrange900 struct {
		Trm bnd.Bnd
	}
	PenDeepOrangeA100 struct {
		Trm bnd.Bnd
	}
	PenDeepOrangeA200 struct {
		Trm bnd.Bnd
	}
	PenDeepOrangeA400 struct {
		Trm bnd.Bnd
	}
	PenDeepOrangeA700 struct {
		Trm bnd.Bnd
	}
	PenBrown50 struct {
		Trm bnd.Bnd
	}
	PenBrown100 struct {
		Trm bnd.Bnd
	}
	PenBrown200 struct {
		Trm bnd.Bnd
	}
	PenBrown300 struct {
		Trm bnd.Bnd
	}
	PenBrown400 struct {
		Trm bnd.Bnd
	}
	PenBrown500 struct {
		Trm bnd.Bnd
	}
	PenBrown600 struct {
		Trm bnd.Bnd
	}
	PenBrown700 struct {
		Trm bnd.Bnd
	}
	PenBrown800 struct {
		Trm bnd.Bnd
	}
	PenBrown900 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey50 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey100 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey200 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey300 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey400 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey500 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey600 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey700 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey800 struct {
		Trm bnd.Bnd
	}
	PenBlueGrey900 struct {
		Trm bnd.Bnd
	}
	PenGrey50 struct {
		Trm bnd.Bnd
	}
	PenGrey100 struct {
		Trm bnd.Bnd
	}
	PenGrey200 struct {
		Trm bnd.Bnd
	}
	PenGrey300 struct {
		Trm bnd.Bnd
	}
	PenGrey400 struct {
		Trm bnd.Bnd
	}
	PenGrey500 struct {
		Trm bnd.Bnd
	}
	PenGrey600 struct {
		Trm bnd.Bnd
	}
	PenGrey700 struct {
		Trm bnd.Bnd
	}
	PenGrey800 struct {
		Trm bnd.Bnd
	}
	PenGrey900 struct {
		Trm bnd.Bnd
	}
	FltScl struct {
		Trm bnd.Bnd
	}
	UntStkWidth struct {
		Trm bnd.Bnd
	}
	UntShpRadius struct {
		Trm bnd.Bnd
	}
	UntAxisPad struct {
		Trm bnd.Bnd
	}
	UntBarPad struct {
		Trm bnd.Bnd
	}
	UntLen struct {
		Trm bnd.Bnd
	}
	UntPad struct {
		Trm bnd.Bnd
	}
	ClrBakClr struct {
		Trm bnd.Bnd
	}
	ClrBrdrClr struct {
		Trm bnd.Bnd
	}
	UntBrdrLen struct {
		Trm bnd.Bnd
	}
	UntInrvlTxtLen struct {
		Trm bnd.Bnd
	}
	ClrInrvlTxtClrX struct {
		Trm bnd.Bnd
	}
	ClrInrvlTxtClrY struct {
		Trm bnd.Bnd
	}
	ClrMsgClr struct {
		Trm bnd.Bnd
	}
	ClrTitleClr struct {
		Trm bnd.Bnd
	}
	ClrPrfClr struct {
		Trm bnd.Bnd
	}
	ClrLosClr struct {
		Trm bnd.Bnd
	}
	PenPrfPen struct {
		Trm bnd.Bnd
	}
	PenLosPen struct {
		Trm bnd.Bnd
	}
	FltOutlierLim struct {
		Trm bnd.Bnd
	}
	LogIfo struct {
		Trm bnd.Bnd
		I0  []Xpr
	}
	LogIfof struct {
		Trm bnd.Bnd
		I0  StrStrXpr
		I1  []Xpr
	}
	StrFmt struct {
		Trm bnd.Bnd
		I0  StrStrXpr
		I1  []Xpr
	}
	TmeNow struct {
		Trm bnd.Bnd
	}
	FltNewRng struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
	}
	FltNewRngArnd struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
	}
	FltNewRngFul struct {
		Trm bnd.Bnd
	}
	TmeNewRng struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
	}
	TmeNewRngArnd struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
	}
	TmeNewRngFul struct {
		Trm bnd.Bnd
	}
	StrsNew struct {
		Trm bnd.Bnd
		I0  []StrStrXpr
	}
	StrsMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	StrsMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	BolsNew struct {
		Trm bnd.Bnd
		I0  []BolBolXpr
	}
	BolsMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	BolsMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	FltsNew struct {
		Trm bnd.Bnd
		I0  []FltFltXpr
	}
	FltsMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	FltsMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	FltsAddsLss struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsAddsLeq struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsSubsGtr struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsSubsGeq struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsMulsLss struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsMulsLeq struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsDivsGtr struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsDivsGeq struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	FltsFibsLeq struct {
		Trm bnd.Bnd
		I0  FltFltXpr
	}
	UntsNew struct {
		Trm bnd.Bnd
		I0  []UntUntXpr
	}
	UntsMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	UntsMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	UntsAddsLss struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsAddsLeq struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsSubsGtr struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsSubsGeq struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsMulsLss struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsMulsLeq struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsDivsGtr struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsDivsGeq struct {
		Trm bnd.Bnd
		I0  UntUntXpr
		I1  UntUntXpr
		I2  UntUntXpr
	}
	UntsFibsLeq struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	IntsNew struct {
		Trm bnd.Bnd
		I0  []IntIntXpr
	}
	IntsMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	IntsMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	TmesNew struct {
		Trm bnd.Bnd
		I0  []TmeTmeXpr
	}
	TmesMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	TmesMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	TmesAddsLss struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesAddsLeq struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesSubsGtr struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesSubsGeq struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesMulsLss struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesMulsLeq struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesDivsGtr struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesDivsGeq struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
		I1  TmeTmeXpr
		I2  TmeTmeXpr
	}
	TmesFibsLeq struct {
		Trm bnd.Bnd
		I0  TmeTmeXpr
	}
	BndsNew struct {
		Trm bnd.Bnd
		I0  []BndBndXpr
	}
	BndsMake struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	BndsMakeEmp struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	TmeNewRngs struct {
		Trm bnd.Bnd
		I0  []TmeRngXpr
	}
	TmeMakeRngs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	TmeMakeEmpRngs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	AnaNewTrds struct {
		Trm bnd.Bnd
		I0  []AnaTrdXpr
	}
	AnaMakeTrds struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	AnaMakeEmpTrds struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	AnaNewPrfms struct {
		Trm bnd.Bnd
		I0  []AnaPrfmXpr
	}
	AnaMakePrfms struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	AnaMakeEmpPrfms struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstOan struct {
		Trm bnd.Bnd
	}
	HstNewPrvs struct {
		Trm bnd.Bnd
		I0  []HstPrvXpr
	}
	HstMakePrvs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpPrvs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstNewInstrs struct {
		Trm bnd.Bnd
		I0  []HstInstrXpr
	}
	HstMakeInstrs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpInstrs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstNewInrvls struct {
		Trm bnd.Bnd
		I0  []HstInrvlXpr
	}
	HstMakeInrvls struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpInrvls struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstNewSides struct {
		Trm bnd.Bnd
		I0  []HstSideXpr
	}
	HstMakeSides struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpSides struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstNewStms struct {
		Trm bnd.Bnd
		I0  []HstStmXpr
	}
	HstMakeStms struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpStms struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstNewCnds struct {
		Trm bnd.Bnd
		I0  []HstCndXpr
	}
	HstMakeCnds struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpCnds struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstNewStgys struct {
		Trm bnd.Bnd
		I0  []HstStgyXpr
	}
	HstMakeStgys struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	HstMakeEmpStgys struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltOan struct {
		Trm bnd.Bnd
	}
	RltNewPrvs struct {
		Trm bnd.Bnd
		I0  []RltPrvXpr
	}
	RltMakePrvs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpPrvs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltNewInstrs struct {
		Trm bnd.Bnd
		I0  []RltInstrXpr
	}
	RltMakeInstrs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpInstrs struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltNewInrvls struct {
		Trm bnd.Bnd
		I0  []RltInrvlXpr
	}
	RltMakeInrvls struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpInrvls struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltNewSides struct {
		Trm bnd.Bnd
		I0  []RltSideXpr
	}
	RltMakeSides struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpSides struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltNewStms struct {
		Trm bnd.Bnd
		I0  []RltStmXpr
	}
	RltMakeStms struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpStms struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltNewCnds struct {
		Trm bnd.Bnd
		I0  []RltCndXpr
	}
	RltMakeCnds struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpCnds struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltNewStgys struct {
		Trm bnd.Bnd
		I0  []RltStgyXpr
	}
	RltMakeStgys struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	RltMakeEmpStgys struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	ClrRgba struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
		I3  FltFltXpr
	}
	ClrRgb struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
	}
	ClrHex struct {
		Trm bnd.Bnd
		I0  StrStrXpr
	}
	PenNew struct {
		Trm bnd.Bnd
		I0  ClrClrXpr
		I1  []UntUntXpr
	}
	PenRgba struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
		I3  FltFltXpr
		I4  []UntUntXpr
	}
	PenRgb struct {
		Trm bnd.Bnd
		I0  FltFltXpr
		I1  FltFltXpr
		I2  FltFltXpr
		I3  []UntUntXpr
	}
	PenHex struct {
		Trm bnd.Bnd
		I0  StrStrXpr
		I1  []UntUntXpr
	}
	PenNewPens struct {
		Trm bnd.Bnd
		I0  []PenPenXpr
	}
	PenMakePens struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	PenMakeEmpPens struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	PltNewPlts struct {
		Trm bnd.Bnd
		I0  []PltPltXpr
	}
	PltMakePlts struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	PltMakeEmpPlts struct {
		Trm bnd.Bnd
		I0  UntUntXpr
	}
	PltNewStm struct {
		Trm bnd.Bnd
	}
	PltNewFltsSctr struct {
		Trm bnd.Bnd
	}
	PltNewFltsSctrDist struct {
		Trm bnd.Bnd
	}
	PltNewHrz struct {
		Trm bnd.Bnd
		I0  []PltPltXpr
	}
	PltNewVrt struct {
		Trm bnd.Bnd
		I0  []PltPltXpr
	}
	PltNewDpth struct {
		Trm bnd.Bnd
		I0  []PltPltXpr
	}
	SysNewMu struct {
		Trm bnd.Bnd
	}
	StrStrLower struct {
		Trm bnd.Bnd
		X   StrStrXpr
	}
	StrStrUpper struct {
		Trm bnd.Bnd
		X   StrStrXpr
	}
	StrStrEql struct {
		Trm bnd.Bnd
		X   StrStrXpr
		I0  StrStrXpr
	}
	StrStrNeq struct {
		Trm bnd.Bnd
		X   StrStrXpr
		I0  StrStrXpr
	}
	StrStrLss struct {
		Trm bnd.Bnd
		X   StrStrXpr
		I0  StrStrXpr
	}
	StrStrGtr struct {
		Trm bnd.Bnd
		X   StrStrXpr
		I0  StrStrXpr
	}
	StrStrLeq struct {
		Trm bnd.Bnd
		X   StrStrXpr
		I0  StrStrXpr
	}
	StrStrGeq struct {
		Trm bnd.Bnd
		X   StrStrXpr
		I0  StrStrXpr
	}
	BolBolNot struct {
		Trm bnd.Bnd
		X   BolBolXpr
	}
	BolBolEql struct {
		Trm bnd.Bnd
		X   BolBolXpr
		I0  BolBolXpr
	}
	BolBolNeq struct {
		Trm bnd.Bnd
		X   BolBolXpr
		I0  BolBolXpr
	}
	FltFltEql struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltNeq struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltTrnc struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  UntUntXpr
	}
	FltFltIsNaN struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltIsInfPos struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltIsInfNeg struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltIsValid struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltPct struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltLss struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltGtr struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltLeq struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltGeq struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltPos struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltNeg struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltInv struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltAdd struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSub struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltMul struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltDiv struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltRem struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltPow struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSqr struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltSqrt struct {
		Trm bnd.Bnd
		X   FltFltXpr
	}
	FltFltMin struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltMax struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltMid struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltAvg struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltAvgGeo struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSelEql struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSelNeq struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSelLss struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSelGtr struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSelLeq struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	FltFltSelGeq struct {
		Trm bnd.Bnd
		X   FltFltXpr
		I0  FltFltXpr
	}
	UntUntEql struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntNeq struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntLss struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntGtr struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntLeq struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntGeq struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntAdd struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntSub struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntMul struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntDiv struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntRem struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntPow struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntSqr struct {
		Trm bnd.Bnd
		X   UntUntXpr
	}
	UntUntSqrt struct {
		Trm bnd.Bnd
		X   UntUntXpr
	}
	UntUntMin struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntMax struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntMid struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntAvg struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	UntUntAvgGeo struct {
		Trm bnd.Bnd
		X   UntUntXpr
		I0  UntUntXpr
	}
	IntIntEql struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntNeq struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntLss struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntGtr struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntLeq struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntGeq struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntPos struct {
		Trm bnd.Bnd
		X   IntIntXpr
	}
	IntIntNeg struct {
		Trm bnd.Bnd
		X   IntIntXpr
	}
	IntIntInv struct {
		Trm bnd.Bnd
		X   IntIntXpr
	}
	IntIntAdd struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntSub struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntMul struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntDiv struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntRem struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntPow struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntSqr struct {
		Trm bnd.Bnd
		X   IntIntXpr
	}
	IntIntSqrt struct {
		Trm bnd.Bnd
		X   IntIntXpr
	}
	IntIntMin struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntMax struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntMid struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntAvg struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	IntIntAvgGeo struct {
		Trm bnd.Bnd
		X   IntIntXpr
		I0  IntIntXpr
	}
	TmeTmeWeekdayCnt struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeDte struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToSunday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToMonday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToTuesday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToWednesday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToThursday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToFriday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeToSaturday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsSunday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsMonday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsTuesday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsWednesday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsThursday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsFriday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeIsSaturday struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeEql struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeNeq struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeLss struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeGtr struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeLeq struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeGeq struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmePos struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeNeg struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeInv struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeAdd struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeSub struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeMul struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeDiv struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeRem struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmePow struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeSqr struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeSqrt struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
	}
	TmeTmeMin struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeMax struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeMid struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeAvg struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	TmeTmeAvgGeo struct {
		Trm bnd.Bnd
		X   TmeTmeXpr
		I0  TmeTmeXpr
	}
	BndBndCnt struct {
		Trm bnd.Bnd
		X   BndBndXpr
	}
	BndBndLen struct {
		Trm bnd.Bnd
		X   BndBndXpr
	}
	BndBndLstIdx struct {
		Trm bnd.Bnd
		X   BndBndXpr
	}
	BndBndIsValid struct {
		Trm bnd.Bnd
		X   BndBndXpr
	}
	FltRngLen struct {
		Trm bnd.Bnd
		X   FltRngXpr
	}
	FltRngIsValid struct {
		Trm bnd.Bnd
		X   FltRngXpr
	}
	FltRngEnsure struct {
		Trm bnd.Bnd
		X   FltRngXpr
	}
	FltRngMinSub struct {
		Trm bnd.Bnd
		X   FltRngXpr
		I0  FltFltXpr
	}
	FltRngMaxAdd struct {
		Trm bnd.Bnd
		X   FltRngXpr
		I0  FltFltXpr
	}
	FltRngMrg struct {
		Trm bnd.Bnd
		X   FltRngXpr
		I0  FltRngXpr
	}
	TmeRngLen struct {
		Trm bnd.Bnd
		X   TmeRngXpr
	}
	TmeRngIsValid struct {
		Trm bnd.Bnd
		X   TmeRngXpr
	}
	TmeRngEnsure struct {
		Trm bnd.Bnd
		X   TmeRngXpr
	}
	TmeRngMinSub struct {
		Trm bnd.Bnd
		X   TmeRngXpr
		I0  TmeTmeXpr
	}
	TmeRngMaxAdd struct {
		Trm bnd.Bnd
		X   TmeRngXpr
		I0  TmeTmeXpr
	}
	TmeRngMrg struct {
		Trm bnd.Bnd
		X   TmeRngXpr
		I0  TmeRngXpr
	}
	StrsStrsCnt struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsCpy struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsClr struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsRand struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsMrg struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  []StrsStrsXpr
	}
	StrsStrsPush struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  []StrStrXpr
	}
	StrsStrsPop struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsQue struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  []StrStrXpr
	}
	StrsStrsDque struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsIns struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
		I1  StrStrXpr
	}
	StrsStrsUpd struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
		I1  StrStrXpr
	}
	StrsStrsDel struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
	}
	StrsStrsAt struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
	}
	StrsStrsIn struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	StrsStrsInBnd struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  BndBndXpr
	}
	StrsStrsFrom struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
	}
	StrsStrsTo struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  UntUntXpr
	}
	StrsStrsFst struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsMdl struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsLst struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsFstIdx struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsMdlIdx struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsLstIdx struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsRev struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsSrchIdxEql struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  StrStrXpr
	}
	StrsStrsSrchIdx struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  StrStrXpr
		I1  []BolBolXpr
	}
	StrsStrsHas struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
		I0  StrStrXpr
	}
	StrsStrsSrtAsc struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	StrsStrsSrtDsc struct {
		Trm bnd.Bnd
		X   StrsStrsXpr
	}
	BolsBolsCnt struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsCpy struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsClr struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsRand struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsMrg struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  []BolsBolsXpr
	}
	BolsBolsPush struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  []BolBolXpr
	}
	BolsBolsPop struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsQue struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  []BolBolXpr
	}
	BolsBolsDque struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsIns struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
		I1  BolBolXpr
	}
	BolsBolsUpd struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
		I1  BolBolXpr
	}
	BolsBolsDel struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
	}
	BolsBolsAt struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
	}
	BolsBolsIn struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	BolsBolsInBnd struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  BndBndXpr
	}
	BolsBolsFrom struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
	}
	BolsBolsTo struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
		I0  UntUntXpr
	}
	BolsBolsFst struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsMdl struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsLst struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsFstIdx struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsMdlIdx struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsLstIdx struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	BolsBolsRev struct {
		Trm bnd.Bnd
		X   BolsBolsXpr
	}
	FltsFltsCnt struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsCpy struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsClr struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsRand struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMrg struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  []FltsFltsXpr
	}
	FltsFltsPush struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  []FltFltXpr
	}
	FltsFltsPop struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsQue struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  []FltFltXpr
	}
	FltsFltsDque struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsIns struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
		I1  FltFltXpr
	}
	FltsFltsUpd struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
		I1  FltFltXpr
	}
	FltsFltsDel struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsAt struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsIn struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	FltsFltsInBnd struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  BndBndXpr
	}
	FltsFltsFrom struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsTo struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsFst struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMdl struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsLst struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsFstIdx struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMdlIdx struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsLstIdx struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsRev struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsSrchIdxEql struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSrchIdx struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
		I1  []BolBolXpr
	}
	FltsFltsHas struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSrtAsc struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsSrtDsc struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsUnaPos struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsUnaNeg struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsUnaInv struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsUnaSqr struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsUnaSqrt struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsSclAdd struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclSub struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclMul struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclDiv struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclRem struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclPow struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclMin struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSclMax struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSelEql struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSelNeq struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSelLss struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSelGtr struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSelLeq struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsSelGeq struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsCntEql struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsCntNeq struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsCntLss struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsCntGtr struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsCntLeq struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsCntGeq struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  FltFltXpr
	}
	FltsFltsInrAdd struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrSub struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrMul struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrDiv struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrRem struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrPow struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrMin struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsInrMax struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  UntUntXpr
	}
	FltsFltsSum struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsPrd struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMin struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMax struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMid struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsMdn struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsSma struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsGma struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsWma struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsVrnc struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsStd struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsZscr struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsZscrInplace struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsRngFul struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsRngLst struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsProLst struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsProSma struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsSubSumPos struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsSubSumNeg struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsRsi struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsWrsi struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsPro struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsAlma struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsProAlma struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
	}
	FltsFltsCntrDist struct {
		Trm bnd.Bnd
		X   FltsFltsXpr
		I0  []BolBolXpr
	}
	UntsUntsCnt struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsCpy struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsClr struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsRand struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMrg struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  []UntsUntsXpr
	}
	UntsUntsPush struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  []UntUntXpr
	}
	UntsUntsPop struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsQue struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  []UntUntXpr
	}
	UntsUntsDque struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsIns struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	UntsUntsUpd struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	UntsUntsDel struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsAt struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsIn struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	UntsUntsInBnd struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  BndBndXpr
	}
	UntsUntsFrom struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsTo struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsFst struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMdl struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsLst struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsFstIdx struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMdlIdx struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsLstIdx struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsRev struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsSrchIdxEql struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsSrchIdx struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
		I1  []BolBolXpr
	}
	UntsUntsHas struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsSrtAsc struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsSrtDsc struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsInrAdd struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrSub struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrMul struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrDiv struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrRem struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrPow struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrMin struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsInrMax struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
		I0  UntUntXpr
	}
	UntsUntsSum struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsPrd struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMin struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMax struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMid struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsMdn struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsSma struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsGma struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsWma struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsVrnc struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsStd struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsZscr struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsZscrInplace struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsRngFul struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsRngLst struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsProLst struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	UntsUntsProSma struct {
		Trm bnd.Bnd
		X   UntsUntsXpr
	}
	IntsIntsCnt struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsCpy struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsClr struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsRand struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsMrg struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  []IntsIntsXpr
	}
	IntsIntsPush struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  []IntIntXpr
	}
	IntsIntsPop struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsQue struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  []IntIntXpr
	}
	IntsIntsDque struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsIns struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
		I1  IntIntXpr
	}
	IntsIntsUpd struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
		I1  IntIntXpr
	}
	IntsIntsDel struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
	}
	IntsIntsAt struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
	}
	IntsIntsIn struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	IntsIntsInBnd struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  BndBndXpr
	}
	IntsIntsFrom struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
	}
	IntsIntsTo struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  UntUntXpr
	}
	IntsIntsFst struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsMdl struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsLst struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsFstIdx struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsMdlIdx struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsLstIdx struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsRev struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsSrchIdxEql struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  IntIntXpr
	}
	IntsIntsSrchIdx struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  IntIntXpr
		I1  []BolBolXpr
	}
	IntsIntsHas struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
		I0  IntIntXpr
	}
	IntsIntsSrtAsc struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	IntsIntsSrtDsc struct {
		Trm bnd.Bnd
		X   IntsIntsXpr
	}
	TmesTmesBnd struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  TmeRngXpr
	}
	TmesTmesWeekdayCnt struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesCnt struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesCpy struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesClr struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesRand struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMrg struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  []TmesTmesXpr
	}
	TmesTmesPush struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  []TmeTmeXpr
	}
	TmesTmesPop struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesQue struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  []TmeTmeXpr
	}
	TmesTmesDque struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesIns struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
		I1  TmeTmeXpr
	}
	TmesTmesUpd struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
		I1  TmeTmeXpr
	}
	TmesTmesDel struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesAt struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesIn struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	TmesTmesInBnd struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  BndBndXpr
	}
	TmesTmesFrom struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesTo struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesFst struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMdl struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesLst struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesFstIdx struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMdlIdx struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesLstIdx struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesRev struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesSrchIdxEql struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  TmeTmeXpr
	}
	TmesTmesSrchIdx struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  TmeTmeXpr
		I1  []BolBolXpr
	}
	TmesTmesHas struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  TmeTmeXpr
	}
	TmesTmesSrtAsc struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesSrtDsc struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesInrAdd struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrSub struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrMul struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrDiv struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrRem struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrPow struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrMin struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesInrMax struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
		I0  UntUntXpr
	}
	TmesTmesSum struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesPrd struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMin struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMax struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMid struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesMdn struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesSma struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesGma struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesWma struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesVrnc struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesStd struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesZscr struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesZscrInplace struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesRngFul struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesRngLst struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesProLst struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	TmesTmesProSma struct {
		Trm bnd.Bnd
		X   TmesTmesXpr
	}
	BndsBndsCnt struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsCpy struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsClr struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsRand struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsMrg struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  []BndsBndsXpr
	}
	BndsBndsPush struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  []BndBndXpr
	}
	BndsBndsPop struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsQue struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  []BndBndXpr
	}
	BndsBndsDque struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsIns struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
		I1  BndBndXpr
	}
	BndsBndsUpd struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
		I1  BndBndXpr
	}
	BndsBndsDel struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
	}
	BndsBndsAt struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
	}
	BndsBndsIn struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	BndsBndsInBnd struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  BndBndXpr
	}
	BndsBndsFrom struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
	}
	BndsBndsTo struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
		I0  UntUntXpr
	}
	BndsBndsFst struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsMdl struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsLst struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsFstIdx struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsMdlIdx struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsLstIdx struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	BndsBndsRev struct {
		Trm bnd.Bnd
		X   BndsBndsXpr
	}
	TmeRngsCnt struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsCpy struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsClr struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsRand struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsMrg struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  []TmeRngsXpr
	}
	TmeRngsPush struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  []TmeRngXpr
	}
	TmeRngsPop struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsQue struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  []TmeRngXpr
	}
	TmeRngsDque struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsIns struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
		I1  TmeRngXpr
	}
	TmeRngsUpd struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
		I1  TmeRngXpr
	}
	TmeRngsDel struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
	}
	TmeRngsAt struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
	}
	TmeRngsIn struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	TmeRngsInBnd struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  BndBndXpr
	}
	TmeRngsFrom struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
	}
	TmeRngsTo struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
	}
	TmeRngsFst struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsMdl struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsLst struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsFstIdx struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsMdlIdx struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsLstIdx struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsRev struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
	}
	TmeRngsSrchIdx struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  TmeTmeXpr
	}
	TmeRngsRngMrg struct {
		Trm bnd.Bnd
		X   TmeRngsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	AnaTrdOpnMid struct {
		Trm bnd.Bnd
		X   AnaTrdXpr
	}
	AnaTrdClsMid struct {
		Trm bnd.Bnd
		X   AnaTrdXpr
	}
	AnaTrdsCnt struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsCpy struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsRand struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsMrg struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  []AnaTrdsXpr
	}
	AnaTrdsPush struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  []AnaTrdXpr
	}
	AnaTrdsPop struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsQue struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  []AnaTrdXpr
	}
	AnaTrdsDque struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsIns struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
		I1  AnaTrdXpr
	}
	AnaTrdsUpd struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
		I1  AnaTrdXpr
	}
	AnaTrdsDel struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
	}
	AnaTrdsAt struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
	}
	AnaTrdsIn struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	AnaTrdsInBnd struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  BndBndXpr
	}
	AnaTrdsFrom struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
	}
	AnaTrdsTo struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  UntUntXpr
	}
	AnaTrdsFst struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsMdl struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsLst struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsFstIdx struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsMdlIdx struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsLstIdx struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsRev struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsSelClsResEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsResNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsResLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsResGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsResLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsResGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsReqEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsReqNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsReqLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsReqGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsReqLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsReqGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnResEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnResNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnResLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnResGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnResLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnResGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnReqEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnReqNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnReqLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnReqGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnReqLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelOpnReqGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelInstrEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelInstrNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelInstrLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelInstrGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelInstrLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelInstrGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelUnitsEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelUnitsNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelUnitsLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelUnitsGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelUnitsLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelUnitsGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelMrgnRtioEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelMrgnRtioNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelMrgnRtioLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelMrgnRtioGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelMrgnRtioLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelMrgnRtioGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelTrdPctEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelTrdPctNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelTrdPctLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelTrdPctGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelTrdPctLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelTrdPctGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdActEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdActNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdActLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdActGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdActLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdActGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBalUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBalUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBalUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBalUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBalUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBalUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBalUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstOpnSpdUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstOpnSpdUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstOpnSpdUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstOpnSpdUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstOpnSpdUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstOpnSpdUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstClsSpdUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstClsSpdUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstClsSpdUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstClsSpdUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstClsSpdUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstClsSpdUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstComUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstComUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstComUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstComUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstComUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelCstComUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlGrsUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlGrsUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlGrsUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlGrsUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlGrsUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlGrsUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlUsdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlUsdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlUsdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlUsdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlUsdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlUsdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctPredictEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctPredictNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctPredictLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctPredictGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctPredictLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctPredictGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPnlPctGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelIsLongEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  BolBolXpr
	}
	AnaTrdsSelIsLongNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  BolBolXpr
	}
	AnaTrdsSelDurEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelDurNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelDurLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelDurGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelDurLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelDurGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelPipEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPipNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPipLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPipGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPipLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelPipGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsRsnEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsRsnNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsRsnLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsRsnGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsRsnLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsRsnGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  StrStrXpr
	}
	AnaTrdsSelClsSpdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsSpdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsSpdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsSpdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsSpdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsSpdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnSpdEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnSpdNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnSpdLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnSpdGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnSpdLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnSpdGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsAskEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsAskNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsAskLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsAskGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsAskLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsAskGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnAskEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnAskNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnAskLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnAskGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnAskLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnAskGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBidEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBidNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBidLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBidGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBidLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsBidGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBidEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBidNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBidLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBidGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBidLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelOpnBidGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  FltFltXpr
	}
	AnaTrdsSelClsTmeEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelClsTmeNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelClsTmeLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelClsTmeGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelClsTmeLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelClsTmeGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelOpnTmeEql struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelOpnTmeNeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelOpnTmeLss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelOpnTmeGtr struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelOpnTmeLeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsSelOpnTmeGeq struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
		I0  TmeTmeXpr
	}
	AnaTrdsOpnTmes struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsTmes struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsOpnBids struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsBids struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsOpnAsks struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsAsks struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsOpnSpds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsSpds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsRsns struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsPips struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsDurs struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsIsLongs struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsPnlPcts struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsPnlPctPredicts struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsPnlUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsPnlGrsUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsCstComUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsCstClsSpdUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsCstOpnSpdUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsOpnBalUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsBalUsds struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsBalUsdActs struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsTrdPcts struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsMrgnRtios struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsUnitss struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsInstrs struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsOpnReqs struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsOpnRess struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsReqs struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaTrdsClsRess struct {
		Trm bnd.Bnd
		X   AnaTrdsXpr
	}
	AnaPrfmDlt struct {
		Trm bnd.Bnd
		X   AnaPrfmXpr
		I0  AnaPrfmXpr
	}
	AnaPrfmsCnt struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsCpy struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsClr struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsRand struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsMrg struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  []AnaPrfmsXpr
	}
	AnaPrfmsPush struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  []AnaPrfmXpr
	}
	AnaPrfmsPop struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsQue struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  []AnaPrfmXpr
	}
	AnaPrfmsDque struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsIns struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
		I1  AnaPrfmXpr
	}
	AnaPrfmsUpd struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
		I1  AnaPrfmXpr
	}
	AnaPrfmsDel struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
	}
	AnaPrfmsAt struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
	}
	AnaPrfmsIn struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	AnaPrfmsInBnd struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  BndBndXpr
	}
	AnaPrfmsFrom struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
	}
	AnaPrfmsTo struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
		I0  UntUntXpr
	}
	AnaPrfmsFst struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsMdl struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsLst struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsFstIdx struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsMdlIdx struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsLstIdx struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsRev struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPnlPcts struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsScsPcts struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPipPerDays struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsUsdPerDays struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsScsPerDays struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsOpnPerDays struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPnlUsds struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPipAvgs struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPipMdns struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPipMins struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPipMaxs struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPipSums struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsDurAvgs struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsDurMdns struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsDurMins struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsDurMaxs struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsLosLimMaxs struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsDurLimMaxs struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsDayCnts struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsTrdCnts struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsTrdPcts struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsCstTotUsds struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsCstSpdUsds struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsCstComUsds struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	AnaPrfmsPths struct {
		Trm bnd.Bnd
		X   AnaPrfmsXpr
	}
	HstPrvsCnt struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsCpy struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsClr struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsRand struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsMrg struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  []HstPrvsXpr
	}
	HstPrvsPush struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  []HstPrvXpr
	}
	HstPrvsPop struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsQue struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  []HstPrvXpr
	}
	HstPrvsDque struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsIns struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
		I1  HstPrvXpr
	}
	HstPrvsUpd struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
		I1  HstPrvXpr
	}
	HstPrvsDel struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
	}
	HstPrvsAt struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
	}
	HstPrvsIn struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstPrvsInBnd struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  BndBndXpr
	}
	HstPrvsFrom struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
	}
	HstPrvsTo struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
		I0  UntUntXpr
	}
	HstPrvsFst struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsMdl struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsLst struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsFstIdx struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsMdlIdx struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsLstIdx struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstPrvsRev struct {
		Trm bnd.Bnd
		X   HstPrvsXpr
	}
	HstInstrsCnt struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsCpy struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsClr struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsRand struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsMrg struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  []HstInstrsXpr
	}
	HstInstrsPush struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  []HstInstrXpr
	}
	HstInstrsPop struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsQue struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  []HstInstrXpr
	}
	HstInstrsDque struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsIns struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
		I1  HstInstrXpr
	}
	HstInstrsUpd struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
		I1  HstInstrXpr
	}
	HstInstrsDel struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
	}
	HstInstrsAt struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
	}
	HstInstrsIn struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstInstrsInBnd struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  BndBndXpr
	}
	HstInstrsFrom struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
	}
	HstInstrsTo struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
		I0  UntUntXpr
	}
	HstInstrsFst struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsMdl struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsLst struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsFstIdx struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsMdlIdx struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsLstIdx struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInstrsRev struct {
		Trm bnd.Bnd
		X   HstInstrsXpr
	}
	HstInrvlsCnt struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsCpy struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsClr struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsRand struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsMrg struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  []HstInrvlsXpr
	}
	HstInrvlsPush struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  []HstInrvlXpr
	}
	HstInrvlsPop struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsQue struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  []HstInrvlXpr
	}
	HstInrvlsDque struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsIns struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
		I1  HstInrvlXpr
	}
	HstInrvlsUpd struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
		I1  HstInrvlXpr
	}
	HstInrvlsDel struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
	}
	HstInrvlsAt struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
	}
	HstInrvlsIn struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstInrvlsInBnd struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  BndBndXpr
	}
	HstInrvlsFrom struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
	}
	HstInrvlsTo struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
		I0  UntUntXpr
	}
	HstInrvlsFst struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsMdl struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsLst struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsFstIdx struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsMdlIdx struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsLstIdx struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstInrvlsRev struct {
		Trm bnd.Bnd
		X   HstInrvlsXpr
	}
	HstSidesCnt struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesCpy struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesClr struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesRand struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesMrg struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  []HstSidesXpr
	}
	HstSidesPush struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  []HstSideXpr
	}
	HstSidesPop struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesQue struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  []HstSideXpr
	}
	HstSidesDque struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesIns struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
		I1  HstSideXpr
	}
	HstSidesUpd struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
		I1  HstSideXpr
	}
	HstSidesDel struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
	}
	HstSidesAt struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
	}
	HstSidesIn struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstSidesInBnd struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  BndBndXpr
	}
	HstSidesFrom struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
	}
	HstSidesTo struct {
		Trm bnd.Bnd
		X   HstSidesXpr
		I0  UntUntXpr
	}
	HstSidesFst struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesMdl struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesLst struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesFstIdx struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesMdlIdx struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesLstIdx struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstSidesRev struct {
		Trm bnd.Bnd
		X   HstSidesXpr
	}
	HstStmsCnt struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsCpy struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsClr struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsRand struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsMrg struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  []HstStmsXpr
	}
	HstStmsPush struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  []HstStmXpr
	}
	HstStmsPop struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsQue struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  []HstStmXpr
	}
	HstStmsDque struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsIns struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmsUpd struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmsDel struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
	}
	HstStmsAt struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
	}
	HstStmsIn struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstStmsInBnd struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  BndBndXpr
	}
	HstStmsFrom struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
	}
	HstStmsTo struct {
		Trm bnd.Bnd
		X   HstStmsXpr
		I0  UntUntXpr
	}
	HstStmsFst struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsMdl struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsLst struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsFstIdx struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsMdlIdx struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsLstIdx struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstStmsRev struct {
		Trm bnd.Bnd
		X   HstStmsXpr
	}
	HstCndsCnt struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsCpy struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsClr struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsRand struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsMrg struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  []HstCndsXpr
	}
	HstCndsPush struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  []HstCndXpr
	}
	HstCndsPop struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsQue struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  []HstCndXpr
	}
	HstCndsDque struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsIns struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
		I1  HstCndXpr
	}
	HstCndsUpd struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
		I1  HstCndXpr
	}
	HstCndsDel struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
	}
	HstCndsAt struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
	}
	HstCndsIn struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstCndsInBnd struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  BndBndXpr
	}
	HstCndsFrom struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
	}
	HstCndsTo struct {
		Trm bnd.Bnd
		X   HstCndsXpr
		I0  UntUntXpr
	}
	HstCndsFst struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsMdl struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsLst struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsFstIdx struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsMdlIdx struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsLstIdx struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstCndsRev struct {
		Trm bnd.Bnd
		X   HstCndsXpr
	}
	HstStgysCnt struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysCpy struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysClr struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysRand struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysMrg struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  []HstStgysXpr
	}
	HstStgysPush struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  []HstStgyXpr
	}
	HstStgysPop struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysQue struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  []HstStgyXpr
	}
	HstStgysDque struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysIns struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
		I1  HstStgyXpr
	}
	HstStgysUpd struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
		I1  HstStgyXpr
	}
	HstStgysDel struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
	}
	HstStgysAt struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
	}
	HstStgysIn struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	HstStgysInBnd struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  BndBndXpr
	}
	HstStgysFrom struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
	}
	HstStgysTo struct {
		Trm bnd.Bnd
		X   HstStgysXpr
		I0  UntUntXpr
	}
	HstStgysFst struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysMdl struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysLst struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysFstIdx struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysMdlIdx struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysLstIdx struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	HstStgysRev struct {
		Trm bnd.Bnd
		X   HstStgysXpr
	}
	RltPrvsCnt struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsCpy struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsClr struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsRand struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsMrg struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  []RltPrvsXpr
	}
	RltPrvsPush struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  []RltPrvXpr
	}
	RltPrvsPop struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsQue struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  []RltPrvXpr
	}
	RltPrvsDque struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsIns struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
		I1  RltPrvXpr
	}
	RltPrvsUpd struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
		I1  RltPrvXpr
	}
	RltPrvsDel struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
	}
	RltPrvsAt struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
	}
	RltPrvsIn struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltPrvsInBnd struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  BndBndXpr
	}
	RltPrvsFrom struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
	}
	RltPrvsTo struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
		I0  UntUntXpr
	}
	RltPrvsFst struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsMdl struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsLst struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsFstIdx struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsMdlIdx struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsLstIdx struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltPrvsRev struct {
		Trm bnd.Bnd
		X   RltPrvsXpr
	}
	RltInstrsCnt struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsCpy struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsClr struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsRand struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsMrg struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  []RltInstrsXpr
	}
	RltInstrsPush struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  []RltInstrXpr
	}
	RltInstrsPop struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsQue struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  []RltInstrXpr
	}
	RltInstrsDque struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsIns struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
		I1  RltInstrXpr
	}
	RltInstrsUpd struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
		I1  RltInstrXpr
	}
	RltInstrsDel struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
	}
	RltInstrsAt struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
	}
	RltInstrsIn struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltInstrsInBnd struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  BndBndXpr
	}
	RltInstrsFrom struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
	}
	RltInstrsTo struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
		I0  UntUntXpr
	}
	RltInstrsFst struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsMdl struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsLst struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsFstIdx struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsMdlIdx struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsLstIdx struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInstrsRev struct {
		Trm bnd.Bnd
		X   RltInstrsXpr
	}
	RltInrvlsCnt struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsCpy struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsClr struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsRand struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsMrg struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  []RltInrvlsXpr
	}
	RltInrvlsPush struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  []RltInrvlXpr
	}
	RltInrvlsPop struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsQue struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  []RltInrvlXpr
	}
	RltInrvlsDque struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsIns struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
		I1  RltInrvlXpr
	}
	RltInrvlsUpd struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
		I1  RltInrvlXpr
	}
	RltInrvlsDel struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
	}
	RltInrvlsAt struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
	}
	RltInrvlsIn struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltInrvlsInBnd struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  BndBndXpr
	}
	RltInrvlsFrom struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
	}
	RltInrvlsTo struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
		I0  UntUntXpr
	}
	RltInrvlsFst struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsMdl struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsLst struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsFstIdx struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsMdlIdx struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsLstIdx struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltInrvlsRev struct {
		Trm bnd.Bnd
		X   RltInrvlsXpr
	}
	RltSidesCnt struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesCpy struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesClr struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesRand struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesMrg struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  []RltSidesXpr
	}
	RltSidesPush struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  []RltSideXpr
	}
	RltSidesPop struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesQue struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  []RltSideXpr
	}
	RltSidesDque struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesIns struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
		I1  RltSideXpr
	}
	RltSidesUpd struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
		I1  RltSideXpr
	}
	RltSidesDel struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
	}
	RltSidesAt struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
	}
	RltSidesIn struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltSidesInBnd struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  BndBndXpr
	}
	RltSidesFrom struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
	}
	RltSidesTo struct {
		Trm bnd.Bnd
		X   RltSidesXpr
		I0  UntUntXpr
	}
	RltSidesFst struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesMdl struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesLst struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesFstIdx struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesMdlIdx struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesLstIdx struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltSidesRev struct {
		Trm bnd.Bnd
		X   RltSidesXpr
	}
	RltStmsCnt struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsCpy struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsClr struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsRand struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsMrg struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  []RltStmsXpr
	}
	RltStmsPush struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  []RltStmXpr
	}
	RltStmsPop struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsQue struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  []RltStmXpr
	}
	RltStmsDque struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsIns struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmsUpd struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmsDel struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
	}
	RltStmsAt struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
	}
	RltStmsIn struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltStmsInBnd struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  BndBndXpr
	}
	RltStmsFrom struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
	}
	RltStmsTo struct {
		Trm bnd.Bnd
		X   RltStmsXpr
		I0  UntUntXpr
	}
	RltStmsFst struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsMdl struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsLst struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsFstIdx struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsMdlIdx struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsLstIdx struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltStmsRev struct {
		Trm bnd.Bnd
		X   RltStmsXpr
	}
	RltCndsCnt struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsCpy struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsClr struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsRand struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsMrg struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  []RltCndsXpr
	}
	RltCndsPush struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  []RltCndXpr
	}
	RltCndsPop struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsQue struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  []RltCndXpr
	}
	RltCndsDque struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsIns struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
		I1  RltCndXpr
	}
	RltCndsUpd struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
		I1  RltCndXpr
	}
	RltCndsDel struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
	}
	RltCndsAt struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
	}
	RltCndsIn struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltCndsInBnd struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  BndBndXpr
	}
	RltCndsFrom struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
	}
	RltCndsTo struct {
		Trm bnd.Bnd
		X   RltCndsXpr
		I0  UntUntXpr
	}
	RltCndsFst struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsMdl struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsLst struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsFstIdx struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsMdlIdx struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsLstIdx struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltCndsRev struct {
		Trm bnd.Bnd
		X   RltCndsXpr
	}
	RltStgysCnt struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysCpy struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysClr struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysRand struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysMrg struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  []RltStgysXpr
	}
	RltStgysPush struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  []RltStgyXpr
	}
	RltStgysPop struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysQue struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  []RltStgyXpr
	}
	RltStgysDque struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysIns struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
		I1  RltStgyXpr
	}
	RltStgysUpd struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
		I1  RltStgyXpr
	}
	RltStgysDel struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
	}
	RltStgysAt struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
	}
	RltStgysIn struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	RltStgysInBnd struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  BndBndXpr
	}
	RltStgysFrom struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
	}
	RltStgysTo struct {
		Trm bnd.Bnd
		X   RltStgysXpr
		I0  UntUntXpr
	}
	RltStgysFst struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysMdl struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysLst struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysFstIdx struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysMdlIdx struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysLstIdx struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	RltStgysRev struct {
		Trm bnd.Bnd
		X   RltStgysXpr
	}
	ClrClrOpa struct {
		Trm bnd.Bnd
		X   ClrClrXpr
		I0  FltFltXpr
	}
	ClrClrInv struct {
		Trm bnd.Bnd
		X   ClrClrXpr
	}
	PenPenOpa struct {
		Trm bnd.Bnd
		X   PenPenXpr
		I0  FltFltXpr
	}
	PenPenInv struct {
		Trm bnd.Bnd
		X   PenPenXpr
	}
	PenPensCnt struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensCpy struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensClr struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensRand struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensMrg struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  []PenPensXpr
	}
	PenPensPush struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  []PenPenXpr
	}
	PenPensPop struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensQue struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  []PenPenXpr
	}
	PenPensDque struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensIns struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
		I1  PenPenXpr
	}
	PenPensUpd struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
		I1  PenPenXpr
	}
	PenPensDel struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
	}
	PenPensAt struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
	}
	PenPensIn struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PenPensInBnd struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  BndBndXpr
	}
	PenPensFrom struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
	}
	PenPensTo struct {
		Trm bnd.Bnd
		X   PenPensXpr
		I0  UntUntXpr
	}
	PenPensFst struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensMdl struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensLst struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensFstIdx struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensMdlIdx struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensLstIdx struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PenPensRev struct {
		Trm bnd.Bnd
		X   PenPensXpr
	}
	PltPltsCnt struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsCpy struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsClr struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsRand struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsMrg struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  []PltPltsXpr
	}
	PltPltsPush struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  []PltPltXpr
	}
	PltPltsPop struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsQue struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  []PltPltXpr
	}
	PltPltsDque struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsIns struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
		I1  PltPltXpr
	}
	PltPltsUpd struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
		I1  PltPltXpr
	}
	PltPltsDel struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
	}
	PltPltsAt struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
	}
	PltPltsIn struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltPltsInBnd struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  BndBndXpr
	}
	PltPltsFrom struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
	}
	PltPltsTo struct {
		Trm bnd.Bnd
		X   PltPltsXpr
		I0  UntUntXpr
	}
	PltPltsFst struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsMdl struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsLst struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsFstIdx struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsMdlIdx struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsLstIdx struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltPltsRev struct {
		Trm bnd.Bnd
		X   PltPltsXpr
	}
	PltTmeAxisXVis struct {
		Trm bnd.Bnd
		X   PltTmeAxisXXpr
		I0  BolBolXpr
	}
	PltFltAxisYVis struct {
		Trm bnd.Bnd
		X   PltFltAxisYXpr
		I0  BolBolXpr
	}
	PltStmX struct {
		Trm bnd.Bnd
		X   PltStmXpr
	}
	PltStmY struct {
		Trm bnd.Bnd
		X   PltStmXpr
	}
	PltStmStm struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  PenPenXpr
		I1  []HstStmXpr
	}
	PltStmStmBnd struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  ClrClrXpr
		I1  PenPenXpr
		I2  HstStmXpr
		I3  HstStmXpr
	}
	PltStmCnd struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  PenPenXpr
		I1  []HstCndXpr
	}
	PltStmHrzLn struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  PenPenXpr
		I1  []FltFltXpr
	}
	PltStmVrtLn struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  PenPenXpr
		I1  []TmeTmeXpr
	}
	PltStmHrzBnd struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  ClrClrXpr
		I1  PenPenXpr
		I2  FltFltXpr
		I3  FltFltXpr
	}
	PltStmVrtBnd struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  ClrClrXpr
		I1  PenPenXpr
		I2  TmeTmeXpr
		I3  TmeTmeXpr
	}
	PltStmHrzSclVal struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  TmeTmeXpr
	}
	PltStmVrtSclVal struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  FltFltXpr
	}
	PltStmSho struct {
		Trm bnd.Bnd
		X   PltStmXpr
	}
	PltStmSiz struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltStmScl struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  FltFltXpr
	}
	PltStmHrzScl struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  FltFltXpr
	}
	PltStmVrtScl struct {
		Trm bnd.Bnd
		X   PltStmXpr
		I0  FltFltXpr
	}
	PltFltsSctrFlts struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  ClrClrXpr
		I1  []FltsFltsXpr
	}
	PltFltsSctrPrfLos struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  TmesTmesXpr
		I1  TmesTmesXpr
		I2  []HstStmXpr
	}
	PltFltsSctrSho struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
	}
	PltFltsSctrSiz struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltFltsSctrScl struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  FltFltXpr
	}
	PltFltsSctrHrzScl struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  FltFltXpr
	}
	PltFltsSctrVrtScl struct {
		Trm bnd.Bnd
		X   PltFltsSctrXpr
		I0  FltFltXpr
	}
	PltFltsSctrDistFlts struct {
		Trm bnd.Bnd
		X   PltFltsSctrDistXpr
		I0  ClrClrXpr
		I1  UntUntXpr
		I2  []FltsFltsXpr
	}
	PltFltsSctrDistSho struct {
		Trm bnd.Bnd
		X   PltFltsSctrDistXpr
	}
	PltFltsSctrDistSiz struct {
		Trm bnd.Bnd
		X   PltFltsSctrDistXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltFltsSctrDistScl struct {
		Trm bnd.Bnd
		X   PltFltsSctrDistXpr
		I0  FltFltXpr
	}
	PltFltsSctrDistHrzScl struct {
		Trm bnd.Bnd
		X   PltFltsSctrDistXpr
		I0  FltFltXpr
	}
	PltFltsSctrDistVrtScl struct {
		Trm bnd.Bnd
		X   PltFltsSctrDistXpr
		I0  FltFltXpr
	}
	PltHrzPlt struct {
		Trm bnd.Bnd
		X   PltHrzXpr
		I0  []PltPltXpr
	}
	PltHrzSho struct {
		Trm bnd.Bnd
		X   PltHrzXpr
	}
	PltHrzSiz struct {
		Trm bnd.Bnd
		X   PltHrzXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltHrzScl struct {
		Trm bnd.Bnd
		X   PltHrzXpr
		I0  FltFltXpr
	}
	PltHrzHrzScl struct {
		Trm bnd.Bnd
		X   PltHrzXpr
		I0  FltFltXpr
	}
	PltHrzVrtScl struct {
		Trm bnd.Bnd
		X   PltHrzXpr
		I0  FltFltXpr
	}
	PltVrtPlt struct {
		Trm bnd.Bnd
		X   PltVrtXpr
		I0  []PltPltXpr
	}
	PltVrtSho struct {
		Trm bnd.Bnd
		X   PltVrtXpr
	}
	PltVrtSiz struct {
		Trm bnd.Bnd
		X   PltVrtXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltVrtScl struct {
		Trm bnd.Bnd
		X   PltVrtXpr
		I0  FltFltXpr
	}
	PltVrtHrzScl struct {
		Trm bnd.Bnd
		X   PltVrtXpr
		I0  FltFltXpr
	}
	PltVrtVrtScl struct {
		Trm bnd.Bnd
		X   PltVrtXpr
		I0  FltFltXpr
	}
	PltDpthPlt struct {
		Trm bnd.Bnd
		X   PltDpthXpr
		I0  []PltPltXpr
	}
	PltDpthSho struct {
		Trm bnd.Bnd
		X   PltDpthXpr
	}
	PltDpthSiz struct {
		Trm bnd.Bnd
		X   PltDpthXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltDpthScl struct {
		Trm bnd.Bnd
		X   PltDpthXpr
		I0  FltFltXpr
	}
	PltDpthHrzScl struct {
		Trm bnd.Bnd
		X   PltDpthXpr
		I0  FltFltXpr
	}
	PltDpthVrtScl struct {
		Trm bnd.Bnd
		X   PltDpthXpr
		I0  FltFltXpr
	}
	SysMuLck struct {
		Trm bnd.Bnd
		X   SysMuXpr
	}
	SysMuUlck struct {
		Trm bnd.Bnd
		X   SysMuXpr
	}
	HstPrvName struct {
		Trm bnd.Bnd
		X   HstPrvXpr
	}
	HstPrvEurUsd struct {
		Trm bnd.Bnd
		X   HstPrvXpr
		I0  []TmeRngXpr
	}
	HstPrvAudUsd struct {
		Trm bnd.Bnd
		X   HstPrvXpr
		I0  []TmeRngXpr
	}
	HstPrvNzdUsd struct {
		Trm bnd.Bnd
		X   HstPrvXpr
		I0  []TmeRngXpr
	}
	HstPrvGbpUsd struct {
		Trm bnd.Bnd
		X   HstPrvXpr
		I0  []TmeRngXpr
	}
	HstInstrName struct {
		Trm bnd.Bnd
		X   HstInstrXpr
	}
	HstInstrI struct {
		Trm bnd.Bnd
		X   HstInstrXpr
		I0  TmeTmeXpr
	}
	HstInrvlName struct {
		Trm bnd.Bnd
		X   HstInrvlXpr
	}
	HstInrvlBid struct {
		Trm bnd.Bnd
		X   HstInrvlXpr
	}
	HstInrvlAsk struct {
		Trm bnd.Bnd
		X   HstInrvlXpr
	}
	HstSideName struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideFst struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideLst struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideSum struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSidePrd struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideMin struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideMax struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideMid struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideMdn struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideSma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideGma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideWma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideRsi struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideWrsi struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideAlma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideVrnc struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideStd struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideRngFul struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideRngLst struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideProLst struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideProSma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideProAlma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstSideSar struct {
		Trm bnd.Bnd
		X   HstSideXpr
		I0  FltFltXpr
		I1  FltFltXpr
	}
	HstSideEma struct {
		Trm bnd.Bnd
		X   HstSideXpr
	}
	HstStmName struct {
		Trm bnd.Bnd
		X   HstStmXpr
	}
	HstStmAt struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  TmesTmesXpr
	}
	HstStmUnaPos struct {
		Trm bnd.Bnd
		X   HstStmXpr
	}
	HstStmUnaNeg struct {
		Trm bnd.Bnd
		X   HstStmXpr
	}
	HstStmUnaInv struct {
		Trm bnd.Bnd
		X   HstStmXpr
	}
	HstStmUnaSqr struct {
		Trm bnd.Bnd
		X   HstStmXpr
	}
	HstStmUnaSqrt struct {
		Trm bnd.Bnd
		X   HstStmXpr
	}
	HstStmSclAdd struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclSub struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclMul struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclDiv struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclRem struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclPow struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclMin struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclMax struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSelEql struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSelNeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSelLss struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSelGtr struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSelLeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSelGeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmAggFst struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggLst struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggSum struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggPrd struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggMin struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggMax struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggMid struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggMdn struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggSma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggGma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggWma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggRsi struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggWrsi struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggAlma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggVrnc struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggStd struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggRngFul struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggRngLst struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggProLst struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggProSma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggProAlma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmAggEma struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrAdd struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrSub struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrMul struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrDiv struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrRem struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrPow struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrMin struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrMax struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrSlp struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmOtrAdd struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrSub struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrMul struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrDiv struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrRem struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrPow struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrMin struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrMax struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmSclEql struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclNeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclLss struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclGtr struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclLeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmSclGeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  FltFltXpr
	}
	HstStmInrEql struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrNeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrLss struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrGtr struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrLeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmInrGeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
	}
	HstStmOtrEql struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrNeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrLss struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrGtr struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrLeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstStmOtrGeq struct {
		Trm bnd.Bnd
		X   HstStmXpr
		I0  UntUntXpr
		I1  HstStmXpr
	}
	HstCndName struct {
		Trm bnd.Bnd
		X   HstCndXpr
	}
	HstCndAnd struct {
		Trm bnd.Bnd
		X   HstCndXpr
		I0  HstCndXpr
	}
	HstCndSeq struct {
		Trm bnd.Bnd
		X   HstCndXpr
		I0  TmeTmeXpr
		I1  HstCndXpr
	}
	HstCndStgy struct {
		Trm bnd.Bnd
		X   HstCndXpr
		I0  BolBolXpr
		I1  FltFltXpr
		I2  FltFltXpr
		I3  TmeTmeXpr
		I4  FltFltXpr
		I5  HstInstrXpr
		I6  HstStmsXpr
		I7  []HstCndXpr
	}
	HstStgyName struct {
		Trm bnd.Bnd
		X   HstStgyXpr
	}
	RltPrvMayTrd struct {
		Trm bnd.Bnd
		X   RltPrvXpr
	}
	RltPrvEurUsd struct {
		Trm bnd.Bnd
		X   RltPrvXpr
		I0  []TmeRngXpr
	}
	RltPrvAudUsd struct {
		Trm bnd.Bnd
		X   RltPrvXpr
		I0  []TmeRngXpr
	}
	RltPrvNzdUsd struct {
		Trm bnd.Bnd
		X   RltPrvXpr
		I0  []TmeRngXpr
	}
	RltPrvGbpUsd struct {
		Trm bnd.Bnd
		X   RltPrvXpr
		I0  []TmeRngXpr
	}
	RltInstrI struct {
		Trm bnd.Bnd
		X   RltInstrXpr
		I0  TmeTmeXpr
	}
	RltInrvlBid struct {
		Trm bnd.Bnd
		X   RltInrvlXpr
	}
	RltInrvlAsk struct {
		Trm bnd.Bnd
		X   RltInrvlXpr
	}
	RltSideFst struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideLst struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideSum struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSidePrd struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideMin struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideMax struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideMid struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideMdn struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideSma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideGma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideWma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideRsi struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideWrsi struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideAlma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideVrnc struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideStd struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideRngFul struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideRngLst struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideProLst struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideProSma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideProAlma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltSideSar struct {
		Trm bnd.Bnd
		X   RltSideXpr
		I0  FltFltXpr
		I1  FltFltXpr
	}
	RltSideEma struct {
		Trm bnd.Bnd
		X   RltSideXpr
	}
	RltStmUnaPos struct {
		Trm bnd.Bnd
		X   RltStmXpr
	}
	RltStmUnaNeg struct {
		Trm bnd.Bnd
		X   RltStmXpr
	}
	RltStmUnaInv struct {
		Trm bnd.Bnd
		X   RltStmXpr
	}
	RltStmUnaSqr struct {
		Trm bnd.Bnd
		X   RltStmXpr
	}
	RltStmUnaSqrt struct {
		Trm bnd.Bnd
		X   RltStmXpr
	}
	RltStmSclAdd struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclSub struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclMul struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclDiv struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclRem struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclPow struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclMin struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclMax struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSelEql struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSelNeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSelLss struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSelGtr struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSelLeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSelGeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmAggFst struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggLst struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggSum struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggPrd struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggMin struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggMax struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggMid struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggMdn struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggSma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggGma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggWma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggRsi struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggWrsi struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggAlma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggVrnc struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggStd struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggRngFul struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggRngLst struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggProLst struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggProSma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggProAlma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmAggEma struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrAdd struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrSub struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrMul struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrDiv struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrRem struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrPow struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrMin struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrMax struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrSlp struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmOtrAdd struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrSub struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrMul struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrDiv struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrRem struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrPow struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrMin struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrMax struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmSclEql struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclNeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclLss struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclGtr struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclLeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmSclGeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  FltFltXpr
	}
	RltStmInrEql struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrNeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrLss struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrGtr struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrLeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmInrGeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
	}
	RltStmOtrEql struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrNeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrLss struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrGtr struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrLeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltStmOtrGeq struct {
		Trm bnd.Bnd
		X   RltStmXpr
		I0  UntUntXpr
		I1  RltStmXpr
	}
	RltCndAnd struct {
		Trm bnd.Bnd
		X   RltCndXpr
		I0  RltCndXpr
	}
	RltCndSeq struct {
		Trm bnd.Bnd
		X   RltCndXpr
		I0  TmeTmeXpr
		I1  RltCndXpr
	}
	RltCndStgy struct {
		Trm bnd.Bnd
		X   RltCndXpr
		I0  BolBolXpr
		I1  FltFltXpr
		I2  FltFltXpr
		I3  TmeTmeXpr
		I4  FltFltXpr
		I5  RltInstrXpr
		I6  RltStmsXpr
		I7  []RltCndXpr
	}
	PltPltSho struct {
		Trm bnd.Bnd
		X   PltPltXpr
	}
	PltPltSiz struct {
		Trm bnd.Bnd
		X   PltPltXpr
		I0  UntUntXpr
		I1  UntUntXpr
	}
	PltPltScl struct {
		Trm bnd.Bnd
		X   PltPltXpr
		I0  FltFltXpr
	}
	PltPltHrzScl struct {
		Trm bnd.Bnd
		X   PltPltXpr
		I0  FltFltXpr
	}
	PltPltVrtScl struct {
		Trm bnd.Bnd
		X   PltPltXpr
		I0  FltFltXpr
	}
	PllWait struct {
		Trm  bnd.Bnd
		Xprs []Xpr
		Scp  *Scp
	}
)

func (x StrStrLit) Xpr()                          {}
func (x StrStrLit) StrStrXpr()                    {}
func (x BolBolLit) Xpr()                          {}
func (x BolBolLit) BolBolXpr()                    {}
func (x FltFltLit) Xpr()                          {}
func (x FltFltLit) FltFltXpr()                    {}
func (x UntUntLit) Xpr()                          {}
func (x UntUntLit) UntUntXpr()                    {}
func (x IntIntLit) Xpr()                          {}
func (x IntIntLit) IntIntXpr()                    {}
func (x TmeTmeLit) Xpr()                          {}
func (x TmeTmeLit) TmeTmeXpr()                    {}
func (x BndBndLit) Xpr()                          {}
func (x BndBndLit) BndBndXpr()                    {}
func (x FltRngLit) Xpr()                          {}
func (x FltRngLit) FltRngXpr()                    {}
func (x TmeRngLit) Xpr()                          {}
func (x TmeRngLit) TmeRngXpr()                    {}
func (x StrsStrsLit) Xpr()                        {}
func (x StrsStrsLit) StrsStrsXpr()                {}
func (x BolsBolsLit) Xpr()                        {}
func (x BolsBolsLit) BolsBolsXpr()                {}
func (x FltsFltsLit) Xpr()                        {}
func (x FltsFltsLit) FltsFltsXpr()                {}
func (x UntsUntsLit) Xpr()                        {}
func (x UntsUntsLit) UntsUntsXpr()                {}
func (x IntsIntsLit) Xpr()                        {}
func (x IntsIntsLit) IntsIntsXpr()                {}
func (x TmesTmesLit) Xpr()                        {}
func (x TmesTmesLit) TmesTmesXpr()                {}
func (x BndsBndsLit) Xpr()                        {}
func (x BndsBndsLit) BndsBndsXpr()                {}
func (x TmeRngsLit) Xpr()                         {}
func (x TmeRngsLit) TmeRngsXpr()                  {}
func (x StrStrAsn) Xpr()                          {}
func (x StrStrAsn) StrStrXpr()                    {}
func (x StrStrAcs) Xpr()                          {}
func (x StrStrAcs) StrStrXpr()                    {}
func (x BolBolAsn) Xpr()                          {}
func (x BolBolAsn) BolBolXpr()                    {}
func (x BolBolAcs) Xpr()                          {}
func (x BolBolAcs) BolBolXpr()                    {}
func (x FltFltAsn) Xpr()                          {}
func (x FltFltAsn) FltFltXpr()                    {}
func (x FltFltAcs) Xpr()                          {}
func (x FltFltAcs) FltFltXpr()                    {}
func (x UntUntAsn) Xpr()                          {}
func (x UntUntAsn) UntUntXpr()                    {}
func (x UntUntAcs) Xpr()                          {}
func (x UntUntAcs) UntUntXpr()                    {}
func (x IntIntAsn) Xpr()                          {}
func (x IntIntAsn) IntIntXpr()                    {}
func (x IntIntAcs) Xpr()                          {}
func (x IntIntAcs) IntIntXpr()                    {}
func (x TmeTmeAsn) Xpr()                          {}
func (x TmeTmeAsn) TmeTmeXpr()                    {}
func (x TmeTmeAcs) Xpr()                          {}
func (x TmeTmeAcs) TmeTmeXpr()                    {}
func (x BndBndAsn) Xpr()                          {}
func (x BndBndAsn) BndBndXpr()                    {}
func (x BndBndAcs) Xpr()                          {}
func (x BndBndAcs) BndBndXpr()                    {}
func (x FltRngAsn) Xpr()                          {}
func (x FltRngAsn) FltRngXpr()                    {}
func (x FltRngAcs) Xpr()                          {}
func (x FltRngAcs) FltRngXpr()                    {}
func (x TmeRngAsn) Xpr()                          {}
func (x TmeRngAsn) TmeRngXpr()                    {}
func (x TmeRngAcs) Xpr()                          {}
func (x TmeRngAcs) TmeRngXpr()                    {}
func (x StrsStrsAsn) Xpr()                        {}
func (x StrsStrsAsn) StrsStrsXpr()                {}
func (x StrsStrsAcs) Xpr()                        {}
func (x StrsStrsAcs) StrsStrsXpr()                {}
func (x StrsStrsEach) Xpr()                       {}
func (x StrsStrsEach) StrsStrsXpr()               {}
func (x StrsStrsPllEach) Xpr()                    {}
func (x StrsStrsPllEach) StrsStrsXpr()            {}
func (x BolsBolsAsn) Xpr()                        {}
func (x BolsBolsAsn) BolsBolsXpr()                {}
func (x BolsBolsAcs) Xpr()                        {}
func (x BolsBolsAcs) BolsBolsXpr()                {}
func (x BolsBolsEach) Xpr()                       {}
func (x BolsBolsEach) BolsBolsXpr()               {}
func (x BolsBolsPllEach) Xpr()                    {}
func (x BolsBolsPllEach) BolsBolsXpr()            {}
func (x FltsFltsAsn) Xpr()                        {}
func (x FltsFltsAsn) FltsFltsXpr()                {}
func (x FltsFltsAcs) Xpr()                        {}
func (x FltsFltsAcs) FltsFltsXpr()                {}
func (x FltsFltsEach) Xpr()                       {}
func (x FltsFltsEach) FltsFltsXpr()               {}
func (x FltsFltsPllEach) Xpr()                    {}
func (x FltsFltsPllEach) FltsFltsXpr()            {}
func (x UntsUntsAsn) Xpr()                        {}
func (x UntsUntsAsn) UntsUntsXpr()                {}
func (x UntsUntsAcs) Xpr()                        {}
func (x UntsUntsAcs) UntsUntsXpr()                {}
func (x UntsUntsEach) Xpr()                       {}
func (x UntsUntsEach) UntsUntsXpr()               {}
func (x UntsUntsPllEach) Xpr()                    {}
func (x UntsUntsPllEach) UntsUntsXpr()            {}
func (x IntsIntsAsn) Xpr()                        {}
func (x IntsIntsAsn) IntsIntsXpr()                {}
func (x IntsIntsAcs) Xpr()                        {}
func (x IntsIntsAcs) IntsIntsXpr()                {}
func (x IntsIntsEach) Xpr()                       {}
func (x IntsIntsEach) IntsIntsXpr()               {}
func (x IntsIntsPllEach) Xpr()                    {}
func (x IntsIntsPllEach) IntsIntsXpr()            {}
func (x TmesTmesAsn) Xpr()                        {}
func (x TmesTmesAsn) TmesTmesXpr()                {}
func (x TmesTmesAcs) Xpr()                        {}
func (x TmesTmesAcs) TmesTmesXpr()                {}
func (x TmesTmesEach) Xpr()                       {}
func (x TmesTmesEach) TmesTmesXpr()               {}
func (x TmesTmesPllEach) Xpr()                    {}
func (x TmesTmesPllEach) TmesTmesXpr()            {}
func (x BndsBndsAsn) Xpr()                        {}
func (x BndsBndsAsn) BndsBndsXpr()                {}
func (x BndsBndsAcs) Xpr()                        {}
func (x BndsBndsAcs) BndsBndsXpr()                {}
func (x BndsBndsEach) Xpr()                       {}
func (x BndsBndsEach) BndsBndsXpr()               {}
func (x BndsBndsPllEach) Xpr()                    {}
func (x BndsBndsPllEach) BndsBndsXpr()            {}
func (x TmeRngsAsn) Xpr()                         {}
func (x TmeRngsAsn) TmeRngsXpr()                  {}
func (x TmeRngsAcs) Xpr()                         {}
func (x TmeRngsAcs) TmeRngsXpr()                  {}
func (x TmeRngsEach) Xpr()                        {}
func (x TmeRngsEach) TmeRngsXpr()                 {}
func (x TmeRngsPllEach) Xpr()                     {}
func (x TmeRngsPllEach) TmeRngsXpr()              {}
func (x AnaTrdAsn) Xpr()                          {}
func (x AnaTrdAsn) AnaTrdXpr()                    {}
func (x AnaTrdAcs) Xpr()                          {}
func (x AnaTrdAcs) AnaTrdXpr()                    {}
func (x AnaTrdsAsn) Xpr()                         {}
func (x AnaTrdsAsn) AnaTrdsXpr()                  {}
func (x AnaTrdsAcs) Xpr()                         {}
func (x AnaTrdsAcs) AnaTrdsXpr()                  {}
func (x AnaTrdsEach) Xpr()                        {}
func (x AnaTrdsEach) AnaTrdsXpr()                 {}
func (x AnaTrdsPllEach) Xpr()                     {}
func (x AnaTrdsPllEach) AnaTrdsXpr()              {}
func (x AnaPrfmAsn) Xpr()                         {}
func (x AnaPrfmAsn) AnaPrfmXpr()                  {}
func (x AnaPrfmAcs) Xpr()                         {}
func (x AnaPrfmAcs) AnaPrfmXpr()                  {}
func (x AnaPrfmsAsn) Xpr()                        {}
func (x AnaPrfmsAsn) AnaPrfmsXpr()                {}
func (x AnaPrfmsAcs) Xpr()                        {}
func (x AnaPrfmsAcs) AnaPrfmsXpr()                {}
func (x AnaPrfmsEach) Xpr()                       {}
func (x AnaPrfmsEach) AnaPrfmsXpr()               {}
func (x AnaPrfmsPllEach) Xpr()                    {}
func (x AnaPrfmsPllEach) AnaPrfmsXpr()            {}
func (x AnaPrfmDltAsn) Xpr()                      {}
func (x AnaPrfmDltAsn) AnaPrfmDltXpr()            {}
func (x AnaPrfmDltAcs) Xpr()                      {}
func (x AnaPrfmDltAcs) AnaPrfmDltXpr()            {}
func (x AnaPortAsn) Xpr()                         {}
func (x AnaPortAsn) AnaPortXpr()                  {}
func (x AnaPortAcs) Xpr()                         {}
func (x AnaPortAcs) AnaPortXpr()                  {}
func (x HstPrvAsn) Xpr()                          {}
func (x HstPrvAsn) HstPrvXpr()                    {}
func (x HstPrvAcs) Xpr()                          {}
func (x HstPrvAcs) HstPrvXpr()                    {}
func (x HstInstrAsn) Xpr()                        {}
func (x HstInstrAsn) HstInstrXpr()                {}
func (x HstInstrAcs) Xpr()                        {}
func (x HstInstrAcs) HstInstrXpr()                {}
func (x HstInrvlAsn) Xpr()                        {}
func (x HstInrvlAsn) HstInrvlXpr()                {}
func (x HstInrvlAcs) Xpr()                        {}
func (x HstInrvlAcs) HstInrvlXpr()                {}
func (x HstSideAsn) Xpr()                         {}
func (x HstSideAsn) HstSideXpr()                  {}
func (x HstSideAcs) Xpr()                         {}
func (x HstSideAcs) HstSideXpr()                  {}
func (x HstStmAsn) Xpr()                          {}
func (x HstStmAsn) HstStmXpr()                    {}
func (x HstStmAcs) Xpr()                          {}
func (x HstStmAcs) HstStmXpr()                    {}
func (x HstCndAsn) Xpr()                          {}
func (x HstCndAsn) HstCndXpr()                    {}
func (x HstCndAcs) Xpr()                          {}
func (x HstCndAcs) HstCndXpr()                    {}
func (x HstStgyAsn) Xpr()                         {}
func (x HstStgyAsn) HstStgyXpr()                  {}
func (x HstStgyAcs) Xpr()                         {}
func (x HstStgyAcs) HstStgyXpr()                  {}
func (x HstPrvsAsn) Xpr()                         {}
func (x HstPrvsAsn) HstPrvsXpr()                  {}
func (x HstPrvsAcs) Xpr()                         {}
func (x HstPrvsAcs) HstPrvsXpr()                  {}
func (x HstPrvsEach) Xpr()                        {}
func (x HstPrvsEach) HstPrvsXpr()                 {}
func (x HstPrvsPllEach) Xpr()                     {}
func (x HstPrvsPllEach) HstPrvsXpr()              {}
func (x HstInstrsAsn) Xpr()                       {}
func (x HstInstrsAsn) HstInstrsXpr()              {}
func (x HstInstrsAcs) Xpr()                       {}
func (x HstInstrsAcs) HstInstrsXpr()              {}
func (x HstInstrsEach) Xpr()                      {}
func (x HstInstrsEach) HstInstrsXpr()             {}
func (x HstInstrsPllEach) Xpr()                   {}
func (x HstInstrsPllEach) HstInstrsXpr()          {}
func (x HstInrvlsAsn) Xpr()                       {}
func (x HstInrvlsAsn) HstInrvlsXpr()              {}
func (x HstInrvlsAcs) Xpr()                       {}
func (x HstInrvlsAcs) HstInrvlsXpr()              {}
func (x HstInrvlsEach) Xpr()                      {}
func (x HstInrvlsEach) HstInrvlsXpr()             {}
func (x HstInrvlsPllEach) Xpr()                   {}
func (x HstInrvlsPllEach) HstInrvlsXpr()          {}
func (x HstSidesAsn) Xpr()                        {}
func (x HstSidesAsn) HstSidesXpr()                {}
func (x HstSidesAcs) Xpr()                        {}
func (x HstSidesAcs) HstSidesXpr()                {}
func (x HstSidesEach) Xpr()                       {}
func (x HstSidesEach) HstSidesXpr()               {}
func (x HstSidesPllEach) Xpr()                    {}
func (x HstSidesPllEach) HstSidesXpr()            {}
func (x HstStmsAsn) Xpr()                         {}
func (x HstStmsAsn) HstStmsXpr()                  {}
func (x HstStmsAcs) Xpr()                         {}
func (x HstStmsAcs) HstStmsXpr()                  {}
func (x HstStmsEach) Xpr()                        {}
func (x HstStmsEach) HstStmsXpr()                 {}
func (x HstStmsPllEach) Xpr()                     {}
func (x HstStmsPllEach) HstStmsXpr()              {}
func (x HstCndsAsn) Xpr()                         {}
func (x HstCndsAsn) HstCndsXpr()                  {}
func (x HstCndsAcs) Xpr()                         {}
func (x HstCndsAcs) HstCndsXpr()                  {}
func (x HstCndsEach) Xpr()                        {}
func (x HstCndsEach) HstCndsXpr()                 {}
func (x HstCndsPllEach) Xpr()                     {}
func (x HstCndsPllEach) HstCndsXpr()              {}
func (x HstStgysAsn) Xpr()                        {}
func (x HstStgysAsn) HstStgysXpr()                {}
func (x HstStgysAcs) Xpr()                        {}
func (x HstStgysAcs) HstStgysXpr()                {}
func (x HstStgysEach) Xpr()                       {}
func (x HstStgysEach) HstStgysXpr()               {}
func (x HstStgysPllEach) Xpr()                    {}
func (x HstStgysPllEach) HstStgysXpr()            {}
func (x RltPrvAsn) Xpr()                          {}
func (x RltPrvAsn) RltPrvXpr()                    {}
func (x RltPrvAcs) Xpr()                          {}
func (x RltPrvAcs) RltPrvXpr()                    {}
func (x RltInstrAsn) Xpr()                        {}
func (x RltInstrAsn) RltInstrXpr()                {}
func (x RltInstrAcs) Xpr()                        {}
func (x RltInstrAcs) RltInstrXpr()                {}
func (x RltInrvlAsn) Xpr()                        {}
func (x RltInrvlAsn) RltInrvlXpr()                {}
func (x RltInrvlAcs) Xpr()                        {}
func (x RltInrvlAcs) RltInrvlXpr()                {}
func (x RltSideAsn) Xpr()                         {}
func (x RltSideAsn) RltSideXpr()                  {}
func (x RltSideAcs) Xpr()                         {}
func (x RltSideAcs) RltSideXpr()                  {}
func (x RltStmAsn) Xpr()                          {}
func (x RltStmAsn) RltStmXpr()                    {}
func (x RltStmAcs) Xpr()                          {}
func (x RltStmAcs) RltStmXpr()                    {}
func (x RltCndAsn) Xpr()                          {}
func (x RltCndAsn) RltCndXpr()                    {}
func (x RltCndAcs) Xpr()                          {}
func (x RltCndAcs) RltCndXpr()                    {}
func (x RltStgyAsn) Xpr()                         {}
func (x RltStgyAsn) RltStgyXpr()                  {}
func (x RltStgyAcs) Xpr()                         {}
func (x RltStgyAcs) RltStgyXpr()                  {}
func (x RltPrvsAsn) Xpr()                         {}
func (x RltPrvsAsn) RltPrvsXpr()                  {}
func (x RltPrvsAcs) Xpr()                         {}
func (x RltPrvsAcs) RltPrvsXpr()                  {}
func (x RltPrvsEach) Xpr()                        {}
func (x RltPrvsEach) RltPrvsXpr()                 {}
func (x RltPrvsPllEach) Xpr()                     {}
func (x RltPrvsPllEach) RltPrvsXpr()              {}
func (x RltInstrsAsn) Xpr()                       {}
func (x RltInstrsAsn) RltInstrsXpr()              {}
func (x RltInstrsAcs) Xpr()                       {}
func (x RltInstrsAcs) RltInstrsXpr()              {}
func (x RltInstrsEach) Xpr()                      {}
func (x RltInstrsEach) RltInstrsXpr()             {}
func (x RltInstrsPllEach) Xpr()                   {}
func (x RltInstrsPllEach) RltInstrsXpr()          {}
func (x RltInrvlsAsn) Xpr()                       {}
func (x RltInrvlsAsn) RltInrvlsXpr()              {}
func (x RltInrvlsAcs) Xpr()                       {}
func (x RltInrvlsAcs) RltInrvlsXpr()              {}
func (x RltInrvlsEach) Xpr()                      {}
func (x RltInrvlsEach) RltInrvlsXpr()             {}
func (x RltInrvlsPllEach) Xpr()                   {}
func (x RltInrvlsPllEach) RltInrvlsXpr()          {}
func (x RltSidesAsn) Xpr()                        {}
func (x RltSidesAsn) RltSidesXpr()                {}
func (x RltSidesAcs) Xpr()                        {}
func (x RltSidesAcs) RltSidesXpr()                {}
func (x RltSidesEach) Xpr()                       {}
func (x RltSidesEach) RltSidesXpr()               {}
func (x RltSidesPllEach) Xpr()                    {}
func (x RltSidesPllEach) RltSidesXpr()            {}
func (x RltStmsAsn) Xpr()                         {}
func (x RltStmsAsn) RltStmsXpr()                  {}
func (x RltStmsAcs) Xpr()                         {}
func (x RltStmsAcs) RltStmsXpr()                  {}
func (x RltStmsEach) Xpr()                        {}
func (x RltStmsEach) RltStmsXpr()                 {}
func (x RltStmsPllEach) Xpr()                     {}
func (x RltStmsPllEach) RltStmsXpr()              {}
func (x RltCndsAsn) Xpr()                         {}
func (x RltCndsAsn) RltCndsXpr()                  {}
func (x RltCndsAcs) Xpr()                         {}
func (x RltCndsAcs) RltCndsXpr()                  {}
func (x RltCndsEach) Xpr()                        {}
func (x RltCndsEach) RltCndsXpr()                 {}
func (x RltCndsPllEach) Xpr()                     {}
func (x RltCndsPllEach) RltCndsXpr()              {}
func (x RltStgysAsn) Xpr()                        {}
func (x RltStgysAsn) RltStgysXpr()                {}
func (x RltStgysAcs) Xpr()                        {}
func (x RltStgysAcs) RltStgysXpr()                {}
func (x RltStgysEach) Xpr()                       {}
func (x RltStgysEach) RltStgysXpr()               {}
func (x RltStgysPllEach) Xpr()                    {}
func (x RltStgysPllEach) RltStgysXpr()            {}
func (x FntFntAsn) Xpr()                          {}
func (x FntFntAsn) FntFntXpr()                    {}
func (x FntFntAcs) Xpr()                          {}
func (x FntFntAcs) FntFntXpr()                    {}
func (x ClrClrAsn) Xpr()                          {}
func (x ClrClrAsn) ClrClrXpr()                    {}
func (x ClrClrAcs) Xpr()                          {}
func (x ClrClrAcs) ClrClrXpr()                    {}
func (x PenPenAsn) Xpr()                          {}
func (x PenPenAsn) PenPenXpr()                    {}
func (x PenPenAcs) Xpr()                          {}
func (x PenPenAcs) PenPenXpr()                    {}
func (x PenPensAsn) Xpr()                         {}
func (x PenPensAsn) PenPensXpr()                  {}
func (x PenPensAcs) Xpr()                         {}
func (x PenPensAcs) PenPensXpr()                  {}
func (x PenPensEach) Xpr()                        {}
func (x PenPensEach) PenPensXpr()                 {}
func (x PenPensPllEach) Xpr()                     {}
func (x PenPensPllEach) PenPensXpr()              {}
func (x PltPltAsn) Xpr()                          {}
func (x PltPltAsn) PltPltXpr()                    {}
func (x PltPltAcs) Xpr()                          {}
func (x PltPltAcs) PltPltXpr()                    {}
func (x PltPltsAsn) Xpr()                         {}
func (x PltPltsAsn) PltPltsXpr()                  {}
func (x PltPltsAcs) Xpr()                         {}
func (x PltPltsAcs) PltPltsXpr()                  {}
func (x PltPltsEach) Xpr()                        {}
func (x PltPltsEach) PltPltsXpr()                 {}
func (x PltPltsPllEach) Xpr()                     {}
func (x PltPltsPllEach) PltPltsXpr()              {}
func (x PltStmAsn) Xpr()                          {}
func (x PltStmAsn) PltStmXpr()                    {}
func (x PltStmAsn) PltPltXpr()                    {}
func (x PltStmAcs) Xpr()                          {}
func (x PltStmAcs) PltStmXpr()                    {}
func (x PltStmAcs) PltPltXpr()                    {}
func (x PltFltsSctrAsn) Xpr()                     {}
func (x PltFltsSctrAsn) PltFltsSctrXpr()          {}
func (x PltFltsSctrAsn) PltPltXpr()               {}
func (x PltFltsSctrAcs) Xpr()                     {}
func (x PltFltsSctrAcs) PltFltsSctrXpr()          {}
func (x PltFltsSctrAcs) PltPltXpr()               {}
func (x PltFltsSctrDistAsn) Xpr()                 {}
func (x PltFltsSctrDistAsn) PltFltsSctrDistXpr()  {}
func (x PltFltsSctrDistAsn) PltPltXpr()           {}
func (x PltFltsSctrDistAcs) Xpr()                 {}
func (x PltFltsSctrDistAcs) PltFltsSctrDistXpr()  {}
func (x PltFltsSctrDistAcs) PltPltXpr()           {}
func (x PltHrzAsn) Xpr()                          {}
func (x PltHrzAsn) PltHrzXpr()                    {}
func (x PltHrzAsn) PltPltXpr()                    {}
func (x PltHrzAcs) Xpr()                          {}
func (x PltHrzAcs) PltHrzXpr()                    {}
func (x PltHrzAcs) PltPltXpr()                    {}
func (x PltVrtAsn) Xpr()                          {}
func (x PltVrtAsn) PltVrtXpr()                    {}
func (x PltVrtAsn) PltPltXpr()                    {}
func (x PltVrtAcs) Xpr()                          {}
func (x PltVrtAcs) PltVrtXpr()                    {}
func (x PltVrtAcs) PltPltXpr()                    {}
func (x PltDpthAsn) Xpr()                         {}
func (x PltDpthAsn) PltDpthXpr()                  {}
func (x PltDpthAsn) PltPltXpr()                   {}
func (x PltDpthAcs) Xpr()                         {}
func (x PltDpthAcs) PltDpthXpr()                  {}
func (x PltDpthAcs) PltPltXpr()                   {}
func (x SysMuAsn) Xpr()                           {}
func (x SysMuAsn) SysMuXpr()                      {}
func (x SysMuAcs) Xpr()                           {}
func (x SysMuAcs) SysMuXpr()                      {}
func (x BolBolThen) Xpr()                         {}
func (x BolBolThen) BolBolXpr()                   {}
func (x BolBolElse) Xpr()                         {}
func (x BolBolElse) BolBolXpr()                   {}
func (x AnaPrfmPnlPctGet) Xpr()                   {}
func (x AnaPrfmPnlPctGet) FltFltXpr()             {}
func (x AnaPrfmScsPctGet) Xpr()                   {}
func (x AnaPrfmScsPctGet) FltFltXpr()             {}
func (x AnaPrfmPipPerDayGet) Xpr()                {}
func (x AnaPrfmPipPerDayGet) FltFltXpr()          {}
func (x AnaPrfmUsdPerDayGet) Xpr()                {}
func (x AnaPrfmUsdPerDayGet) FltFltXpr()          {}
func (x AnaPrfmScsPerDayGet) Xpr()                {}
func (x AnaPrfmScsPerDayGet) FltFltXpr()          {}
func (x AnaPrfmOpnPerDayGet) Xpr()                {}
func (x AnaPrfmOpnPerDayGet) FltFltXpr()          {}
func (x AnaPrfmPnlUsdGet) Xpr()                   {}
func (x AnaPrfmPnlUsdGet) FltFltXpr()             {}
func (x AnaPrfmPipAvgGet) Xpr()                   {}
func (x AnaPrfmPipAvgGet) FltFltXpr()             {}
func (x AnaPrfmPipMdnGet) Xpr()                   {}
func (x AnaPrfmPipMdnGet) FltFltXpr()             {}
func (x AnaPrfmPipMinGet) Xpr()                   {}
func (x AnaPrfmPipMinGet) FltFltXpr()             {}
func (x AnaPrfmPipMaxGet) Xpr()                   {}
func (x AnaPrfmPipMaxGet) FltFltXpr()             {}
func (x AnaPrfmPipSumGet) Xpr()                   {}
func (x AnaPrfmPipSumGet) FltFltXpr()             {}
func (x AnaPrfmDurAvgGet) Xpr()                   {}
func (x AnaPrfmDurAvgGet) TmeTmeXpr()             {}
func (x AnaPrfmDurMdnGet) Xpr()                   {}
func (x AnaPrfmDurMdnGet) TmeTmeXpr()             {}
func (x AnaPrfmDurMinGet) Xpr()                   {}
func (x AnaPrfmDurMinGet) TmeTmeXpr()             {}
func (x AnaPrfmDurMaxGet) Xpr()                   {}
func (x AnaPrfmDurMaxGet) TmeTmeXpr()             {}
func (x AnaPrfmLosLimMaxGet) Xpr()                {}
func (x AnaPrfmLosLimMaxGet) FltFltXpr()          {}
func (x AnaPrfmDurLimMaxGet) Xpr()                {}
func (x AnaPrfmDurLimMaxGet) TmeTmeXpr()          {}
func (x AnaPrfmDayCntGet) Xpr()                   {}
func (x AnaPrfmDayCntGet) UntUntXpr()             {}
func (x AnaPrfmTrdCntGet) Xpr()                   {}
func (x AnaPrfmTrdCntGet) UntUntXpr()             {}
func (x AnaPrfmTrdPctGet) Xpr()                   {}
func (x AnaPrfmTrdPctGet) FltFltXpr()             {}
func (x AnaPrfmCstTotUsdGet) Xpr()                {}
func (x AnaPrfmCstTotUsdGet) FltFltXpr()          {}
func (x AnaPrfmCstSpdUsdGet) Xpr()                {}
func (x AnaPrfmCstSpdUsdGet) FltFltXpr()          {}
func (x AnaPrfmCstComUsdGet) Xpr()                {}
func (x AnaPrfmCstComUsdGet) FltFltXpr()          {}
func (x AnaPrfmDltPnlPctAGet) Xpr()               {}
func (x AnaPrfmDltPnlPctAGet) FltFltXpr()         {}
func (x AnaPrfmDltPnlPctBGet) Xpr()               {}
func (x AnaPrfmDltPnlPctBGet) FltFltXpr()         {}
func (x AnaPrfmDltPnlPctDltGet) Xpr()             {}
func (x AnaPrfmDltPnlPctDltGet) FltFltXpr()       {}
func (x AnaPrfmDltScsPctAGet) Xpr()               {}
func (x AnaPrfmDltScsPctAGet) FltFltXpr()         {}
func (x AnaPrfmDltScsPctBGet) Xpr()               {}
func (x AnaPrfmDltScsPctBGet) FltFltXpr()         {}
func (x AnaPrfmDltScsPctDltGet) Xpr()             {}
func (x AnaPrfmDltScsPctDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPipPerDayAGet) Xpr()            {}
func (x AnaPrfmDltPipPerDayAGet) FltFltXpr()      {}
func (x AnaPrfmDltPipPerDayBGet) Xpr()            {}
func (x AnaPrfmDltPipPerDayBGet) FltFltXpr()      {}
func (x AnaPrfmDltPipPerDayDltGet) Xpr()          {}
func (x AnaPrfmDltPipPerDayDltGet) FltFltXpr()    {}
func (x AnaPrfmDltUsdPerDayAGet) Xpr()            {}
func (x AnaPrfmDltUsdPerDayAGet) FltFltXpr()      {}
func (x AnaPrfmDltUsdPerDayBGet) Xpr()            {}
func (x AnaPrfmDltUsdPerDayBGet) FltFltXpr()      {}
func (x AnaPrfmDltUsdPerDayDltGet) Xpr()          {}
func (x AnaPrfmDltUsdPerDayDltGet) FltFltXpr()    {}
func (x AnaPrfmDltScsPerDayAGet) Xpr()            {}
func (x AnaPrfmDltScsPerDayAGet) FltFltXpr()      {}
func (x AnaPrfmDltScsPerDayBGet) Xpr()            {}
func (x AnaPrfmDltScsPerDayBGet) FltFltXpr()      {}
func (x AnaPrfmDltScsPerDayDltGet) Xpr()          {}
func (x AnaPrfmDltScsPerDayDltGet) FltFltXpr()    {}
func (x AnaPrfmDltOpnPerDayAGet) Xpr()            {}
func (x AnaPrfmDltOpnPerDayAGet) FltFltXpr()      {}
func (x AnaPrfmDltOpnPerDayBGet) Xpr()            {}
func (x AnaPrfmDltOpnPerDayBGet) FltFltXpr()      {}
func (x AnaPrfmDltOpnPerDayDltGet) Xpr()          {}
func (x AnaPrfmDltOpnPerDayDltGet) FltFltXpr()    {}
func (x AnaPrfmDltPnlUsdAGet) Xpr()               {}
func (x AnaPrfmDltPnlUsdAGet) FltFltXpr()         {}
func (x AnaPrfmDltPnlUsdBGet) Xpr()               {}
func (x AnaPrfmDltPnlUsdBGet) FltFltXpr()         {}
func (x AnaPrfmDltPnlUsdDltGet) Xpr()             {}
func (x AnaPrfmDltPnlUsdDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPipAvgAGet) Xpr()               {}
func (x AnaPrfmDltPipAvgAGet) FltFltXpr()         {}
func (x AnaPrfmDltPipAvgBGet) Xpr()               {}
func (x AnaPrfmDltPipAvgBGet) FltFltXpr()         {}
func (x AnaPrfmDltPipAvgDltGet) Xpr()             {}
func (x AnaPrfmDltPipAvgDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPipMdnAGet) Xpr()               {}
func (x AnaPrfmDltPipMdnAGet) FltFltXpr()         {}
func (x AnaPrfmDltPipMdnBGet) Xpr()               {}
func (x AnaPrfmDltPipMdnBGet) FltFltXpr()         {}
func (x AnaPrfmDltPipMdnDltGet) Xpr()             {}
func (x AnaPrfmDltPipMdnDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPipMinAGet) Xpr()               {}
func (x AnaPrfmDltPipMinAGet) FltFltXpr()         {}
func (x AnaPrfmDltPipMinBGet) Xpr()               {}
func (x AnaPrfmDltPipMinBGet) FltFltXpr()         {}
func (x AnaPrfmDltPipMinDltGet) Xpr()             {}
func (x AnaPrfmDltPipMinDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPipMaxAGet) Xpr()               {}
func (x AnaPrfmDltPipMaxAGet) FltFltXpr()         {}
func (x AnaPrfmDltPipMaxBGet) Xpr()               {}
func (x AnaPrfmDltPipMaxBGet) FltFltXpr()         {}
func (x AnaPrfmDltPipMaxDltGet) Xpr()             {}
func (x AnaPrfmDltPipMaxDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPipSumAGet) Xpr()               {}
func (x AnaPrfmDltPipSumAGet) FltFltXpr()         {}
func (x AnaPrfmDltPipSumBGet) Xpr()               {}
func (x AnaPrfmDltPipSumBGet) FltFltXpr()         {}
func (x AnaPrfmDltPipSumDltGet) Xpr()             {}
func (x AnaPrfmDltPipSumDltGet) FltFltXpr()       {}
func (x AnaPrfmDltDurAvgAGet) Xpr()               {}
func (x AnaPrfmDltDurAvgAGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurAvgBGet) Xpr()               {}
func (x AnaPrfmDltDurAvgBGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurAvgDltGet) Xpr()             {}
func (x AnaPrfmDltDurAvgDltGet) FltFltXpr()       {}
func (x AnaPrfmDltDurMdnAGet) Xpr()               {}
func (x AnaPrfmDltDurMdnAGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurMdnBGet) Xpr()               {}
func (x AnaPrfmDltDurMdnBGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurMdnDltGet) Xpr()             {}
func (x AnaPrfmDltDurMdnDltGet) FltFltXpr()       {}
func (x AnaPrfmDltDurMinAGet) Xpr()               {}
func (x AnaPrfmDltDurMinAGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurMinBGet) Xpr()               {}
func (x AnaPrfmDltDurMinBGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurMinDltGet) Xpr()             {}
func (x AnaPrfmDltDurMinDltGet) FltFltXpr()       {}
func (x AnaPrfmDltDurMaxAGet) Xpr()               {}
func (x AnaPrfmDltDurMaxAGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurMaxBGet) Xpr()               {}
func (x AnaPrfmDltDurMaxBGet) TmeTmeXpr()         {}
func (x AnaPrfmDltDurMaxDltGet) Xpr()             {}
func (x AnaPrfmDltDurMaxDltGet) FltFltXpr()       {}
func (x AnaPrfmDltTrdCntAGet) Xpr()               {}
func (x AnaPrfmDltTrdCntAGet) UntUntXpr()         {}
func (x AnaPrfmDltTrdCntBGet) Xpr()               {}
func (x AnaPrfmDltTrdCntBGet) UntUntXpr()         {}
func (x AnaPrfmDltTrdCntDltGet) Xpr()             {}
func (x AnaPrfmDltTrdCntDltGet) FltFltXpr()       {}
func (x AnaPrfmDltTrdPctAGet) Xpr()               {}
func (x AnaPrfmDltTrdPctAGet) FltFltXpr()         {}
func (x AnaPrfmDltTrdPctBGet) Xpr()               {}
func (x AnaPrfmDltTrdPctBGet) FltFltXpr()         {}
func (x AnaPrfmDltTrdPctDltGet) Xpr()             {}
func (x AnaPrfmDltTrdPctDltGet) FltFltXpr()       {}
func (x AnaPrfmDltPthBGet) Xpr()                  {}
func (x AnaPrfmDltPthBGet) StrStrXpr()            {}
func (x PenPenClrSetGet) Xpr()                    {}
func (x PenPenClrSetGet) ClrClrXpr()              {}
func (x PenPenWidSetGet) Xpr()                    {}
func (x PenPenWidSetGet) UntUntXpr()              {}
func (x PltFltAxisYMinSetGet) Xpr()               {}
func (x PltFltAxisYMinSetGet) FltFltXpr()         {}
func (x PltFltAxisYMaxSetGet) Xpr()               {}
func (x PltFltAxisYMaxSetGet) FltFltXpr()         {}
func (x PltFltAxisYEqiDstSetGet) Xpr()            {}
func (x PltFltAxisYEqiDstSetGet) FltFltXpr()      {}
func (x PltStmTitleSetGet) Xpr()                  {}
func (x PltStmTitleSetGet) StrStrXpr()            {}
func (x PltFltsSctrYGet) Xpr()                    {}
func (x PltFltsSctrYGet) PltFltAxisYXpr()         {}
func (x PltFltsSctrTitleSetGet) Xpr()             {}
func (x PltFltsSctrTitleSetGet) StrStrXpr()       {}
func (x PltFltsSctrOutlierSetGet) Xpr()           {}
func (x PltFltsSctrOutlierSetGet) BolBolXpr()     {}
func (x PltHrzPltsGet) Xpr()                      {}
func (x PltHrzPltsGet) PltPltsXpr()               {}
func (x PltVrtPltsGet) Xpr()                      {}
func (x PltVrtPltsGet) PltPltsXpr()               {}
func (x PltDpthPltsGet) Xpr()                     {}
func (x PltDpthPltsGet) PltPltsXpr()              {}
func (x StrZero) Xpr()                            {}
func (x StrZero) StrStrXpr()                      {}
func (x StrEmpty) Xpr()                           {}
func (x StrEmpty) StrStrXpr()                     {}
func (x BolZero) Xpr()                            {}
func (x BolZero) BolBolXpr()                      {}
func (x BolFls) Xpr()                             {}
func (x BolFls) BolBolXpr()                       {}
func (x BolTru) Xpr()                             {}
func (x BolTru) BolBolXpr()                       {}
func (x FltZero) Xpr()                            {}
func (x FltZero) FltFltXpr()                      {}
func (x FltOne) Xpr()                             {}
func (x FltOne) FltFltXpr()                       {}
func (x FltNegOne) Xpr()                          {}
func (x FltNegOne) FltFltXpr()                    {}
func (x FltHndrd) Xpr()                           {}
func (x FltHndrd) FltFltXpr()                     {}
func (x FltMin) Xpr()                             {}
func (x FltMin) FltFltXpr()                       {}
func (x FltMax) Xpr()                             {}
func (x FltMax) FltFltXpr()                       {}
func (x FltTiny) Xpr()                            {}
func (x FltTiny) FltFltXpr()                      {}
func (x UntZero) Xpr()                            {}
func (x UntZero) UntUntXpr()                      {}
func (x UntOne) Xpr()                             {}
func (x UntOne) UntUntXpr()                       {}
func (x UntMin) Xpr()                             {}
func (x UntMin) UntUntXpr()                       {}
func (x UntMax) Xpr()                             {}
func (x UntMax) UntUntXpr()                       {}
func (x IntZero) Xpr()                            {}
func (x IntZero) IntIntXpr()                      {}
func (x IntOne) Xpr()                             {}
func (x IntOne) IntIntXpr()                       {}
func (x IntNegOne) Xpr()                          {}
func (x IntNegOne) IntIntXpr()                    {}
func (x IntMin) Xpr()                             {}
func (x IntMin) IntIntXpr()                       {}
func (x IntMax) Xpr()                             {}
func (x IntMax) IntIntXpr()                       {}
func (x TmeZero) Xpr()                            {}
func (x TmeZero) TmeTmeXpr()                      {}
func (x TmeOne) Xpr()                             {}
func (x TmeOne) TmeTmeXpr()                       {}
func (x TmeNegOne) Xpr()                          {}
func (x TmeNegOne) TmeTmeXpr()                    {}
func (x TmeMin) Xpr()                             {}
func (x TmeMin) TmeTmeXpr()                       {}
func (x TmeMax) Xpr()                             {}
func (x TmeMax) TmeTmeXpr()                       {}
func (x TmeSecond) Xpr()                          {}
func (x TmeSecond) TmeTmeXpr()                    {}
func (x TmeMinute) Xpr()                          {}
func (x TmeMinute) TmeTmeXpr()                    {}
func (x TmeHour) Xpr()                            {}
func (x TmeHour) TmeTmeXpr()                      {}
func (x TmeDay) Xpr()                             {}
func (x TmeDay) TmeTmeXpr()                       {}
func (x TmeWeek) Xpr()                            {}
func (x TmeWeek) TmeTmeXpr()                      {}
func (x TmeS1) Xpr()                              {}
func (x TmeS1) TmeTmeXpr()                        {}
func (x TmeS5) Xpr()                              {}
func (x TmeS5) TmeTmeXpr()                        {}
func (x TmeS10) Xpr()                             {}
func (x TmeS10) TmeTmeXpr()                       {}
func (x TmeS15) Xpr()                             {}
func (x TmeS15) TmeTmeXpr()                       {}
func (x TmeS20) Xpr()                             {}
func (x TmeS20) TmeTmeXpr()                       {}
func (x TmeS30) Xpr()                             {}
func (x TmeS30) TmeTmeXpr()                       {}
func (x TmeS40) Xpr()                             {}
func (x TmeS40) TmeTmeXpr()                       {}
func (x TmeS50) Xpr()                             {}
func (x TmeS50) TmeTmeXpr()                       {}
func (x TmeM1) Xpr()                              {}
func (x TmeM1) TmeTmeXpr()                        {}
func (x TmeM5) Xpr()                              {}
func (x TmeM5) TmeTmeXpr()                        {}
func (x TmeM10) Xpr()                             {}
func (x TmeM10) TmeTmeXpr()                       {}
func (x TmeM15) Xpr()                             {}
func (x TmeM15) TmeTmeXpr()                       {}
func (x TmeM20) Xpr()                             {}
func (x TmeM20) TmeTmeXpr()                       {}
func (x TmeM30) Xpr()                             {}
func (x TmeM30) TmeTmeXpr()                       {}
func (x TmeM40) Xpr()                             {}
func (x TmeM40) TmeTmeXpr()                       {}
func (x TmeM50) Xpr()                             {}
func (x TmeM50) TmeTmeXpr()                       {}
func (x TmeH1) Xpr()                              {}
func (x TmeH1) TmeTmeXpr()                        {}
func (x TmeD1) Xpr()                              {}
func (x TmeD1) TmeTmeXpr()                        {}
func (x TmeResolution) Xpr()                      {}
func (x TmeResolution) TmeTmeXpr()                {}
func (x ClrBlack) Xpr()                           {}
func (x ClrBlack) ClrClrXpr()                     {}
func (x ClrWhite) Xpr()                           {}
func (x ClrWhite) ClrClrXpr()                     {}
func (x ClrRed50) Xpr()                           {}
func (x ClrRed50) ClrClrXpr()                     {}
func (x ClrRed100) Xpr()                          {}
func (x ClrRed100) ClrClrXpr()                    {}
func (x ClrRed200) Xpr()                          {}
func (x ClrRed200) ClrClrXpr()                    {}
func (x ClrRed300) Xpr()                          {}
func (x ClrRed300) ClrClrXpr()                    {}
func (x ClrRed400) Xpr()                          {}
func (x ClrRed400) ClrClrXpr()                    {}
func (x ClrRed500) Xpr()                          {}
func (x ClrRed500) ClrClrXpr()                    {}
func (x ClrRed600) Xpr()                          {}
func (x ClrRed600) ClrClrXpr()                    {}
func (x ClrRed700) Xpr()                          {}
func (x ClrRed700) ClrClrXpr()                    {}
func (x ClrRed800) Xpr()                          {}
func (x ClrRed800) ClrClrXpr()                    {}
func (x ClrRed900) Xpr()                          {}
func (x ClrRed900) ClrClrXpr()                    {}
func (x ClrRedA100) Xpr()                         {}
func (x ClrRedA100) ClrClrXpr()                   {}
func (x ClrRedA200) Xpr()                         {}
func (x ClrRedA200) ClrClrXpr()                   {}
func (x ClrRedA400) Xpr()                         {}
func (x ClrRedA400) ClrClrXpr()                   {}
func (x ClrRedA700) Xpr()                         {}
func (x ClrRedA700) ClrClrXpr()                   {}
func (x ClrPink50) Xpr()                          {}
func (x ClrPink50) ClrClrXpr()                    {}
func (x ClrPink100) Xpr()                         {}
func (x ClrPink100) ClrClrXpr()                   {}
func (x ClrPink200) Xpr()                         {}
func (x ClrPink200) ClrClrXpr()                   {}
func (x ClrPink300) Xpr()                         {}
func (x ClrPink300) ClrClrXpr()                   {}
func (x ClrPink400) Xpr()                         {}
func (x ClrPink400) ClrClrXpr()                   {}
func (x ClrPink500) Xpr()                         {}
func (x ClrPink500) ClrClrXpr()                   {}
func (x ClrPink600) Xpr()                         {}
func (x ClrPink600) ClrClrXpr()                   {}
func (x ClrPink700) Xpr()                         {}
func (x ClrPink700) ClrClrXpr()                   {}
func (x ClrPink800) Xpr()                         {}
func (x ClrPink800) ClrClrXpr()                   {}
func (x ClrPink900) Xpr()                         {}
func (x ClrPink900) ClrClrXpr()                   {}
func (x ClrPinkA100) Xpr()                        {}
func (x ClrPinkA100) ClrClrXpr()                  {}
func (x ClrPinkA200) Xpr()                        {}
func (x ClrPinkA200) ClrClrXpr()                  {}
func (x ClrPinkA400) Xpr()                        {}
func (x ClrPinkA400) ClrClrXpr()                  {}
func (x ClrPinkA700) Xpr()                        {}
func (x ClrPinkA700) ClrClrXpr()                  {}
func (x ClrPurple50) Xpr()                        {}
func (x ClrPurple50) ClrClrXpr()                  {}
func (x ClrPurple100) Xpr()                       {}
func (x ClrPurple100) ClrClrXpr()                 {}
func (x ClrPurple200) Xpr()                       {}
func (x ClrPurple200) ClrClrXpr()                 {}
func (x ClrPurple300) Xpr()                       {}
func (x ClrPurple300) ClrClrXpr()                 {}
func (x ClrPurple400) Xpr()                       {}
func (x ClrPurple400) ClrClrXpr()                 {}
func (x ClrPurple500) Xpr()                       {}
func (x ClrPurple500) ClrClrXpr()                 {}
func (x ClrPurple600) Xpr()                       {}
func (x ClrPurple600) ClrClrXpr()                 {}
func (x ClrPurple700) Xpr()                       {}
func (x ClrPurple700) ClrClrXpr()                 {}
func (x ClrPurple800) Xpr()                       {}
func (x ClrPurple800) ClrClrXpr()                 {}
func (x ClrPurple900) Xpr()                       {}
func (x ClrPurple900) ClrClrXpr()                 {}
func (x ClrPurpleA100) Xpr()                      {}
func (x ClrPurpleA100) ClrClrXpr()                {}
func (x ClrPurpleA200) Xpr()                      {}
func (x ClrPurpleA200) ClrClrXpr()                {}
func (x ClrPurpleA400) Xpr()                      {}
func (x ClrPurpleA400) ClrClrXpr()                {}
func (x ClrPurpleA700) Xpr()                      {}
func (x ClrPurpleA700) ClrClrXpr()                {}
func (x ClrDeepPurple50) Xpr()                    {}
func (x ClrDeepPurple50) ClrClrXpr()              {}
func (x ClrDeepPurple100) Xpr()                   {}
func (x ClrDeepPurple100) ClrClrXpr()             {}
func (x ClrDeepPurple200) Xpr()                   {}
func (x ClrDeepPurple200) ClrClrXpr()             {}
func (x ClrDeepPurple300) Xpr()                   {}
func (x ClrDeepPurple300) ClrClrXpr()             {}
func (x ClrDeepPurple400) Xpr()                   {}
func (x ClrDeepPurple400) ClrClrXpr()             {}
func (x ClrDeepPurple500) Xpr()                   {}
func (x ClrDeepPurple500) ClrClrXpr()             {}
func (x ClrDeepPurple600) Xpr()                   {}
func (x ClrDeepPurple600) ClrClrXpr()             {}
func (x ClrDeepPurple700) Xpr()                   {}
func (x ClrDeepPurple700) ClrClrXpr()             {}
func (x ClrDeepPurple800) Xpr()                   {}
func (x ClrDeepPurple800) ClrClrXpr()             {}
func (x ClrDeepPurple900) Xpr()                   {}
func (x ClrDeepPurple900) ClrClrXpr()             {}
func (x ClrDeepPurpleA100) Xpr()                  {}
func (x ClrDeepPurpleA100) ClrClrXpr()            {}
func (x ClrDeepPurpleA200) Xpr()                  {}
func (x ClrDeepPurpleA200) ClrClrXpr()            {}
func (x ClrDeepPurpleA400) Xpr()                  {}
func (x ClrDeepPurpleA400) ClrClrXpr()            {}
func (x ClrDeepPurpleA700) Xpr()                  {}
func (x ClrDeepPurpleA700) ClrClrXpr()            {}
func (x ClrIndigo50) Xpr()                        {}
func (x ClrIndigo50) ClrClrXpr()                  {}
func (x ClrIndigo100) Xpr()                       {}
func (x ClrIndigo100) ClrClrXpr()                 {}
func (x ClrIndigo200) Xpr()                       {}
func (x ClrIndigo200) ClrClrXpr()                 {}
func (x ClrIndigo300) Xpr()                       {}
func (x ClrIndigo300) ClrClrXpr()                 {}
func (x ClrIndigo400) Xpr()                       {}
func (x ClrIndigo400) ClrClrXpr()                 {}
func (x ClrIndigo500) Xpr()                       {}
func (x ClrIndigo500) ClrClrXpr()                 {}
func (x ClrIndigo600) Xpr()                       {}
func (x ClrIndigo600) ClrClrXpr()                 {}
func (x ClrIndigo700) Xpr()                       {}
func (x ClrIndigo700) ClrClrXpr()                 {}
func (x ClrIndigo800) Xpr()                       {}
func (x ClrIndigo800) ClrClrXpr()                 {}
func (x ClrIndigo900) Xpr()                       {}
func (x ClrIndigo900) ClrClrXpr()                 {}
func (x ClrIndigoA100) Xpr()                      {}
func (x ClrIndigoA100) ClrClrXpr()                {}
func (x ClrIndigoA200) Xpr()                      {}
func (x ClrIndigoA200) ClrClrXpr()                {}
func (x ClrIndigoA400) Xpr()                      {}
func (x ClrIndigoA400) ClrClrXpr()                {}
func (x ClrIndigoA700) Xpr()                      {}
func (x ClrIndigoA700) ClrClrXpr()                {}
func (x ClrBlue50) Xpr()                          {}
func (x ClrBlue50) ClrClrXpr()                    {}
func (x ClrBlue100) Xpr()                         {}
func (x ClrBlue100) ClrClrXpr()                   {}
func (x ClrBlue200) Xpr()                         {}
func (x ClrBlue200) ClrClrXpr()                   {}
func (x ClrBlue300) Xpr()                         {}
func (x ClrBlue300) ClrClrXpr()                   {}
func (x ClrBlue400) Xpr()                         {}
func (x ClrBlue400) ClrClrXpr()                   {}
func (x ClrBlue500) Xpr()                         {}
func (x ClrBlue500) ClrClrXpr()                   {}
func (x ClrBlue600) Xpr()                         {}
func (x ClrBlue600) ClrClrXpr()                   {}
func (x ClrBlue700) Xpr()                         {}
func (x ClrBlue700) ClrClrXpr()                   {}
func (x ClrBlue800) Xpr()                         {}
func (x ClrBlue800) ClrClrXpr()                   {}
func (x ClrBlue900) Xpr()                         {}
func (x ClrBlue900) ClrClrXpr()                   {}
func (x ClrBlueA100) Xpr()                        {}
func (x ClrBlueA100) ClrClrXpr()                  {}
func (x ClrBlueA200) Xpr()                        {}
func (x ClrBlueA200) ClrClrXpr()                  {}
func (x ClrBlueA400) Xpr()                        {}
func (x ClrBlueA400) ClrClrXpr()                  {}
func (x ClrBlueA700) Xpr()                        {}
func (x ClrBlueA700) ClrClrXpr()                  {}
func (x ClrLightBlue50) Xpr()                     {}
func (x ClrLightBlue50) ClrClrXpr()               {}
func (x ClrLightBlue100) Xpr()                    {}
func (x ClrLightBlue100) ClrClrXpr()              {}
func (x ClrLightBlue200) Xpr()                    {}
func (x ClrLightBlue200) ClrClrXpr()              {}
func (x ClrLightBlue300) Xpr()                    {}
func (x ClrLightBlue300) ClrClrXpr()              {}
func (x ClrLightBlue400) Xpr()                    {}
func (x ClrLightBlue400) ClrClrXpr()              {}
func (x ClrLightBlue500) Xpr()                    {}
func (x ClrLightBlue500) ClrClrXpr()              {}
func (x ClrLightBlue600) Xpr()                    {}
func (x ClrLightBlue600) ClrClrXpr()              {}
func (x ClrLightBlue700) Xpr()                    {}
func (x ClrLightBlue700) ClrClrXpr()              {}
func (x ClrLightBlue800) Xpr()                    {}
func (x ClrLightBlue800) ClrClrXpr()              {}
func (x ClrLightBlue900) Xpr()                    {}
func (x ClrLightBlue900) ClrClrXpr()              {}
func (x ClrLightBlueA100) Xpr()                   {}
func (x ClrLightBlueA100) ClrClrXpr()             {}
func (x ClrLightBlueA200) Xpr()                   {}
func (x ClrLightBlueA200) ClrClrXpr()             {}
func (x ClrLightBlueA400) Xpr()                   {}
func (x ClrLightBlueA400) ClrClrXpr()             {}
func (x ClrLightBlueA700) Xpr()                   {}
func (x ClrLightBlueA700) ClrClrXpr()             {}
func (x ClrCyan50) Xpr()                          {}
func (x ClrCyan50) ClrClrXpr()                    {}
func (x ClrCyan100) Xpr()                         {}
func (x ClrCyan100) ClrClrXpr()                   {}
func (x ClrCyan200) Xpr()                         {}
func (x ClrCyan200) ClrClrXpr()                   {}
func (x ClrCyan300) Xpr()                         {}
func (x ClrCyan300) ClrClrXpr()                   {}
func (x ClrCyan400) Xpr()                         {}
func (x ClrCyan400) ClrClrXpr()                   {}
func (x ClrCyan500) Xpr()                         {}
func (x ClrCyan500) ClrClrXpr()                   {}
func (x ClrCyan600) Xpr()                         {}
func (x ClrCyan600) ClrClrXpr()                   {}
func (x ClrCyan700) Xpr()                         {}
func (x ClrCyan700) ClrClrXpr()                   {}
func (x ClrCyan800) Xpr()                         {}
func (x ClrCyan800) ClrClrXpr()                   {}
func (x ClrCyan900) Xpr()                         {}
func (x ClrCyan900) ClrClrXpr()                   {}
func (x ClrCyanA100) Xpr()                        {}
func (x ClrCyanA100) ClrClrXpr()                  {}
func (x ClrCyanA200) Xpr()                        {}
func (x ClrCyanA200) ClrClrXpr()                  {}
func (x ClrCyanA400) Xpr()                        {}
func (x ClrCyanA400) ClrClrXpr()                  {}
func (x ClrCyanA700) Xpr()                        {}
func (x ClrCyanA700) ClrClrXpr()                  {}
func (x ClrTeal50) Xpr()                          {}
func (x ClrTeal50) ClrClrXpr()                    {}
func (x ClrTeal100) Xpr()                         {}
func (x ClrTeal100) ClrClrXpr()                   {}
func (x ClrTeal200) Xpr()                         {}
func (x ClrTeal200) ClrClrXpr()                   {}
func (x ClrTeal300) Xpr()                         {}
func (x ClrTeal300) ClrClrXpr()                   {}
func (x ClrTeal400) Xpr()                         {}
func (x ClrTeal400) ClrClrXpr()                   {}
func (x ClrTeal500) Xpr()                         {}
func (x ClrTeal500) ClrClrXpr()                   {}
func (x ClrTeal600) Xpr()                         {}
func (x ClrTeal600) ClrClrXpr()                   {}
func (x ClrTeal700) Xpr()                         {}
func (x ClrTeal700) ClrClrXpr()                   {}
func (x ClrTeal800) Xpr()                         {}
func (x ClrTeal800) ClrClrXpr()                   {}
func (x ClrTeal900) Xpr()                         {}
func (x ClrTeal900) ClrClrXpr()                   {}
func (x ClrTealA100) Xpr()                        {}
func (x ClrTealA100) ClrClrXpr()                  {}
func (x ClrTealA200) Xpr()                        {}
func (x ClrTealA200) ClrClrXpr()                  {}
func (x ClrTealA400) Xpr()                        {}
func (x ClrTealA400) ClrClrXpr()                  {}
func (x ClrTealA700) Xpr()                        {}
func (x ClrTealA700) ClrClrXpr()                  {}
func (x ClrGreen50) Xpr()                         {}
func (x ClrGreen50) ClrClrXpr()                   {}
func (x ClrGreen100) Xpr()                        {}
func (x ClrGreen100) ClrClrXpr()                  {}
func (x ClrGreen200) Xpr()                        {}
func (x ClrGreen200) ClrClrXpr()                  {}
func (x ClrGreen300) Xpr()                        {}
func (x ClrGreen300) ClrClrXpr()                  {}
func (x ClrGreen400) Xpr()                        {}
func (x ClrGreen400) ClrClrXpr()                  {}
func (x ClrGreen500) Xpr()                        {}
func (x ClrGreen500) ClrClrXpr()                  {}
func (x ClrGreen600) Xpr()                        {}
func (x ClrGreen600) ClrClrXpr()                  {}
func (x ClrGreen700) Xpr()                        {}
func (x ClrGreen700) ClrClrXpr()                  {}
func (x ClrGreen800) Xpr()                        {}
func (x ClrGreen800) ClrClrXpr()                  {}
func (x ClrGreen900) Xpr()                        {}
func (x ClrGreen900) ClrClrXpr()                  {}
func (x ClrGreenA100) Xpr()                       {}
func (x ClrGreenA100) ClrClrXpr()                 {}
func (x ClrGreenA200) Xpr()                       {}
func (x ClrGreenA200) ClrClrXpr()                 {}
func (x ClrGreenA400) Xpr()                       {}
func (x ClrGreenA400) ClrClrXpr()                 {}
func (x ClrGreenA700) Xpr()                       {}
func (x ClrGreenA700) ClrClrXpr()                 {}
func (x ClrLightGreen50) Xpr()                    {}
func (x ClrLightGreen50) ClrClrXpr()              {}
func (x ClrLightGreen100) Xpr()                   {}
func (x ClrLightGreen100) ClrClrXpr()             {}
func (x ClrLightGreen200) Xpr()                   {}
func (x ClrLightGreen200) ClrClrXpr()             {}
func (x ClrLightGreen300) Xpr()                   {}
func (x ClrLightGreen300) ClrClrXpr()             {}
func (x ClrLightGreen400) Xpr()                   {}
func (x ClrLightGreen400) ClrClrXpr()             {}
func (x ClrLightGreen500) Xpr()                   {}
func (x ClrLightGreen500) ClrClrXpr()             {}
func (x ClrLightGreen600) Xpr()                   {}
func (x ClrLightGreen600) ClrClrXpr()             {}
func (x ClrLightGreen700) Xpr()                   {}
func (x ClrLightGreen700) ClrClrXpr()             {}
func (x ClrLightGreen800) Xpr()                   {}
func (x ClrLightGreen800) ClrClrXpr()             {}
func (x ClrLightGreen900) Xpr()                   {}
func (x ClrLightGreen900) ClrClrXpr()             {}
func (x ClrLightGreenA100) Xpr()                  {}
func (x ClrLightGreenA100) ClrClrXpr()            {}
func (x ClrLightGreenA200) Xpr()                  {}
func (x ClrLightGreenA200) ClrClrXpr()            {}
func (x ClrLightGreenA400) Xpr()                  {}
func (x ClrLightGreenA400) ClrClrXpr()            {}
func (x ClrLightGreenA700) Xpr()                  {}
func (x ClrLightGreenA700) ClrClrXpr()            {}
func (x ClrLime50) Xpr()                          {}
func (x ClrLime50) ClrClrXpr()                    {}
func (x ClrLime100) Xpr()                         {}
func (x ClrLime100) ClrClrXpr()                   {}
func (x ClrLime200) Xpr()                         {}
func (x ClrLime200) ClrClrXpr()                   {}
func (x ClrLime300) Xpr()                         {}
func (x ClrLime300) ClrClrXpr()                   {}
func (x ClrLime400) Xpr()                         {}
func (x ClrLime400) ClrClrXpr()                   {}
func (x ClrLime500) Xpr()                         {}
func (x ClrLime500) ClrClrXpr()                   {}
func (x ClrLime600) Xpr()                         {}
func (x ClrLime600) ClrClrXpr()                   {}
func (x ClrLime700) Xpr()                         {}
func (x ClrLime700) ClrClrXpr()                   {}
func (x ClrLime800) Xpr()                         {}
func (x ClrLime800) ClrClrXpr()                   {}
func (x ClrLime900) Xpr()                         {}
func (x ClrLime900) ClrClrXpr()                   {}
func (x ClrLimeA100) Xpr()                        {}
func (x ClrLimeA100) ClrClrXpr()                  {}
func (x ClrLimeA200) Xpr()                        {}
func (x ClrLimeA200) ClrClrXpr()                  {}
func (x ClrLimeA400) Xpr()                        {}
func (x ClrLimeA400) ClrClrXpr()                  {}
func (x ClrLimeA700) Xpr()                        {}
func (x ClrLimeA700) ClrClrXpr()                  {}
func (x ClrYellow50) Xpr()                        {}
func (x ClrYellow50) ClrClrXpr()                  {}
func (x ClrYellow100) Xpr()                       {}
func (x ClrYellow100) ClrClrXpr()                 {}
func (x ClrYellow200) Xpr()                       {}
func (x ClrYellow200) ClrClrXpr()                 {}
func (x ClrYellow300) Xpr()                       {}
func (x ClrYellow300) ClrClrXpr()                 {}
func (x ClrYellow400) Xpr()                       {}
func (x ClrYellow400) ClrClrXpr()                 {}
func (x ClrYellow500) Xpr()                       {}
func (x ClrYellow500) ClrClrXpr()                 {}
func (x ClrYellow600) Xpr()                       {}
func (x ClrYellow600) ClrClrXpr()                 {}
func (x ClrYellow700) Xpr()                       {}
func (x ClrYellow700) ClrClrXpr()                 {}
func (x ClrYellow800) Xpr()                       {}
func (x ClrYellow800) ClrClrXpr()                 {}
func (x ClrYellow900) Xpr()                       {}
func (x ClrYellow900) ClrClrXpr()                 {}
func (x ClrYellowA100) Xpr()                      {}
func (x ClrYellowA100) ClrClrXpr()                {}
func (x ClrYellowA200) Xpr()                      {}
func (x ClrYellowA200) ClrClrXpr()                {}
func (x ClrYellowA400) Xpr()                      {}
func (x ClrYellowA400) ClrClrXpr()                {}
func (x ClrYellowA700) Xpr()                      {}
func (x ClrYellowA700) ClrClrXpr()                {}
func (x ClrAmber50) Xpr()                         {}
func (x ClrAmber50) ClrClrXpr()                   {}
func (x ClrAmber100) Xpr()                        {}
func (x ClrAmber100) ClrClrXpr()                  {}
func (x ClrAmber200) Xpr()                        {}
func (x ClrAmber200) ClrClrXpr()                  {}
func (x ClrAmber300) Xpr()                        {}
func (x ClrAmber300) ClrClrXpr()                  {}
func (x ClrAmber400) Xpr()                        {}
func (x ClrAmber400) ClrClrXpr()                  {}
func (x ClrAmber500) Xpr()                        {}
func (x ClrAmber500) ClrClrXpr()                  {}
func (x ClrAmber600) Xpr()                        {}
func (x ClrAmber600) ClrClrXpr()                  {}
func (x ClrAmber700) Xpr()                        {}
func (x ClrAmber700) ClrClrXpr()                  {}
func (x ClrAmber800) Xpr()                        {}
func (x ClrAmber800) ClrClrXpr()                  {}
func (x ClrAmber900) Xpr()                        {}
func (x ClrAmber900) ClrClrXpr()                  {}
func (x ClrAmberA100) Xpr()                       {}
func (x ClrAmberA100) ClrClrXpr()                 {}
func (x ClrAmberA200) Xpr()                       {}
func (x ClrAmberA200) ClrClrXpr()                 {}
func (x ClrAmberA400) Xpr()                       {}
func (x ClrAmberA400) ClrClrXpr()                 {}
func (x ClrAmberA700) Xpr()                       {}
func (x ClrAmberA700) ClrClrXpr()                 {}
func (x ClrOrange50) Xpr()                        {}
func (x ClrOrange50) ClrClrXpr()                  {}
func (x ClrOrange100) Xpr()                       {}
func (x ClrOrange100) ClrClrXpr()                 {}
func (x ClrOrange200) Xpr()                       {}
func (x ClrOrange200) ClrClrXpr()                 {}
func (x ClrOrange300) Xpr()                       {}
func (x ClrOrange300) ClrClrXpr()                 {}
func (x ClrOrange400) Xpr()                       {}
func (x ClrOrange400) ClrClrXpr()                 {}
func (x ClrOrange500) Xpr()                       {}
func (x ClrOrange500) ClrClrXpr()                 {}
func (x ClrOrange600) Xpr()                       {}
func (x ClrOrange600) ClrClrXpr()                 {}
func (x ClrOrange700) Xpr()                       {}
func (x ClrOrange700) ClrClrXpr()                 {}
func (x ClrOrange800) Xpr()                       {}
func (x ClrOrange800) ClrClrXpr()                 {}
func (x ClrOrange900) Xpr()                       {}
func (x ClrOrange900) ClrClrXpr()                 {}
func (x ClrOrangeA100) Xpr()                      {}
func (x ClrOrangeA100) ClrClrXpr()                {}
func (x ClrOrangeA200) Xpr()                      {}
func (x ClrOrangeA200) ClrClrXpr()                {}
func (x ClrOrangeA400) Xpr()                      {}
func (x ClrOrangeA400) ClrClrXpr()                {}
func (x ClrOrangeA700) Xpr()                      {}
func (x ClrOrangeA700) ClrClrXpr()                {}
func (x ClrDeepOrange50) Xpr()                    {}
func (x ClrDeepOrange50) ClrClrXpr()              {}
func (x ClrDeepOrange100) Xpr()                   {}
func (x ClrDeepOrange100) ClrClrXpr()             {}
func (x ClrDeepOrange200) Xpr()                   {}
func (x ClrDeepOrange200) ClrClrXpr()             {}
func (x ClrDeepOrange300) Xpr()                   {}
func (x ClrDeepOrange300) ClrClrXpr()             {}
func (x ClrDeepOrange400) Xpr()                   {}
func (x ClrDeepOrange400) ClrClrXpr()             {}
func (x ClrDeepOrange500) Xpr()                   {}
func (x ClrDeepOrange500) ClrClrXpr()             {}
func (x ClrDeepOrange600) Xpr()                   {}
func (x ClrDeepOrange600) ClrClrXpr()             {}
func (x ClrDeepOrange700) Xpr()                   {}
func (x ClrDeepOrange700) ClrClrXpr()             {}
func (x ClrDeepOrange800) Xpr()                   {}
func (x ClrDeepOrange800) ClrClrXpr()             {}
func (x ClrDeepOrange900) Xpr()                   {}
func (x ClrDeepOrange900) ClrClrXpr()             {}
func (x ClrDeepOrangeA100) Xpr()                  {}
func (x ClrDeepOrangeA100) ClrClrXpr()            {}
func (x ClrDeepOrangeA200) Xpr()                  {}
func (x ClrDeepOrangeA200) ClrClrXpr()            {}
func (x ClrDeepOrangeA400) Xpr()                  {}
func (x ClrDeepOrangeA400) ClrClrXpr()            {}
func (x ClrDeepOrangeA700) Xpr()                  {}
func (x ClrDeepOrangeA700) ClrClrXpr()            {}
func (x ClrBrown50) Xpr()                         {}
func (x ClrBrown50) ClrClrXpr()                   {}
func (x ClrBrown100) Xpr()                        {}
func (x ClrBrown100) ClrClrXpr()                  {}
func (x ClrBrown200) Xpr()                        {}
func (x ClrBrown200) ClrClrXpr()                  {}
func (x ClrBrown300) Xpr()                        {}
func (x ClrBrown300) ClrClrXpr()                  {}
func (x ClrBrown400) Xpr()                        {}
func (x ClrBrown400) ClrClrXpr()                  {}
func (x ClrBrown500) Xpr()                        {}
func (x ClrBrown500) ClrClrXpr()                  {}
func (x ClrBrown600) Xpr()                        {}
func (x ClrBrown600) ClrClrXpr()                  {}
func (x ClrBrown700) Xpr()                        {}
func (x ClrBrown700) ClrClrXpr()                  {}
func (x ClrBrown800) Xpr()                        {}
func (x ClrBrown800) ClrClrXpr()                  {}
func (x ClrBrown900) Xpr()                        {}
func (x ClrBrown900) ClrClrXpr()                  {}
func (x ClrGrey50) Xpr()                          {}
func (x ClrGrey50) ClrClrXpr()                    {}
func (x ClrGrey100) Xpr()                         {}
func (x ClrGrey100) ClrClrXpr()                   {}
func (x ClrGrey200) Xpr()                         {}
func (x ClrGrey200) ClrClrXpr()                   {}
func (x ClrGrey300) Xpr()                         {}
func (x ClrGrey300) ClrClrXpr()                   {}
func (x ClrGrey400) Xpr()                         {}
func (x ClrGrey400) ClrClrXpr()                   {}
func (x ClrGrey500) Xpr()                         {}
func (x ClrGrey500) ClrClrXpr()                   {}
func (x ClrGrey600) Xpr()                         {}
func (x ClrGrey600) ClrClrXpr()                   {}
func (x ClrGrey700) Xpr()                         {}
func (x ClrGrey700) ClrClrXpr()                   {}
func (x ClrGrey800) Xpr()                         {}
func (x ClrGrey800) ClrClrXpr()                   {}
func (x ClrGrey900) Xpr()                         {}
func (x ClrGrey900) ClrClrXpr()                   {}
func (x ClrBlueGrey50) Xpr()                      {}
func (x ClrBlueGrey50) ClrClrXpr()                {}
func (x ClrBlueGrey100) Xpr()                     {}
func (x ClrBlueGrey100) ClrClrXpr()               {}
func (x ClrBlueGrey200) Xpr()                     {}
func (x ClrBlueGrey200) ClrClrXpr()               {}
func (x ClrBlueGrey300) Xpr()                     {}
func (x ClrBlueGrey300) ClrClrXpr()               {}
func (x ClrBlueGrey400) Xpr()                     {}
func (x ClrBlueGrey400) ClrClrXpr()               {}
func (x ClrBlueGrey500) Xpr()                     {}
func (x ClrBlueGrey500) ClrClrXpr()               {}
func (x ClrBlueGrey600) Xpr()                     {}
func (x ClrBlueGrey600) ClrClrXpr()               {}
func (x ClrBlueGrey700) Xpr()                     {}
func (x ClrBlueGrey700) ClrClrXpr()               {}
func (x ClrBlueGrey800) Xpr()                     {}
func (x ClrBlueGrey800) ClrClrXpr()               {}
func (x ClrBlueGrey900) Xpr()                     {}
func (x ClrBlueGrey900) ClrClrXpr()               {}
func (x PenBlack) Xpr()                           {}
func (x PenBlack) PenPenXpr()                     {}
func (x PenWhite) Xpr()                           {}
func (x PenWhite) PenPenXpr()                     {}
func (x PenRed50) Xpr()                           {}
func (x PenRed50) PenPenXpr()                     {}
func (x PenRed100) Xpr()                          {}
func (x PenRed100) PenPenXpr()                    {}
func (x PenRed200) Xpr()                          {}
func (x PenRed200) PenPenXpr()                    {}
func (x PenRed300) Xpr()                          {}
func (x PenRed300) PenPenXpr()                    {}
func (x PenRed400) Xpr()                          {}
func (x PenRed400) PenPenXpr()                    {}
func (x PenRed500) Xpr()                          {}
func (x PenRed500) PenPenXpr()                    {}
func (x PenRed600) Xpr()                          {}
func (x PenRed600) PenPenXpr()                    {}
func (x PenRed700) Xpr()                          {}
func (x PenRed700) PenPenXpr()                    {}
func (x PenRed800) Xpr()                          {}
func (x PenRed800) PenPenXpr()                    {}
func (x PenRed900) Xpr()                          {}
func (x PenRed900) PenPenXpr()                    {}
func (x PenRedA100) Xpr()                         {}
func (x PenRedA100) PenPenXpr()                   {}
func (x PenRedA200) Xpr()                         {}
func (x PenRedA200) PenPenXpr()                   {}
func (x PenRedA400) Xpr()                         {}
func (x PenRedA400) PenPenXpr()                   {}
func (x PenRedA700) Xpr()                         {}
func (x PenRedA700) PenPenXpr()                   {}
func (x PenPink50) Xpr()                          {}
func (x PenPink50) PenPenXpr()                    {}
func (x PenPink100) Xpr()                         {}
func (x PenPink100) PenPenXpr()                   {}
func (x PenPink200) Xpr()                         {}
func (x PenPink200) PenPenXpr()                   {}
func (x PenPink300) Xpr()                         {}
func (x PenPink300) PenPenXpr()                   {}
func (x PenPink400) Xpr()                         {}
func (x PenPink400) PenPenXpr()                   {}
func (x PenPink500) Xpr()                         {}
func (x PenPink500) PenPenXpr()                   {}
func (x PenPink600) Xpr()                         {}
func (x PenPink600) PenPenXpr()                   {}
func (x PenPink700) Xpr()                         {}
func (x PenPink700) PenPenXpr()                   {}
func (x PenPink800) Xpr()                         {}
func (x PenPink800) PenPenXpr()                   {}
func (x PenPink900) Xpr()                         {}
func (x PenPink900) PenPenXpr()                   {}
func (x PenPinkA100) Xpr()                        {}
func (x PenPinkA100) PenPenXpr()                  {}
func (x PenPinkA200) Xpr()                        {}
func (x PenPinkA200) PenPenXpr()                  {}
func (x PenPinkA400) Xpr()                        {}
func (x PenPinkA400) PenPenXpr()                  {}
func (x PenPinkA700) Xpr()                        {}
func (x PenPinkA700) PenPenXpr()                  {}
func (x PenPurple50) Xpr()                        {}
func (x PenPurple50) PenPenXpr()                  {}
func (x PenPurple100) Xpr()                       {}
func (x PenPurple100) PenPenXpr()                 {}
func (x PenPurple200) Xpr()                       {}
func (x PenPurple200) PenPenXpr()                 {}
func (x PenPurple300) Xpr()                       {}
func (x PenPurple300) PenPenXpr()                 {}
func (x PenPurple400) Xpr()                       {}
func (x PenPurple400) PenPenXpr()                 {}
func (x PenPurple500) Xpr()                       {}
func (x PenPurple500) PenPenXpr()                 {}
func (x PenPurple600) Xpr()                       {}
func (x PenPurple600) PenPenXpr()                 {}
func (x PenPurple700) Xpr()                       {}
func (x PenPurple700) PenPenXpr()                 {}
func (x PenPurple800) Xpr()                       {}
func (x PenPurple800) PenPenXpr()                 {}
func (x PenPurple900) Xpr()                       {}
func (x PenPurple900) PenPenXpr()                 {}
func (x PenPurpleA100) Xpr()                      {}
func (x PenPurpleA100) PenPenXpr()                {}
func (x PenPurpleA200) Xpr()                      {}
func (x PenPurpleA200) PenPenXpr()                {}
func (x PenPurpleA400) Xpr()                      {}
func (x PenPurpleA400) PenPenXpr()                {}
func (x PenPurpleA700) Xpr()                      {}
func (x PenPurpleA700) PenPenXpr()                {}
func (x PenDeepPurple50) Xpr()                    {}
func (x PenDeepPurple50) PenPenXpr()              {}
func (x PenDeepPurple100) Xpr()                   {}
func (x PenDeepPurple100) PenPenXpr()             {}
func (x PenDeepPurple200) Xpr()                   {}
func (x PenDeepPurple200) PenPenXpr()             {}
func (x PenDeepPurple300) Xpr()                   {}
func (x PenDeepPurple300) PenPenXpr()             {}
func (x PenDeepPurple400) Xpr()                   {}
func (x PenDeepPurple400) PenPenXpr()             {}
func (x PenDeepPurple500) Xpr()                   {}
func (x PenDeepPurple500) PenPenXpr()             {}
func (x PenDeepPurple600) Xpr()                   {}
func (x PenDeepPurple600) PenPenXpr()             {}
func (x PenDeepPurple700) Xpr()                   {}
func (x PenDeepPurple700) PenPenXpr()             {}
func (x PenDeepPurple800) Xpr()                   {}
func (x PenDeepPurple800) PenPenXpr()             {}
func (x PenDeepPurple900) Xpr()                   {}
func (x PenDeepPurple900) PenPenXpr()             {}
func (x PenDeepPurpleA100) Xpr()                  {}
func (x PenDeepPurpleA100) PenPenXpr()            {}
func (x PenDeepPurpleA200) Xpr()                  {}
func (x PenDeepPurpleA200) PenPenXpr()            {}
func (x PenDeepPurpleA400) Xpr()                  {}
func (x PenDeepPurpleA400) PenPenXpr()            {}
func (x PenDeepPurpleA700) Xpr()                  {}
func (x PenDeepPurpleA700) PenPenXpr()            {}
func (x PenIndigo50) Xpr()                        {}
func (x PenIndigo50) PenPenXpr()                  {}
func (x PenIndigo100) Xpr()                       {}
func (x PenIndigo100) PenPenXpr()                 {}
func (x PenIndigo200) Xpr()                       {}
func (x PenIndigo200) PenPenXpr()                 {}
func (x PenIndigo300) Xpr()                       {}
func (x PenIndigo300) PenPenXpr()                 {}
func (x PenIndigo400) Xpr()                       {}
func (x PenIndigo400) PenPenXpr()                 {}
func (x PenIndigo500) Xpr()                       {}
func (x PenIndigo500) PenPenXpr()                 {}
func (x PenIndigo600) Xpr()                       {}
func (x PenIndigo600) PenPenXpr()                 {}
func (x PenIndigo700) Xpr()                       {}
func (x PenIndigo700) PenPenXpr()                 {}
func (x PenIndigo800) Xpr()                       {}
func (x PenIndigo800) PenPenXpr()                 {}
func (x PenIndigo900) Xpr()                       {}
func (x PenIndigo900) PenPenXpr()                 {}
func (x PenIndigoA100) Xpr()                      {}
func (x PenIndigoA100) PenPenXpr()                {}
func (x PenIndigoA200) Xpr()                      {}
func (x PenIndigoA200) PenPenXpr()                {}
func (x PenIndigoA400) Xpr()                      {}
func (x PenIndigoA400) PenPenXpr()                {}
func (x PenIndigoA700) Xpr()                      {}
func (x PenIndigoA700) PenPenXpr()                {}
func (x PenBlue50) Xpr()                          {}
func (x PenBlue50) PenPenXpr()                    {}
func (x PenBlue100) Xpr()                         {}
func (x PenBlue100) PenPenXpr()                   {}
func (x PenBlue200) Xpr()                         {}
func (x PenBlue200) PenPenXpr()                   {}
func (x PenBlue300) Xpr()                         {}
func (x PenBlue300) PenPenXpr()                   {}
func (x PenBlue400) Xpr()                         {}
func (x PenBlue400) PenPenXpr()                   {}
func (x PenBlue500) Xpr()                         {}
func (x PenBlue500) PenPenXpr()                   {}
func (x PenBlue600) Xpr()                         {}
func (x PenBlue600) PenPenXpr()                   {}
func (x PenBlue700) Xpr()                         {}
func (x PenBlue700) PenPenXpr()                   {}
func (x PenBlue800) Xpr()                         {}
func (x PenBlue800) PenPenXpr()                   {}
func (x PenBlue900) Xpr()                         {}
func (x PenBlue900) PenPenXpr()                   {}
func (x PenBlueA100) Xpr()                        {}
func (x PenBlueA100) PenPenXpr()                  {}
func (x PenBlueA200) Xpr()                        {}
func (x PenBlueA200) PenPenXpr()                  {}
func (x PenBlueA400) Xpr()                        {}
func (x PenBlueA400) PenPenXpr()                  {}
func (x PenBlueA700) Xpr()                        {}
func (x PenBlueA700) PenPenXpr()                  {}
func (x PenLightBlue50) Xpr()                     {}
func (x PenLightBlue50) PenPenXpr()               {}
func (x PenLightBlue100) Xpr()                    {}
func (x PenLightBlue100) PenPenXpr()              {}
func (x PenLightBlue200) Xpr()                    {}
func (x PenLightBlue200) PenPenXpr()              {}
func (x PenLightBlue300) Xpr()                    {}
func (x PenLightBlue300) PenPenXpr()              {}
func (x PenLightBlue400) Xpr()                    {}
func (x PenLightBlue400) PenPenXpr()              {}
func (x PenLightBlue500) Xpr()                    {}
func (x PenLightBlue500) PenPenXpr()              {}
func (x PenLightBlue600) Xpr()                    {}
func (x PenLightBlue600) PenPenXpr()              {}
func (x PenLightBlue700) Xpr()                    {}
func (x PenLightBlue700) PenPenXpr()              {}
func (x PenLightBlue800) Xpr()                    {}
func (x PenLightBlue800) PenPenXpr()              {}
func (x PenLightBlue900) Xpr()                    {}
func (x PenLightBlue900) PenPenXpr()              {}
func (x PenLightBlueA100) Xpr()                   {}
func (x PenLightBlueA100) PenPenXpr()             {}
func (x PenLightBlueA200) Xpr()                   {}
func (x PenLightBlueA200) PenPenXpr()             {}
func (x PenLightBlueA400) Xpr()                   {}
func (x PenLightBlueA400) PenPenXpr()             {}
func (x PenLightBlueA700) Xpr()                   {}
func (x PenLightBlueA700) PenPenXpr()             {}
func (x PenCyan50) Xpr()                          {}
func (x PenCyan50) PenPenXpr()                    {}
func (x PenCyan100) Xpr()                         {}
func (x PenCyan100) PenPenXpr()                   {}
func (x PenCyan200) Xpr()                         {}
func (x PenCyan200) PenPenXpr()                   {}
func (x PenCyan300) Xpr()                         {}
func (x PenCyan300) PenPenXpr()                   {}
func (x PenCyan400) Xpr()                         {}
func (x PenCyan400) PenPenXpr()                   {}
func (x PenCyan500) Xpr()                         {}
func (x PenCyan500) PenPenXpr()                   {}
func (x PenCyan600) Xpr()                         {}
func (x PenCyan600) PenPenXpr()                   {}
func (x PenCyan700) Xpr()                         {}
func (x PenCyan700) PenPenXpr()                   {}
func (x PenCyan800) Xpr()                         {}
func (x PenCyan800) PenPenXpr()                   {}
func (x PenCyan900) Xpr()                         {}
func (x PenCyan900) PenPenXpr()                   {}
func (x PenCyanA100) Xpr()                        {}
func (x PenCyanA100) PenPenXpr()                  {}
func (x PenCyanA200) Xpr()                        {}
func (x PenCyanA200) PenPenXpr()                  {}
func (x PenCyanA400) Xpr()                        {}
func (x PenCyanA400) PenPenXpr()                  {}
func (x PenCyanA700) Xpr()                        {}
func (x PenCyanA700) PenPenXpr()                  {}
func (x PenTeal50) Xpr()                          {}
func (x PenTeal50) PenPenXpr()                    {}
func (x PenTeal100) Xpr()                         {}
func (x PenTeal100) PenPenXpr()                   {}
func (x PenTeal200) Xpr()                         {}
func (x PenTeal200) PenPenXpr()                   {}
func (x PenTeal300) Xpr()                         {}
func (x PenTeal300) PenPenXpr()                   {}
func (x PenTeal400) Xpr()                         {}
func (x PenTeal400) PenPenXpr()                   {}
func (x PenTeal500) Xpr()                         {}
func (x PenTeal500) PenPenXpr()                   {}
func (x PenTeal600) Xpr()                         {}
func (x PenTeal600) PenPenXpr()                   {}
func (x PenTeal700) Xpr()                         {}
func (x PenTeal700) PenPenXpr()                   {}
func (x PenTeal800) Xpr()                         {}
func (x PenTeal800) PenPenXpr()                   {}
func (x PenTeal900) Xpr()                         {}
func (x PenTeal900) PenPenXpr()                   {}
func (x PenTealA100) Xpr()                        {}
func (x PenTealA100) PenPenXpr()                  {}
func (x PenTealA200) Xpr()                        {}
func (x PenTealA200) PenPenXpr()                  {}
func (x PenTealA400) Xpr()                        {}
func (x PenTealA400) PenPenXpr()                  {}
func (x PenTealA700) Xpr()                        {}
func (x PenTealA700) PenPenXpr()                  {}
func (x PenGreen50) Xpr()                         {}
func (x PenGreen50) PenPenXpr()                   {}
func (x PenGreen100) Xpr()                        {}
func (x PenGreen100) PenPenXpr()                  {}
func (x PenGreen200) Xpr()                        {}
func (x PenGreen200) PenPenXpr()                  {}
func (x PenGreen300) Xpr()                        {}
func (x PenGreen300) PenPenXpr()                  {}
func (x PenGreen400) Xpr()                        {}
func (x PenGreen400) PenPenXpr()                  {}
func (x PenGreen500) Xpr()                        {}
func (x PenGreen500) PenPenXpr()                  {}
func (x PenGreen600) Xpr()                        {}
func (x PenGreen600) PenPenXpr()                  {}
func (x PenGreen700) Xpr()                        {}
func (x PenGreen700) PenPenXpr()                  {}
func (x PenGreen800) Xpr()                        {}
func (x PenGreen800) PenPenXpr()                  {}
func (x PenGreen900) Xpr()                        {}
func (x PenGreen900) PenPenXpr()                  {}
func (x PenGreenA100) Xpr()                       {}
func (x PenGreenA100) PenPenXpr()                 {}
func (x PenGreenA200) Xpr()                       {}
func (x PenGreenA200) PenPenXpr()                 {}
func (x PenGreenA400) Xpr()                       {}
func (x PenGreenA400) PenPenXpr()                 {}
func (x PenGreenA700) Xpr()                       {}
func (x PenGreenA700) PenPenXpr()                 {}
func (x PenLightGreen50) Xpr()                    {}
func (x PenLightGreen50) PenPenXpr()              {}
func (x PenLightGreen100) Xpr()                   {}
func (x PenLightGreen100) PenPenXpr()             {}
func (x PenLightGreen200) Xpr()                   {}
func (x PenLightGreen200) PenPenXpr()             {}
func (x PenLightGreen300) Xpr()                   {}
func (x PenLightGreen300) PenPenXpr()             {}
func (x PenLightGreen400) Xpr()                   {}
func (x PenLightGreen400) PenPenXpr()             {}
func (x PenLightGreen500) Xpr()                   {}
func (x PenLightGreen500) PenPenXpr()             {}
func (x PenLightGreen600) Xpr()                   {}
func (x PenLightGreen600) PenPenXpr()             {}
func (x PenLightGreen700) Xpr()                   {}
func (x PenLightGreen700) PenPenXpr()             {}
func (x PenLightGreen800) Xpr()                   {}
func (x PenLightGreen800) PenPenXpr()             {}
func (x PenLightGreen900) Xpr()                   {}
func (x PenLightGreen900) PenPenXpr()             {}
func (x PenLightGreenA100) Xpr()                  {}
func (x PenLightGreenA100) PenPenXpr()            {}
func (x PenLightGreenA200) Xpr()                  {}
func (x PenLightGreenA200) PenPenXpr()            {}
func (x PenLightGreenA400) Xpr()                  {}
func (x PenLightGreenA400) PenPenXpr()            {}
func (x PenLightGreenA700) Xpr()                  {}
func (x PenLightGreenA700) PenPenXpr()            {}
func (x PenLime50) Xpr()                          {}
func (x PenLime50) PenPenXpr()                    {}
func (x PenLime100) Xpr()                         {}
func (x PenLime100) PenPenXpr()                   {}
func (x PenLime200) Xpr()                         {}
func (x PenLime200) PenPenXpr()                   {}
func (x PenLime300) Xpr()                         {}
func (x PenLime300) PenPenXpr()                   {}
func (x PenLime400) Xpr()                         {}
func (x PenLime400) PenPenXpr()                   {}
func (x PenLime500) Xpr()                         {}
func (x PenLime500) PenPenXpr()                   {}
func (x PenLime600) Xpr()                         {}
func (x PenLime600) PenPenXpr()                   {}
func (x PenLime700) Xpr()                         {}
func (x PenLime700) PenPenXpr()                   {}
func (x PenLime800) Xpr()                         {}
func (x PenLime800) PenPenXpr()                   {}
func (x PenLime900) Xpr()                         {}
func (x PenLime900) PenPenXpr()                   {}
func (x PenLimeA100) Xpr()                        {}
func (x PenLimeA100) PenPenXpr()                  {}
func (x PenLimeA200) Xpr()                        {}
func (x PenLimeA200) PenPenXpr()                  {}
func (x PenLimeA400) Xpr()                        {}
func (x PenLimeA400) PenPenXpr()                  {}
func (x PenLimeA700) Xpr()                        {}
func (x PenLimeA700) PenPenXpr()                  {}
func (x PenYellow50) Xpr()                        {}
func (x PenYellow50) PenPenXpr()                  {}
func (x PenYellow100) Xpr()                       {}
func (x PenYellow100) PenPenXpr()                 {}
func (x PenYellow200) Xpr()                       {}
func (x PenYellow200) PenPenXpr()                 {}
func (x PenYellow300) Xpr()                       {}
func (x PenYellow300) PenPenXpr()                 {}
func (x PenYellow400) Xpr()                       {}
func (x PenYellow400) PenPenXpr()                 {}
func (x PenYellow500) Xpr()                       {}
func (x PenYellow500) PenPenXpr()                 {}
func (x PenYellow600) Xpr()                       {}
func (x PenYellow600) PenPenXpr()                 {}
func (x PenYellow700) Xpr()                       {}
func (x PenYellow700) PenPenXpr()                 {}
func (x PenYellow800) Xpr()                       {}
func (x PenYellow800) PenPenXpr()                 {}
func (x PenYellow900) Xpr()                       {}
func (x PenYellow900) PenPenXpr()                 {}
func (x PenYellowA100) Xpr()                      {}
func (x PenYellowA100) PenPenXpr()                {}
func (x PenYellowA200) Xpr()                      {}
func (x PenYellowA200) PenPenXpr()                {}
func (x PenYellowA400) Xpr()                      {}
func (x PenYellowA400) PenPenXpr()                {}
func (x PenYellowA700) Xpr()                      {}
func (x PenYellowA700) PenPenXpr()                {}
func (x PenAmber50) Xpr()                         {}
func (x PenAmber50) PenPenXpr()                   {}
func (x PenAmber100) Xpr()                        {}
func (x PenAmber100) PenPenXpr()                  {}
func (x PenAmber200) Xpr()                        {}
func (x PenAmber200) PenPenXpr()                  {}
func (x PenAmber300) Xpr()                        {}
func (x PenAmber300) PenPenXpr()                  {}
func (x PenAmber400) Xpr()                        {}
func (x PenAmber400) PenPenXpr()                  {}
func (x PenAmber500) Xpr()                        {}
func (x PenAmber500) PenPenXpr()                  {}
func (x PenAmber600) Xpr()                        {}
func (x PenAmber600) PenPenXpr()                  {}
func (x PenAmber700) Xpr()                        {}
func (x PenAmber700) PenPenXpr()                  {}
func (x PenAmber800) Xpr()                        {}
func (x PenAmber800) PenPenXpr()                  {}
func (x PenAmber900) Xpr()                        {}
func (x PenAmber900) PenPenXpr()                  {}
func (x PenAmberA100) Xpr()                       {}
func (x PenAmberA100) PenPenXpr()                 {}
func (x PenAmberA200) Xpr()                       {}
func (x PenAmberA200) PenPenXpr()                 {}
func (x PenAmberA400) Xpr()                       {}
func (x PenAmberA400) PenPenXpr()                 {}
func (x PenAmberA700) Xpr()                       {}
func (x PenAmberA700) PenPenXpr()                 {}
func (x PenOrange50) Xpr()                        {}
func (x PenOrange50) PenPenXpr()                  {}
func (x PenOrange100) Xpr()                       {}
func (x PenOrange100) PenPenXpr()                 {}
func (x PenOrange200) Xpr()                       {}
func (x PenOrange200) PenPenXpr()                 {}
func (x PenOrange300) Xpr()                       {}
func (x PenOrange300) PenPenXpr()                 {}
func (x PenOrange400) Xpr()                       {}
func (x PenOrange400) PenPenXpr()                 {}
func (x PenOrange500) Xpr()                       {}
func (x PenOrange500) PenPenXpr()                 {}
func (x PenOrange600) Xpr()                       {}
func (x PenOrange600) PenPenXpr()                 {}
func (x PenOrange700) Xpr()                       {}
func (x PenOrange700) PenPenXpr()                 {}
func (x PenOrange800) Xpr()                       {}
func (x PenOrange800) PenPenXpr()                 {}
func (x PenOrange900) Xpr()                       {}
func (x PenOrange900) PenPenXpr()                 {}
func (x PenOrangeA100) Xpr()                      {}
func (x PenOrangeA100) PenPenXpr()                {}
func (x PenOrangeA200) Xpr()                      {}
func (x PenOrangeA200) PenPenXpr()                {}
func (x PenOrangeA400) Xpr()                      {}
func (x PenOrangeA400) PenPenXpr()                {}
func (x PenOrangeA700) Xpr()                      {}
func (x PenOrangeA700) PenPenXpr()                {}
func (x PenDeepOrange50) Xpr()                    {}
func (x PenDeepOrange50) PenPenXpr()              {}
func (x PenDeepOrange100) Xpr()                   {}
func (x PenDeepOrange100) PenPenXpr()             {}
func (x PenDeepOrange200) Xpr()                   {}
func (x PenDeepOrange200) PenPenXpr()             {}
func (x PenDeepOrange300) Xpr()                   {}
func (x PenDeepOrange300) PenPenXpr()             {}
func (x PenDeepOrange400) Xpr()                   {}
func (x PenDeepOrange400) PenPenXpr()             {}
func (x PenDeepOrange500) Xpr()                   {}
func (x PenDeepOrange500) PenPenXpr()             {}
func (x PenDeepOrange600) Xpr()                   {}
func (x PenDeepOrange600) PenPenXpr()             {}
func (x PenDeepOrange700) Xpr()                   {}
func (x PenDeepOrange700) PenPenXpr()             {}
func (x PenDeepOrange800) Xpr()                   {}
func (x PenDeepOrange800) PenPenXpr()             {}
func (x PenDeepOrange900) Xpr()                   {}
func (x PenDeepOrange900) PenPenXpr()             {}
func (x PenDeepOrangeA100) Xpr()                  {}
func (x PenDeepOrangeA100) PenPenXpr()            {}
func (x PenDeepOrangeA200) Xpr()                  {}
func (x PenDeepOrangeA200) PenPenXpr()            {}
func (x PenDeepOrangeA400) Xpr()                  {}
func (x PenDeepOrangeA400) PenPenXpr()            {}
func (x PenDeepOrangeA700) Xpr()                  {}
func (x PenDeepOrangeA700) PenPenXpr()            {}
func (x PenBrown50) Xpr()                         {}
func (x PenBrown50) PenPenXpr()                   {}
func (x PenBrown100) Xpr()                        {}
func (x PenBrown100) PenPenXpr()                  {}
func (x PenBrown200) Xpr()                        {}
func (x PenBrown200) PenPenXpr()                  {}
func (x PenBrown300) Xpr()                        {}
func (x PenBrown300) PenPenXpr()                  {}
func (x PenBrown400) Xpr()                        {}
func (x PenBrown400) PenPenXpr()                  {}
func (x PenBrown500) Xpr()                        {}
func (x PenBrown500) PenPenXpr()                  {}
func (x PenBrown600) Xpr()                        {}
func (x PenBrown600) PenPenXpr()                  {}
func (x PenBrown700) Xpr()                        {}
func (x PenBrown700) PenPenXpr()                  {}
func (x PenBrown800) Xpr()                        {}
func (x PenBrown800) PenPenXpr()                  {}
func (x PenBrown900) Xpr()                        {}
func (x PenBrown900) PenPenXpr()                  {}
func (x PenBlueGrey50) Xpr()                      {}
func (x PenBlueGrey50) PenPenXpr()                {}
func (x PenBlueGrey100) Xpr()                     {}
func (x PenBlueGrey100) PenPenXpr()               {}
func (x PenBlueGrey200) Xpr()                     {}
func (x PenBlueGrey200) PenPenXpr()               {}
func (x PenBlueGrey300) Xpr()                     {}
func (x PenBlueGrey300) PenPenXpr()               {}
func (x PenBlueGrey400) Xpr()                     {}
func (x PenBlueGrey400) PenPenXpr()               {}
func (x PenBlueGrey500) Xpr()                     {}
func (x PenBlueGrey500) PenPenXpr()               {}
func (x PenBlueGrey600) Xpr()                     {}
func (x PenBlueGrey600) PenPenXpr()               {}
func (x PenBlueGrey700) Xpr()                     {}
func (x PenBlueGrey700) PenPenXpr()               {}
func (x PenBlueGrey800) Xpr()                     {}
func (x PenBlueGrey800) PenPenXpr()               {}
func (x PenBlueGrey900) Xpr()                     {}
func (x PenBlueGrey900) PenPenXpr()               {}
func (x PenGrey50) Xpr()                          {}
func (x PenGrey50) PenPenXpr()                    {}
func (x PenGrey100) Xpr()                         {}
func (x PenGrey100) PenPenXpr()                   {}
func (x PenGrey200) Xpr()                         {}
func (x PenGrey200) PenPenXpr()                   {}
func (x PenGrey300) Xpr()                         {}
func (x PenGrey300) PenPenXpr()                   {}
func (x PenGrey400) Xpr()                         {}
func (x PenGrey400) PenPenXpr()                   {}
func (x PenGrey500) Xpr()                         {}
func (x PenGrey500) PenPenXpr()                   {}
func (x PenGrey600) Xpr()                         {}
func (x PenGrey600) PenPenXpr()                   {}
func (x PenGrey700) Xpr()                         {}
func (x PenGrey700) PenPenXpr()                   {}
func (x PenGrey800) Xpr()                         {}
func (x PenGrey800) PenPenXpr()                   {}
func (x PenGrey900) Xpr()                         {}
func (x PenGrey900) PenPenXpr()                   {}
func (x FltScl) Xpr()                             {}
func (x FltScl) FltFltXpr()                       {}
func (x UntStkWidth) Xpr()                        {}
func (x UntStkWidth) UntUntXpr()                  {}
func (x UntShpRadius) Xpr()                       {}
func (x UntShpRadius) UntUntXpr()                 {}
func (x UntAxisPad) Xpr()                         {}
func (x UntAxisPad) UntUntXpr()                   {}
func (x UntBarPad) Xpr()                          {}
func (x UntBarPad) UntUntXpr()                    {}
func (x UntLen) Xpr()                             {}
func (x UntLen) UntUntXpr()                       {}
func (x UntPad) Xpr()                             {}
func (x UntPad) UntUntXpr()                       {}
func (x ClrBakClr) Xpr()                          {}
func (x ClrBakClr) ClrClrXpr()                    {}
func (x ClrBrdrClr) Xpr()                         {}
func (x ClrBrdrClr) ClrClrXpr()                   {}
func (x UntBrdrLen) Xpr()                         {}
func (x UntBrdrLen) UntUntXpr()                   {}
func (x UntInrvlTxtLen) Xpr()                     {}
func (x UntInrvlTxtLen) UntUntXpr()               {}
func (x ClrInrvlTxtClrX) Xpr()                    {}
func (x ClrInrvlTxtClrX) ClrClrXpr()              {}
func (x ClrInrvlTxtClrY) Xpr()                    {}
func (x ClrInrvlTxtClrY) ClrClrXpr()              {}
func (x ClrMsgClr) Xpr()                          {}
func (x ClrMsgClr) ClrClrXpr()                    {}
func (x ClrTitleClr) Xpr()                        {}
func (x ClrTitleClr) ClrClrXpr()                  {}
func (x ClrPrfClr) Xpr()                          {}
func (x ClrPrfClr) ClrClrXpr()                    {}
func (x ClrLosClr) Xpr()                          {}
func (x ClrLosClr) ClrClrXpr()                    {}
func (x PenPrfPen) Xpr()                          {}
func (x PenPrfPen) PenPenXpr()                    {}
func (x PenLosPen) Xpr()                          {}
func (x PenLosPen) PenPenXpr()                    {}
func (x FltOutlierLim) Xpr()                      {}
func (x FltOutlierLim) FltFltXpr()                {}
func (x LogIfo) Xpr()                             {}
func (x LogIfo) StrStrXpr()                       {}
func (x LogIfof) Xpr()                            {}
func (x LogIfof) StrStrXpr()                      {}
func (x StrFmt) Xpr()                             {}
func (x StrFmt) StrStrXpr()                       {}
func (x TmeNow) Xpr()                             {}
func (x TmeNow) TmeTmeXpr()                       {}
func (x FltNewRng) Xpr()                          {}
func (x FltNewRng) FltRngXpr()                    {}
func (x FltNewRngArnd) Xpr()                      {}
func (x FltNewRngArnd) FltRngXpr()                {}
func (x FltNewRngFul) Xpr()                       {}
func (x FltNewRngFul) FltRngXpr()                 {}
func (x TmeNewRng) Xpr()                          {}
func (x TmeNewRng) TmeRngXpr()                    {}
func (x TmeNewRngArnd) Xpr()                      {}
func (x TmeNewRngArnd) TmeRngXpr()                {}
func (x TmeNewRngFul) Xpr()                       {}
func (x TmeNewRngFul) TmeRngXpr()                 {}
func (x StrsNew) Xpr()                            {}
func (x StrsNew) StrsStrsXpr()                    {}
func (x StrsMake) Xpr()                           {}
func (x StrsMake) StrsStrsXpr()                   {}
func (x StrsMakeEmp) Xpr()                        {}
func (x StrsMakeEmp) StrsStrsXpr()                {}
func (x BolsNew) Xpr()                            {}
func (x BolsNew) BolsBolsXpr()                    {}
func (x BolsMake) Xpr()                           {}
func (x BolsMake) BolsBolsXpr()                   {}
func (x BolsMakeEmp) Xpr()                        {}
func (x BolsMakeEmp) BolsBolsXpr()                {}
func (x FltsNew) Xpr()                            {}
func (x FltsNew) FltsFltsXpr()                    {}
func (x FltsMake) Xpr()                           {}
func (x FltsMake) FltsFltsXpr()                   {}
func (x FltsMakeEmp) Xpr()                        {}
func (x FltsMakeEmp) FltsFltsXpr()                {}
func (x FltsAddsLss) Xpr()                        {}
func (x FltsAddsLss) FltsFltsXpr()                {}
func (x FltsAddsLeq) Xpr()                        {}
func (x FltsAddsLeq) FltsFltsXpr()                {}
func (x FltsSubsGtr) Xpr()                        {}
func (x FltsSubsGtr) FltsFltsXpr()                {}
func (x FltsSubsGeq) Xpr()                        {}
func (x FltsSubsGeq) FltsFltsXpr()                {}
func (x FltsMulsLss) Xpr()                        {}
func (x FltsMulsLss) FltsFltsXpr()                {}
func (x FltsMulsLeq) Xpr()                        {}
func (x FltsMulsLeq) FltsFltsXpr()                {}
func (x FltsDivsGtr) Xpr()                        {}
func (x FltsDivsGtr) FltsFltsXpr()                {}
func (x FltsDivsGeq) Xpr()                        {}
func (x FltsDivsGeq) FltsFltsXpr()                {}
func (x FltsFibsLeq) Xpr()                        {}
func (x FltsFibsLeq) FltsFltsXpr()                {}
func (x UntsNew) Xpr()                            {}
func (x UntsNew) UntsUntsXpr()                    {}
func (x UntsMake) Xpr()                           {}
func (x UntsMake) UntsUntsXpr()                   {}
func (x UntsMakeEmp) Xpr()                        {}
func (x UntsMakeEmp) UntsUntsXpr()                {}
func (x UntsAddsLss) Xpr()                        {}
func (x UntsAddsLss) UntsUntsXpr()                {}
func (x UntsAddsLeq) Xpr()                        {}
func (x UntsAddsLeq) UntsUntsXpr()                {}
func (x UntsSubsGtr) Xpr()                        {}
func (x UntsSubsGtr) UntsUntsXpr()                {}
func (x UntsSubsGeq) Xpr()                        {}
func (x UntsSubsGeq) UntsUntsXpr()                {}
func (x UntsMulsLss) Xpr()                        {}
func (x UntsMulsLss) UntsUntsXpr()                {}
func (x UntsMulsLeq) Xpr()                        {}
func (x UntsMulsLeq) UntsUntsXpr()                {}
func (x UntsDivsGtr) Xpr()                        {}
func (x UntsDivsGtr) UntsUntsXpr()                {}
func (x UntsDivsGeq) Xpr()                        {}
func (x UntsDivsGeq) UntsUntsXpr()                {}
func (x UntsFibsLeq) Xpr()                        {}
func (x UntsFibsLeq) UntsUntsXpr()                {}
func (x IntsNew) Xpr()                            {}
func (x IntsNew) IntsIntsXpr()                    {}
func (x IntsMake) Xpr()                           {}
func (x IntsMake) IntsIntsXpr()                   {}
func (x IntsMakeEmp) Xpr()                        {}
func (x IntsMakeEmp) IntsIntsXpr()                {}
func (x TmesNew) Xpr()                            {}
func (x TmesNew) TmesTmesXpr()                    {}
func (x TmesMake) Xpr()                           {}
func (x TmesMake) TmesTmesXpr()                   {}
func (x TmesMakeEmp) Xpr()                        {}
func (x TmesMakeEmp) TmesTmesXpr()                {}
func (x TmesAddsLss) Xpr()                        {}
func (x TmesAddsLss) TmesTmesXpr()                {}
func (x TmesAddsLeq) Xpr()                        {}
func (x TmesAddsLeq) TmesTmesXpr()                {}
func (x TmesSubsGtr) Xpr()                        {}
func (x TmesSubsGtr) TmesTmesXpr()                {}
func (x TmesSubsGeq) Xpr()                        {}
func (x TmesSubsGeq) TmesTmesXpr()                {}
func (x TmesMulsLss) Xpr()                        {}
func (x TmesMulsLss) TmesTmesXpr()                {}
func (x TmesMulsLeq) Xpr()                        {}
func (x TmesMulsLeq) TmesTmesXpr()                {}
func (x TmesDivsGtr) Xpr()                        {}
func (x TmesDivsGtr) TmesTmesXpr()                {}
func (x TmesDivsGeq) Xpr()                        {}
func (x TmesDivsGeq) TmesTmesXpr()                {}
func (x TmesFibsLeq) Xpr()                        {}
func (x TmesFibsLeq) TmesTmesXpr()                {}
func (x BndsNew) Xpr()                            {}
func (x BndsNew) BndsBndsXpr()                    {}
func (x BndsMake) Xpr()                           {}
func (x BndsMake) BndsBndsXpr()                   {}
func (x BndsMakeEmp) Xpr()                        {}
func (x BndsMakeEmp) BndsBndsXpr()                {}
func (x TmeNewRngs) Xpr()                         {}
func (x TmeNewRngs) TmeRngsXpr()                  {}
func (x TmeMakeRngs) Xpr()                        {}
func (x TmeMakeRngs) TmeRngsXpr()                 {}
func (x TmeMakeEmpRngs) Xpr()                     {}
func (x TmeMakeEmpRngs) TmeRngsXpr()              {}
func (x AnaNewTrds) Xpr()                         {}
func (x AnaNewTrds) AnaTrdsXpr()                  {}
func (x AnaMakeTrds) Xpr()                        {}
func (x AnaMakeTrds) AnaTrdsXpr()                 {}
func (x AnaMakeEmpTrds) Xpr()                     {}
func (x AnaMakeEmpTrds) AnaTrdsXpr()              {}
func (x AnaNewPrfms) Xpr()                        {}
func (x AnaNewPrfms) AnaPrfmsXpr()                {}
func (x AnaMakePrfms) Xpr()                       {}
func (x AnaMakePrfms) AnaPrfmsXpr()               {}
func (x AnaMakeEmpPrfms) Xpr()                    {}
func (x AnaMakeEmpPrfms) AnaPrfmsXpr()            {}
func (x HstOan) Xpr()                             {}
func (x HstOan) HstPrvXpr()                       {}
func (x HstNewPrvs) Xpr()                         {}
func (x HstNewPrvs) HstPrvsXpr()                  {}
func (x HstMakePrvs) Xpr()                        {}
func (x HstMakePrvs) HstPrvsXpr()                 {}
func (x HstMakeEmpPrvs) Xpr()                     {}
func (x HstMakeEmpPrvs) HstPrvsXpr()              {}
func (x HstNewInstrs) Xpr()                       {}
func (x HstNewInstrs) HstInstrsXpr()              {}
func (x HstMakeInstrs) Xpr()                      {}
func (x HstMakeInstrs) HstInstrsXpr()             {}
func (x HstMakeEmpInstrs) Xpr()                   {}
func (x HstMakeEmpInstrs) HstInstrsXpr()          {}
func (x HstNewInrvls) Xpr()                       {}
func (x HstNewInrvls) HstInrvlsXpr()              {}
func (x HstMakeInrvls) Xpr()                      {}
func (x HstMakeInrvls) HstInrvlsXpr()             {}
func (x HstMakeEmpInrvls) Xpr()                   {}
func (x HstMakeEmpInrvls) HstInrvlsXpr()          {}
func (x HstNewSides) Xpr()                        {}
func (x HstNewSides) HstSidesXpr()                {}
func (x HstMakeSides) Xpr()                       {}
func (x HstMakeSides) HstSidesXpr()               {}
func (x HstMakeEmpSides) Xpr()                    {}
func (x HstMakeEmpSides) HstSidesXpr()            {}
func (x HstNewStms) Xpr()                         {}
func (x HstNewStms) HstStmsXpr()                  {}
func (x HstMakeStms) Xpr()                        {}
func (x HstMakeStms) HstStmsXpr()                 {}
func (x HstMakeEmpStms) Xpr()                     {}
func (x HstMakeEmpStms) HstStmsXpr()              {}
func (x HstNewCnds) Xpr()                         {}
func (x HstNewCnds) HstCndsXpr()                  {}
func (x HstMakeCnds) Xpr()                        {}
func (x HstMakeCnds) HstCndsXpr()                 {}
func (x HstMakeEmpCnds) Xpr()                     {}
func (x HstMakeEmpCnds) HstCndsXpr()              {}
func (x HstNewStgys) Xpr()                        {}
func (x HstNewStgys) HstStgysXpr()                {}
func (x HstMakeStgys) Xpr()                       {}
func (x HstMakeStgys) HstStgysXpr()               {}
func (x HstMakeEmpStgys) Xpr()                    {}
func (x HstMakeEmpStgys) HstStgysXpr()            {}
func (x RltOan) Xpr()                             {}
func (x RltOan) RltPrvXpr()                       {}
func (x RltNewPrvs) Xpr()                         {}
func (x RltNewPrvs) RltPrvsXpr()                  {}
func (x RltMakePrvs) Xpr()                        {}
func (x RltMakePrvs) RltPrvsXpr()                 {}
func (x RltMakeEmpPrvs) Xpr()                     {}
func (x RltMakeEmpPrvs) RltPrvsXpr()              {}
func (x RltNewInstrs) Xpr()                       {}
func (x RltNewInstrs) RltInstrsXpr()              {}
func (x RltMakeInstrs) Xpr()                      {}
func (x RltMakeInstrs) RltInstrsXpr()             {}
func (x RltMakeEmpInstrs) Xpr()                   {}
func (x RltMakeEmpInstrs) RltInstrsXpr()          {}
func (x RltNewInrvls) Xpr()                       {}
func (x RltNewInrvls) RltInrvlsXpr()              {}
func (x RltMakeInrvls) Xpr()                      {}
func (x RltMakeInrvls) RltInrvlsXpr()             {}
func (x RltMakeEmpInrvls) Xpr()                   {}
func (x RltMakeEmpInrvls) RltInrvlsXpr()          {}
func (x RltNewSides) Xpr()                        {}
func (x RltNewSides) RltSidesXpr()                {}
func (x RltMakeSides) Xpr()                       {}
func (x RltMakeSides) RltSidesXpr()               {}
func (x RltMakeEmpSides) Xpr()                    {}
func (x RltMakeEmpSides) RltSidesXpr()            {}
func (x RltNewStms) Xpr()                         {}
func (x RltNewStms) RltStmsXpr()                  {}
func (x RltMakeStms) Xpr()                        {}
func (x RltMakeStms) RltStmsXpr()                 {}
func (x RltMakeEmpStms) Xpr()                     {}
func (x RltMakeEmpStms) RltStmsXpr()              {}
func (x RltNewCnds) Xpr()                         {}
func (x RltNewCnds) RltCndsXpr()                  {}
func (x RltMakeCnds) Xpr()                        {}
func (x RltMakeCnds) RltCndsXpr()                 {}
func (x RltMakeEmpCnds) Xpr()                     {}
func (x RltMakeEmpCnds) RltCndsXpr()              {}
func (x RltNewStgys) Xpr()                        {}
func (x RltNewStgys) RltStgysXpr()                {}
func (x RltMakeStgys) Xpr()                       {}
func (x RltMakeStgys) RltStgysXpr()               {}
func (x RltMakeEmpStgys) Xpr()                    {}
func (x RltMakeEmpStgys) RltStgysXpr()            {}
func (x ClrRgba) Xpr()                            {}
func (x ClrRgba) ClrClrXpr()                      {}
func (x ClrRgb) Xpr()                             {}
func (x ClrRgb) ClrClrXpr()                       {}
func (x ClrHex) Xpr()                             {}
func (x ClrHex) ClrClrXpr()                       {}
func (x PenNew) Xpr()                             {}
func (x PenNew) PenPenXpr()                       {}
func (x PenRgba) Xpr()                            {}
func (x PenRgba) PenPenXpr()                      {}
func (x PenRgb) Xpr()                             {}
func (x PenRgb) PenPenXpr()                       {}
func (x PenHex) Xpr()                             {}
func (x PenHex) PenPenXpr()                       {}
func (x PenNewPens) Xpr()                         {}
func (x PenNewPens) PenPensXpr()                  {}
func (x PenMakePens) Xpr()                        {}
func (x PenMakePens) PenPensXpr()                 {}
func (x PenMakeEmpPens) Xpr()                     {}
func (x PenMakeEmpPens) PenPensXpr()              {}
func (x PltNewPlts) Xpr()                         {}
func (x PltNewPlts) PltPltsXpr()                  {}
func (x PltMakePlts) Xpr()                        {}
func (x PltMakePlts) PltPltsXpr()                 {}
func (x PltMakeEmpPlts) Xpr()                     {}
func (x PltMakeEmpPlts) PltPltsXpr()              {}
func (x PltNewStm) Xpr()                          {}
func (x PltNewStm) PltStmXpr()                    {}
func (x PltNewStm) PltPltXpr()                    {}
func (x PltNewFltsSctr) Xpr()                     {}
func (x PltNewFltsSctr) PltFltsSctrXpr()          {}
func (x PltNewFltsSctr) PltPltXpr()               {}
func (x PltNewFltsSctrDist) Xpr()                 {}
func (x PltNewFltsSctrDist) PltFltsSctrDistXpr()  {}
func (x PltNewFltsSctrDist) PltPltXpr()           {}
func (x PltNewHrz) Xpr()                          {}
func (x PltNewHrz) PltHrzXpr()                    {}
func (x PltNewHrz) PltPltXpr()                    {}
func (x PltNewVrt) Xpr()                          {}
func (x PltNewVrt) PltVrtXpr()                    {}
func (x PltNewVrt) PltPltXpr()                    {}
func (x PltNewDpth) Xpr()                         {}
func (x PltNewDpth) PltDpthXpr()                  {}
func (x PltNewDpth) PltPltXpr()                   {}
func (x SysNewMu) Xpr()                           {}
func (x SysNewMu) SysMuXpr()                      {}
func (x StrStrLower) Xpr()                        {}
func (x StrStrLower) StrStrXpr()                  {}
func (x StrStrUpper) Xpr()                        {}
func (x StrStrUpper) StrStrXpr()                  {}
func (x StrStrEql) Xpr()                          {}
func (x StrStrEql) BolBolXpr()                    {}
func (x StrStrNeq) Xpr()                          {}
func (x StrStrNeq) BolBolXpr()                    {}
func (x StrStrLss) Xpr()                          {}
func (x StrStrLss) BolBolXpr()                    {}
func (x StrStrGtr) Xpr()                          {}
func (x StrStrGtr) BolBolXpr()                    {}
func (x StrStrLeq) Xpr()                          {}
func (x StrStrLeq) BolBolXpr()                    {}
func (x StrStrGeq) Xpr()                          {}
func (x StrStrGeq) BolBolXpr()                    {}
func (x BolBolNot) Xpr()                          {}
func (x BolBolNot) BolBolXpr()                    {}
func (x BolBolEql) Xpr()                          {}
func (x BolBolEql) BolBolXpr()                    {}
func (x BolBolNeq) Xpr()                          {}
func (x BolBolNeq) BolBolXpr()                    {}
func (x FltFltEql) Xpr()                          {}
func (x FltFltEql) BolBolXpr()                    {}
func (x FltFltNeq) Xpr()                          {}
func (x FltFltNeq) BolBolXpr()                    {}
func (x FltFltTrnc) Xpr()                         {}
func (x FltFltTrnc) FltFltXpr()                   {}
func (x FltFltIsNaN) Xpr()                        {}
func (x FltFltIsNaN) BolBolXpr()                  {}
func (x FltFltIsInfPos) Xpr()                     {}
func (x FltFltIsInfPos) BolBolXpr()               {}
func (x FltFltIsInfNeg) Xpr()                     {}
func (x FltFltIsInfNeg) BolBolXpr()               {}
func (x FltFltIsValid) Xpr()                      {}
func (x FltFltIsValid) BolBolXpr()                {}
func (x FltFltPct) Xpr()                          {}
func (x FltFltPct) FltFltXpr()                    {}
func (x FltFltLss) Xpr()                          {}
func (x FltFltLss) BolBolXpr()                    {}
func (x FltFltGtr) Xpr()                          {}
func (x FltFltGtr) BolBolXpr()                    {}
func (x FltFltLeq) Xpr()                          {}
func (x FltFltLeq) BolBolXpr()                    {}
func (x FltFltGeq) Xpr()                          {}
func (x FltFltGeq) BolBolXpr()                    {}
func (x FltFltPos) Xpr()                          {}
func (x FltFltPos) FltFltXpr()                    {}
func (x FltFltNeg) Xpr()                          {}
func (x FltFltNeg) FltFltXpr()                    {}
func (x FltFltInv) Xpr()                          {}
func (x FltFltInv) FltFltXpr()                    {}
func (x FltFltAdd) Xpr()                          {}
func (x FltFltAdd) FltFltXpr()                    {}
func (x FltFltSub) Xpr()                          {}
func (x FltFltSub) FltFltXpr()                    {}
func (x FltFltMul) Xpr()                          {}
func (x FltFltMul) FltFltXpr()                    {}
func (x FltFltDiv) Xpr()                          {}
func (x FltFltDiv) FltFltXpr()                    {}
func (x FltFltRem) Xpr()                          {}
func (x FltFltRem) FltFltXpr()                    {}
func (x FltFltPow) Xpr()                          {}
func (x FltFltPow) FltFltXpr()                    {}
func (x FltFltSqr) Xpr()                          {}
func (x FltFltSqr) FltFltXpr()                    {}
func (x FltFltSqrt) Xpr()                         {}
func (x FltFltSqrt) FltFltXpr()                   {}
func (x FltFltMin) Xpr()                          {}
func (x FltFltMin) FltFltXpr()                    {}
func (x FltFltMax) Xpr()                          {}
func (x FltFltMax) FltFltXpr()                    {}
func (x FltFltMid) Xpr()                          {}
func (x FltFltMid) FltFltXpr()                    {}
func (x FltFltAvg) Xpr()                          {}
func (x FltFltAvg) FltFltXpr()                    {}
func (x FltFltAvgGeo) Xpr()                       {}
func (x FltFltAvgGeo) FltFltXpr()                 {}
func (x FltFltSelEql) Xpr()                       {}
func (x FltFltSelEql) FltFltXpr()                 {}
func (x FltFltSelNeq) Xpr()                       {}
func (x FltFltSelNeq) FltFltXpr()                 {}
func (x FltFltSelLss) Xpr()                       {}
func (x FltFltSelLss) FltFltXpr()                 {}
func (x FltFltSelGtr) Xpr()                       {}
func (x FltFltSelGtr) FltFltXpr()                 {}
func (x FltFltSelLeq) Xpr()                       {}
func (x FltFltSelLeq) FltFltXpr()                 {}
func (x FltFltSelGeq) Xpr()                       {}
func (x FltFltSelGeq) FltFltXpr()                 {}
func (x UntUntEql) Xpr()                          {}
func (x UntUntEql) BolBolXpr()                    {}
func (x UntUntNeq) Xpr()                          {}
func (x UntUntNeq) BolBolXpr()                    {}
func (x UntUntLss) Xpr()                          {}
func (x UntUntLss) BolBolXpr()                    {}
func (x UntUntGtr) Xpr()                          {}
func (x UntUntGtr) BolBolXpr()                    {}
func (x UntUntLeq) Xpr()                          {}
func (x UntUntLeq) BolBolXpr()                    {}
func (x UntUntGeq) Xpr()                          {}
func (x UntUntGeq) BolBolXpr()                    {}
func (x UntUntAdd) Xpr()                          {}
func (x UntUntAdd) UntUntXpr()                    {}
func (x UntUntSub) Xpr()                          {}
func (x UntUntSub) UntUntXpr()                    {}
func (x UntUntMul) Xpr()                          {}
func (x UntUntMul) UntUntXpr()                    {}
func (x UntUntDiv) Xpr()                          {}
func (x UntUntDiv) UntUntXpr()                    {}
func (x UntUntRem) Xpr()                          {}
func (x UntUntRem) UntUntXpr()                    {}
func (x UntUntPow) Xpr()                          {}
func (x UntUntPow) UntUntXpr()                    {}
func (x UntUntSqr) Xpr()                          {}
func (x UntUntSqr) UntUntXpr()                    {}
func (x UntUntSqrt) Xpr()                         {}
func (x UntUntSqrt) UntUntXpr()                   {}
func (x UntUntMin) Xpr()                          {}
func (x UntUntMin) UntUntXpr()                    {}
func (x UntUntMax) Xpr()                          {}
func (x UntUntMax) UntUntXpr()                    {}
func (x UntUntMid) Xpr()                          {}
func (x UntUntMid) UntUntXpr()                    {}
func (x UntUntAvg) Xpr()                          {}
func (x UntUntAvg) UntUntXpr()                    {}
func (x UntUntAvgGeo) Xpr()                       {}
func (x UntUntAvgGeo) UntUntXpr()                 {}
func (x IntIntEql) Xpr()                          {}
func (x IntIntEql) BolBolXpr()                    {}
func (x IntIntNeq) Xpr()                          {}
func (x IntIntNeq) BolBolXpr()                    {}
func (x IntIntLss) Xpr()                          {}
func (x IntIntLss) BolBolXpr()                    {}
func (x IntIntGtr) Xpr()                          {}
func (x IntIntGtr) BolBolXpr()                    {}
func (x IntIntLeq) Xpr()                          {}
func (x IntIntLeq) BolBolXpr()                    {}
func (x IntIntGeq) Xpr()                          {}
func (x IntIntGeq) BolBolXpr()                    {}
func (x IntIntPos) Xpr()                          {}
func (x IntIntPos) IntIntXpr()                    {}
func (x IntIntNeg) Xpr()                          {}
func (x IntIntNeg) IntIntXpr()                    {}
func (x IntIntInv) Xpr()                          {}
func (x IntIntInv) IntIntXpr()                    {}
func (x IntIntAdd) Xpr()                          {}
func (x IntIntAdd) IntIntXpr()                    {}
func (x IntIntSub) Xpr()                          {}
func (x IntIntSub) IntIntXpr()                    {}
func (x IntIntMul) Xpr()                          {}
func (x IntIntMul) IntIntXpr()                    {}
func (x IntIntDiv) Xpr()                          {}
func (x IntIntDiv) IntIntXpr()                    {}
func (x IntIntRem) Xpr()                          {}
func (x IntIntRem) IntIntXpr()                    {}
func (x IntIntPow) Xpr()                          {}
func (x IntIntPow) IntIntXpr()                    {}
func (x IntIntSqr) Xpr()                          {}
func (x IntIntSqr) IntIntXpr()                    {}
func (x IntIntSqrt) Xpr()                         {}
func (x IntIntSqrt) IntIntXpr()                   {}
func (x IntIntMin) Xpr()                          {}
func (x IntIntMin) IntIntXpr()                    {}
func (x IntIntMax) Xpr()                          {}
func (x IntIntMax) IntIntXpr()                    {}
func (x IntIntMid) Xpr()                          {}
func (x IntIntMid) IntIntXpr()                    {}
func (x IntIntAvg) Xpr()                          {}
func (x IntIntAvg) IntIntXpr()                    {}
func (x IntIntAvgGeo) Xpr()                       {}
func (x IntIntAvgGeo) IntIntXpr()                 {}
func (x TmeTmeWeekdayCnt) Xpr()                   {}
func (x TmeTmeWeekdayCnt) UntUntXpr()             {}
func (x TmeTmeDte) Xpr()                          {}
func (x TmeTmeDte) TmeTmeXpr()                    {}
func (x TmeTmeToSunday) Xpr()                     {}
func (x TmeTmeToSunday) TmeTmeXpr()               {}
func (x TmeTmeToMonday) Xpr()                     {}
func (x TmeTmeToMonday) TmeTmeXpr()               {}
func (x TmeTmeToTuesday) Xpr()                    {}
func (x TmeTmeToTuesday) TmeTmeXpr()              {}
func (x TmeTmeToWednesday) Xpr()                  {}
func (x TmeTmeToWednesday) TmeTmeXpr()            {}
func (x TmeTmeToThursday) Xpr()                   {}
func (x TmeTmeToThursday) TmeTmeXpr()             {}
func (x TmeTmeToFriday) Xpr()                     {}
func (x TmeTmeToFriday) TmeTmeXpr()               {}
func (x TmeTmeToSaturday) Xpr()                   {}
func (x TmeTmeToSaturday) TmeTmeXpr()             {}
func (x TmeTmeIsSunday) Xpr()                     {}
func (x TmeTmeIsSunday) BolBolXpr()               {}
func (x TmeTmeIsMonday) Xpr()                     {}
func (x TmeTmeIsMonday) BolBolXpr()               {}
func (x TmeTmeIsTuesday) Xpr()                    {}
func (x TmeTmeIsTuesday) BolBolXpr()              {}
func (x TmeTmeIsWednesday) Xpr()                  {}
func (x TmeTmeIsWednesday) BolBolXpr()            {}
func (x TmeTmeIsThursday) Xpr()                   {}
func (x TmeTmeIsThursday) BolBolXpr()             {}
func (x TmeTmeIsFriday) Xpr()                     {}
func (x TmeTmeIsFriday) BolBolXpr()               {}
func (x TmeTmeIsSaturday) Xpr()                   {}
func (x TmeTmeIsSaturday) BolBolXpr()             {}
func (x TmeTmeEql) Xpr()                          {}
func (x TmeTmeEql) BolBolXpr()                    {}
func (x TmeTmeNeq) Xpr()                          {}
func (x TmeTmeNeq) BolBolXpr()                    {}
func (x TmeTmeLss) Xpr()                          {}
func (x TmeTmeLss) BolBolXpr()                    {}
func (x TmeTmeGtr) Xpr()                          {}
func (x TmeTmeGtr) BolBolXpr()                    {}
func (x TmeTmeLeq) Xpr()                          {}
func (x TmeTmeLeq) BolBolXpr()                    {}
func (x TmeTmeGeq) Xpr()                          {}
func (x TmeTmeGeq) BolBolXpr()                    {}
func (x TmeTmePos) Xpr()                          {}
func (x TmeTmePos) TmeTmeXpr()                    {}
func (x TmeTmeNeg) Xpr()                          {}
func (x TmeTmeNeg) TmeTmeXpr()                    {}
func (x TmeTmeInv) Xpr()                          {}
func (x TmeTmeInv) TmeTmeXpr()                    {}
func (x TmeTmeAdd) Xpr()                          {}
func (x TmeTmeAdd) TmeTmeXpr()                    {}
func (x TmeTmeSub) Xpr()                          {}
func (x TmeTmeSub) TmeTmeXpr()                    {}
func (x TmeTmeMul) Xpr()                          {}
func (x TmeTmeMul) TmeTmeXpr()                    {}
func (x TmeTmeDiv) Xpr()                          {}
func (x TmeTmeDiv) TmeTmeXpr()                    {}
func (x TmeTmeRem) Xpr()                          {}
func (x TmeTmeRem) TmeTmeXpr()                    {}
func (x TmeTmePow) Xpr()                          {}
func (x TmeTmePow) TmeTmeXpr()                    {}
func (x TmeTmeSqr) Xpr()                          {}
func (x TmeTmeSqr) TmeTmeXpr()                    {}
func (x TmeTmeSqrt) Xpr()                         {}
func (x TmeTmeSqrt) TmeTmeXpr()                   {}
func (x TmeTmeMin) Xpr()                          {}
func (x TmeTmeMin) TmeTmeXpr()                    {}
func (x TmeTmeMax) Xpr()                          {}
func (x TmeTmeMax) TmeTmeXpr()                    {}
func (x TmeTmeMid) Xpr()                          {}
func (x TmeTmeMid) TmeTmeXpr()                    {}
func (x TmeTmeAvg) Xpr()                          {}
func (x TmeTmeAvg) TmeTmeXpr()                    {}
func (x TmeTmeAvgGeo) Xpr()                       {}
func (x TmeTmeAvgGeo) TmeTmeXpr()                 {}
func (x BndBndCnt) Xpr()                          {}
func (x BndBndCnt) UntUntXpr()                    {}
func (x BndBndLen) Xpr()                          {}
func (x BndBndLen) UntUntXpr()                    {}
func (x BndBndLstIdx) Xpr()                       {}
func (x BndBndLstIdx) UntUntXpr()                 {}
func (x BndBndIsValid) Xpr()                      {}
func (x BndBndIsValid) BolBolXpr()                {}
func (x FltRngLen) Xpr()                          {}
func (x FltRngLen) FltFltXpr()                    {}
func (x FltRngIsValid) Xpr()                      {}
func (x FltRngIsValid) BolBolXpr()                {}
func (x FltRngEnsure) Xpr()                       {}
func (x FltRngEnsure) FltRngXpr()                 {}
func (x FltRngMinSub) Xpr()                       {}
func (x FltRngMinSub) FltRngXpr()                 {}
func (x FltRngMaxAdd) Xpr()                       {}
func (x FltRngMaxAdd) FltRngXpr()                 {}
func (x FltRngMrg) Xpr()                          {}
func (x FltRngMrg) FltRngXpr()                    {}
func (x TmeRngLen) Xpr()                          {}
func (x TmeRngLen) TmeTmeXpr()                    {}
func (x TmeRngIsValid) Xpr()                      {}
func (x TmeRngIsValid) BolBolXpr()                {}
func (x TmeRngEnsure) Xpr()                       {}
func (x TmeRngEnsure) TmeRngXpr()                 {}
func (x TmeRngMinSub) Xpr()                       {}
func (x TmeRngMinSub) TmeRngXpr()                 {}
func (x TmeRngMaxAdd) Xpr()                       {}
func (x TmeRngMaxAdd) TmeRngXpr()                 {}
func (x TmeRngMrg) Xpr()                          {}
func (x TmeRngMrg) TmeRngXpr()                    {}
func (x StrsStrsCnt) Xpr()                        {}
func (x StrsStrsCnt) UntUntXpr()                  {}
func (x StrsStrsCpy) Xpr()                        {}
func (x StrsStrsCpy) StrsStrsXpr()                {}
func (x StrsStrsClr) Xpr()                        {}
func (x StrsStrsClr) StrsStrsXpr()                {}
func (x StrsStrsRand) Xpr()                       {}
func (x StrsStrsRand) StrsStrsXpr()               {}
func (x StrsStrsMrg) Xpr()                        {}
func (x StrsStrsMrg) StrsStrsXpr()                {}
func (x StrsStrsPush) Xpr()                       {}
func (x StrsStrsPush) StrsStrsXpr()               {}
func (x StrsStrsPop) Xpr()                        {}
func (x StrsStrsPop) StrStrXpr()                  {}
func (x StrsStrsQue) Xpr()                        {}
func (x StrsStrsQue) StrsStrsXpr()                {}
func (x StrsStrsDque) Xpr()                       {}
func (x StrsStrsDque) StrStrXpr()                 {}
func (x StrsStrsIns) Xpr()                        {}
func (x StrsStrsIns) StrsStrsXpr()                {}
func (x StrsStrsUpd) Xpr()                        {}
func (x StrsStrsUpd) StrsStrsXpr()                {}
func (x StrsStrsDel) Xpr()                        {}
func (x StrsStrsDel) StrStrXpr()                  {}
func (x StrsStrsAt) Xpr()                         {}
func (x StrsStrsAt) StrStrXpr()                   {}
func (x StrsStrsIn) Xpr()                         {}
func (x StrsStrsIn) StrsStrsXpr()                 {}
func (x StrsStrsInBnd) Xpr()                      {}
func (x StrsStrsInBnd) StrsStrsXpr()              {}
func (x StrsStrsFrom) Xpr()                       {}
func (x StrsStrsFrom) StrsStrsXpr()               {}
func (x StrsStrsTo) Xpr()                         {}
func (x StrsStrsTo) StrsStrsXpr()                 {}
func (x StrsStrsFst) Xpr()                        {}
func (x StrsStrsFst) StrStrXpr()                  {}
func (x StrsStrsMdl) Xpr()                        {}
func (x StrsStrsMdl) StrStrXpr()                  {}
func (x StrsStrsLst) Xpr()                        {}
func (x StrsStrsLst) StrStrXpr()                  {}
func (x StrsStrsFstIdx) Xpr()                     {}
func (x StrsStrsFstIdx) UntUntXpr()               {}
func (x StrsStrsMdlIdx) Xpr()                     {}
func (x StrsStrsMdlIdx) UntUntXpr()               {}
func (x StrsStrsLstIdx) Xpr()                     {}
func (x StrsStrsLstIdx) UntUntXpr()               {}
func (x StrsStrsRev) Xpr()                        {}
func (x StrsStrsRev) StrsStrsXpr()                {}
func (x StrsStrsSrchIdxEql) Xpr()                 {}
func (x StrsStrsSrchIdxEql) UntUntXpr()           {}
func (x StrsStrsSrchIdx) Xpr()                    {}
func (x StrsStrsSrchIdx) UntUntXpr()              {}
func (x StrsStrsHas) Xpr()                        {}
func (x StrsStrsHas) BolBolXpr()                  {}
func (x StrsStrsSrtAsc) Xpr()                     {}
func (x StrsStrsSrtAsc) StrsStrsXpr()             {}
func (x StrsStrsSrtDsc) Xpr()                     {}
func (x StrsStrsSrtDsc) StrsStrsXpr()             {}
func (x BolsBolsCnt) Xpr()                        {}
func (x BolsBolsCnt) UntUntXpr()                  {}
func (x BolsBolsCpy) Xpr()                        {}
func (x BolsBolsCpy) BolsBolsXpr()                {}
func (x BolsBolsClr) Xpr()                        {}
func (x BolsBolsClr) BolsBolsXpr()                {}
func (x BolsBolsRand) Xpr()                       {}
func (x BolsBolsRand) BolsBolsXpr()               {}
func (x BolsBolsMrg) Xpr()                        {}
func (x BolsBolsMrg) BolsBolsXpr()                {}
func (x BolsBolsPush) Xpr()                       {}
func (x BolsBolsPush) BolsBolsXpr()               {}
func (x BolsBolsPop) Xpr()                        {}
func (x BolsBolsPop) BolBolXpr()                  {}
func (x BolsBolsQue) Xpr()                        {}
func (x BolsBolsQue) BolsBolsXpr()                {}
func (x BolsBolsDque) Xpr()                       {}
func (x BolsBolsDque) BolBolXpr()                 {}
func (x BolsBolsIns) Xpr()                        {}
func (x BolsBolsIns) BolsBolsXpr()                {}
func (x BolsBolsUpd) Xpr()                        {}
func (x BolsBolsUpd) BolsBolsXpr()                {}
func (x BolsBolsDel) Xpr()                        {}
func (x BolsBolsDel) BolBolXpr()                  {}
func (x BolsBolsAt) Xpr()                         {}
func (x BolsBolsAt) BolBolXpr()                   {}
func (x BolsBolsIn) Xpr()                         {}
func (x BolsBolsIn) BolsBolsXpr()                 {}
func (x BolsBolsInBnd) Xpr()                      {}
func (x BolsBolsInBnd) BolsBolsXpr()              {}
func (x BolsBolsFrom) Xpr()                       {}
func (x BolsBolsFrom) BolsBolsXpr()               {}
func (x BolsBolsTo) Xpr()                         {}
func (x BolsBolsTo) BolsBolsXpr()                 {}
func (x BolsBolsFst) Xpr()                        {}
func (x BolsBolsFst) BolBolXpr()                  {}
func (x BolsBolsMdl) Xpr()                        {}
func (x BolsBolsMdl) BolBolXpr()                  {}
func (x BolsBolsLst) Xpr()                        {}
func (x BolsBolsLst) BolBolXpr()                  {}
func (x BolsBolsFstIdx) Xpr()                     {}
func (x BolsBolsFstIdx) UntUntXpr()               {}
func (x BolsBolsMdlIdx) Xpr()                     {}
func (x BolsBolsMdlIdx) UntUntXpr()               {}
func (x BolsBolsLstIdx) Xpr()                     {}
func (x BolsBolsLstIdx) UntUntXpr()               {}
func (x BolsBolsRev) Xpr()                        {}
func (x BolsBolsRev) BolsBolsXpr()                {}
func (x FltsFltsCnt) Xpr()                        {}
func (x FltsFltsCnt) UntUntXpr()                  {}
func (x FltsFltsCpy) Xpr()                        {}
func (x FltsFltsCpy) FltsFltsXpr()                {}
func (x FltsFltsClr) Xpr()                        {}
func (x FltsFltsClr) FltsFltsXpr()                {}
func (x FltsFltsRand) Xpr()                       {}
func (x FltsFltsRand) FltsFltsXpr()               {}
func (x FltsFltsMrg) Xpr()                        {}
func (x FltsFltsMrg) FltsFltsXpr()                {}
func (x FltsFltsPush) Xpr()                       {}
func (x FltsFltsPush) FltsFltsXpr()               {}
func (x FltsFltsPop) Xpr()                        {}
func (x FltsFltsPop) FltFltXpr()                  {}
func (x FltsFltsQue) Xpr()                        {}
func (x FltsFltsQue) FltsFltsXpr()                {}
func (x FltsFltsDque) Xpr()                       {}
func (x FltsFltsDque) FltFltXpr()                 {}
func (x FltsFltsIns) Xpr()                        {}
func (x FltsFltsIns) FltsFltsXpr()                {}
func (x FltsFltsUpd) Xpr()                        {}
func (x FltsFltsUpd) FltsFltsXpr()                {}
func (x FltsFltsDel) Xpr()                        {}
func (x FltsFltsDel) FltFltXpr()                  {}
func (x FltsFltsAt) Xpr()                         {}
func (x FltsFltsAt) FltFltXpr()                   {}
func (x FltsFltsIn) Xpr()                         {}
func (x FltsFltsIn) FltsFltsXpr()                 {}
func (x FltsFltsInBnd) Xpr()                      {}
func (x FltsFltsInBnd) FltsFltsXpr()              {}
func (x FltsFltsFrom) Xpr()                       {}
func (x FltsFltsFrom) FltsFltsXpr()               {}
func (x FltsFltsTo) Xpr()                         {}
func (x FltsFltsTo) FltsFltsXpr()                 {}
func (x FltsFltsFst) Xpr()                        {}
func (x FltsFltsFst) FltFltXpr()                  {}
func (x FltsFltsMdl) Xpr()                        {}
func (x FltsFltsMdl) FltFltXpr()                  {}
func (x FltsFltsLst) Xpr()                        {}
func (x FltsFltsLst) FltFltXpr()                  {}
func (x FltsFltsFstIdx) Xpr()                     {}
func (x FltsFltsFstIdx) UntUntXpr()               {}
func (x FltsFltsMdlIdx) Xpr()                     {}
func (x FltsFltsMdlIdx) UntUntXpr()               {}
func (x FltsFltsLstIdx) Xpr()                     {}
func (x FltsFltsLstIdx) UntUntXpr()               {}
func (x FltsFltsRev) Xpr()                        {}
func (x FltsFltsRev) FltsFltsXpr()                {}
func (x FltsFltsSrchIdxEql) Xpr()                 {}
func (x FltsFltsSrchIdxEql) UntUntXpr()           {}
func (x FltsFltsSrchIdx) Xpr()                    {}
func (x FltsFltsSrchIdx) UntUntXpr()              {}
func (x FltsFltsHas) Xpr()                        {}
func (x FltsFltsHas) BolBolXpr()                  {}
func (x FltsFltsSrtAsc) Xpr()                     {}
func (x FltsFltsSrtAsc) FltsFltsXpr()             {}
func (x FltsFltsSrtDsc) Xpr()                     {}
func (x FltsFltsSrtDsc) FltsFltsXpr()             {}
func (x FltsFltsUnaPos) Xpr()                     {}
func (x FltsFltsUnaPos) FltsFltsXpr()             {}
func (x FltsFltsUnaNeg) Xpr()                     {}
func (x FltsFltsUnaNeg) FltsFltsXpr()             {}
func (x FltsFltsUnaInv) Xpr()                     {}
func (x FltsFltsUnaInv) FltsFltsXpr()             {}
func (x FltsFltsUnaSqr) Xpr()                     {}
func (x FltsFltsUnaSqr) FltsFltsXpr()             {}
func (x FltsFltsUnaSqrt) Xpr()                    {}
func (x FltsFltsUnaSqrt) FltsFltsXpr()            {}
func (x FltsFltsSclAdd) Xpr()                     {}
func (x FltsFltsSclAdd) FltsFltsXpr()             {}
func (x FltsFltsSclSub) Xpr()                     {}
func (x FltsFltsSclSub) FltsFltsXpr()             {}
func (x FltsFltsSclMul) Xpr()                     {}
func (x FltsFltsSclMul) FltsFltsXpr()             {}
func (x FltsFltsSclDiv) Xpr()                     {}
func (x FltsFltsSclDiv) FltsFltsXpr()             {}
func (x FltsFltsSclRem) Xpr()                     {}
func (x FltsFltsSclRem) FltsFltsXpr()             {}
func (x FltsFltsSclPow) Xpr()                     {}
func (x FltsFltsSclPow) FltsFltsXpr()             {}
func (x FltsFltsSclMin) Xpr()                     {}
func (x FltsFltsSclMin) FltsFltsXpr()             {}
func (x FltsFltsSclMax) Xpr()                     {}
func (x FltsFltsSclMax) FltsFltsXpr()             {}
func (x FltsFltsSelEql) Xpr()                     {}
func (x FltsFltsSelEql) FltsFltsXpr()             {}
func (x FltsFltsSelNeq) Xpr()                     {}
func (x FltsFltsSelNeq) FltsFltsXpr()             {}
func (x FltsFltsSelLss) Xpr()                     {}
func (x FltsFltsSelLss) FltsFltsXpr()             {}
func (x FltsFltsSelGtr) Xpr()                     {}
func (x FltsFltsSelGtr) FltsFltsXpr()             {}
func (x FltsFltsSelLeq) Xpr()                     {}
func (x FltsFltsSelLeq) FltsFltsXpr()             {}
func (x FltsFltsSelGeq) Xpr()                     {}
func (x FltsFltsSelGeq) FltsFltsXpr()             {}
func (x FltsFltsCntEql) Xpr()                     {}
func (x FltsFltsCntEql) FltFltXpr()               {}
func (x FltsFltsCntNeq) Xpr()                     {}
func (x FltsFltsCntNeq) FltFltXpr()               {}
func (x FltsFltsCntLss) Xpr()                     {}
func (x FltsFltsCntLss) FltFltXpr()               {}
func (x FltsFltsCntGtr) Xpr()                     {}
func (x FltsFltsCntGtr) FltFltXpr()               {}
func (x FltsFltsCntLeq) Xpr()                     {}
func (x FltsFltsCntLeq) FltFltXpr()               {}
func (x FltsFltsCntGeq) Xpr()                     {}
func (x FltsFltsCntGeq) FltFltXpr()               {}
func (x FltsFltsInrAdd) Xpr()                     {}
func (x FltsFltsInrAdd) FltsFltsXpr()             {}
func (x FltsFltsInrSub) Xpr()                     {}
func (x FltsFltsInrSub) FltsFltsXpr()             {}
func (x FltsFltsInrMul) Xpr()                     {}
func (x FltsFltsInrMul) FltsFltsXpr()             {}
func (x FltsFltsInrDiv) Xpr()                     {}
func (x FltsFltsInrDiv) FltsFltsXpr()             {}
func (x FltsFltsInrRem) Xpr()                     {}
func (x FltsFltsInrRem) FltsFltsXpr()             {}
func (x FltsFltsInrPow) Xpr()                     {}
func (x FltsFltsInrPow) FltsFltsXpr()             {}
func (x FltsFltsInrMin) Xpr()                     {}
func (x FltsFltsInrMin) FltsFltsXpr()             {}
func (x FltsFltsInrMax) Xpr()                     {}
func (x FltsFltsInrMax) FltsFltsXpr()             {}
func (x FltsFltsSum) Xpr()                        {}
func (x FltsFltsSum) FltFltXpr()                  {}
func (x FltsFltsPrd) Xpr()                        {}
func (x FltsFltsPrd) FltFltXpr()                  {}
func (x FltsFltsMin) Xpr()                        {}
func (x FltsFltsMin) FltFltXpr()                  {}
func (x FltsFltsMax) Xpr()                        {}
func (x FltsFltsMax) FltFltXpr()                  {}
func (x FltsFltsMid) Xpr()                        {}
func (x FltsFltsMid) FltFltXpr()                  {}
func (x FltsFltsMdn) Xpr()                        {}
func (x FltsFltsMdn) FltFltXpr()                  {}
func (x FltsFltsSma) Xpr()                        {}
func (x FltsFltsSma) FltFltXpr()                  {}
func (x FltsFltsGma) Xpr()                        {}
func (x FltsFltsGma) FltFltXpr()                  {}
func (x FltsFltsWma) Xpr()                        {}
func (x FltsFltsWma) FltFltXpr()                  {}
func (x FltsFltsVrnc) Xpr()                       {}
func (x FltsFltsVrnc) FltFltXpr()                 {}
func (x FltsFltsStd) Xpr()                        {}
func (x FltsFltsStd) FltFltXpr()                  {}
func (x FltsFltsZscr) Xpr()                       {}
func (x FltsFltsZscr) FltsFltsXpr()               {}
func (x FltsFltsZscrInplace) Xpr()                {}
func (x FltsFltsZscrInplace) FltsFltsXpr()        {}
func (x FltsFltsRngFul) Xpr()                     {}
func (x FltsFltsRngFul) FltFltXpr()               {}
func (x FltsFltsRngLst) Xpr()                     {}
func (x FltsFltsRngLst) FltFltXpr()               {}
func (x FltsFltsProLst) Xpr()                     {}
func (x FltsFltsProLst) FltFltXpr()               {}
func (x FltsFltsProSma) Xpr()                     {}
func (x FltsFltsProSma) FltFltXpr()               {}
func (x FltsFltsSubSumPos) Xpr()                  {}
func (x FltsFltsSubSumPos) FltFltXpr()            {}
func (x FltsFltsSubSumNeg) Xpr()                  {}
func (x FltsFltsSubSumNeg) FltFltXpr()            {}
func (x FltsFltsRsi) Xpr()                        {}
func (x FltsFltsRsi) FltFltXpr()                  {}
func (x FltsFltsWrsi) Xpr()                       {}
func (x FltsFltsWrsi) FltFltXpr()                 {}
func (x FltsFltsPro) Xpr()                        {}
func (x FltsFltsPro) FltsFltsXpr()                {}
func (x FltsFltsAlma) Xpr()                       {}
func (x FltsFltsAlma) FltFltXpr()                 {}
func (x FltsFltsProAlma) Xpr()                    {}
func (x FltsFltsProAlma) FltFltXpr()              {}
func (x FltsFltsCntrDist) Xpr()                   {}
func (x FltsFltsCntrDist) FltsFltsXpr()           {}
func (x UntsUntsCnt) Xpr()                        {}
func (x UntsUntsCnt) UntUntXpr()                  {}
func (x UntsUntsCpy) Xpr()                        {}
func (x UntsUntsCpy) UntsUntsXpr()                {}
func (x UntsUntsClr) Xpr()                        {}
func (x UntsUntsClr) UntsUntsXpr()                {}
func (x UntsUntsRand) Xpr()                       {}
func (x UntsUntsRand) UntsUntsXpr()               {}
func (x UntsUntsMrg) Xpr()                        {}
func (x UntsUntsMrg) UntsUntsXpr()                {}
func (x UntsUntsPush) Xpr()                       {}
func (x UntsUntsPush) UntsUntsXpr()               {}
func (x UntsUntsPop) Xpr()                        {}
func (x UntsUntsPop) UntUntXpr()                  {}
func (x UntsUntsQue) Xpr()                        {}
func (x UntsUntsQue) UntsUntsXpr()                {}
func (x UntsUntsDque) Xpr()                       {}
func (x UntsUntsDque) UntUntXpr()                 {}
func (x UntsUntsIns) Xpr()                        {}
func (x UntsUntsIns) UntsUntsXpr()                {}
func (x UntsUntsUpd) Xpr()                        {}
func (x UntsUntsUpd) UntsUntsXpr()                {}
func (x UntsUntsDel) Xpr()                        {}
func (x UntsUntsDel) UntUntXpr()                  {}
func (x UntsUntsAt) Xpr()                         {}
func (x UntsUntsAt) UntUntXpr()                   {}
func (x UntsUntsIn) Xpr()                         {}
func (x UntsUntsIn) UntsUntsXpr()                 {}
func (x UntsUntsInBnd) Xpr()                      {}
func (x UntsUntsInBnd) UntsUntsXpr()              {}
func (x UntsUntsFrom) Xpr()                       {}
func (x UntsUntsFrom) UntsUntsXpr()               {}
func (x UntsUntsTo) Xpr()                         {}
func (x UntsUntsTo) UntsUntsXpr()                 {}
func (x UntsUntsFst) Xpr()                        {}
func (x UntsUntsFst) UntUntXpr()                  {}
func (x UntsUntsMdl) Xpr()                        {}
func (x UntsUntsMdl) UntUntXpr()                  {}
func (x UntsUntsLst) Xpr()                        {}
func (x UntsUntsLst) UntUntXpr()                  {}
func (x UntsUntsFstIdx) Xpr()                     {}
func (x UntsUntsFstIdx) UntUntXpr()               {}
func (x UntsUntsMdlIdx) Xpr()                     {}
func (x UntsUntsMdlIdx) UntUntXpr()               {}
func (x UntsUntsLstIdx) Xpr()                     {}
func (x UntsUntsLstIdx) UntUntXpr()               {}
func (x UntsUntsRev) Xpr()                        {}
func (x UntsUntsRev) UntsUntsXpr()                {}
func (x UntsUntsSrchIdxEql) Xpr()                 {}
func (x UntsUntsSrchIdxEql) UntUntXpr()           {}
func (x UntsUntsSrchIdx) Xpr()                    {}
func (x UntsUntsSrchIdx) UntUntXpr()              {}
func (x UntsUntsHas) Xpr()                        {}
func (x UntsUntsHas) BolBolXpr()                  {}
func (x UntsUntsSrtAsc) Xpr()                     {}
func (x UntsUntsSrtAsc) UntsUntsXpr()             {}
func (x UntsUntsSrtDsc) Xpr()                     {}
func (x UntsUntsSrtDsc) UntsUntsXpr()             {}
func (x UntsUntsInrAdd) Xpr()                     {}
func (x UntsUntsInrAdd) UntsUntsXpr()             {}
func (x UntsUntsInrSub) Xpr()                     {}
func (x UntsUntsInrSub) UntsUntsXpr()             {}
func (x UntsUntsInrMul) Xpr()                     {}
func (x UntsUntsInrMul) UntsUntsXpr()             {}
func (x UntsUntsInrDiv) Xpr()                     {}
func (x UntsUntsInrDiv) UntsUntsXpr()             {}
func (x UntsUntsInrRem) Xpr()                     {}
func (x UntsUntsInrRem) UntsUntsXpr()             {}
func (x UntsUntsInrPow) Xpr()                     {}
func (x UntsUntsInrPow) UntsUntsXpr()             {}
func (x UntsUntsInrMin) Xpr()                     {}
func (x UntsUntsInrMin) UntsUntsXpr()             {}
func (x UntsUntsInrMax) Xpr()                     {}
func (x UntsUntsInrMax) UntsUntsXpr()             {}
func (x UntsUntsSum) Xpr()                        {}
func (x UntsUntsSum) UntUntXpr()                  {}
func (x UntsUntsPrd) Xpr()                        {}
func (x UntsUntsPrd) UntUntXpr()                  {}
func (x UntsUntsMin) Xpr()                        {}
func (x UntsUntsMin) UntUntXpr()                  {}
func (x UntsUntsMax) Xpr()                        {}
func (x UntsUntsMax) UntUntXpr()                  {}
func (x UntsUntsMid) Xpr()                        {}
func (x UntsUntsMid) UntUntXpr()                  {}
func (x UntsUntsMdn) Xpr()                        {}
func (x UntsUntsMdn) UntUntXpr()                  {}
func (x UntsUntsSma) Xpr()                        {}
func (x UntsUntsSma) UntUntXpr()                  {}
func (x UntsUntsGma) Xpr()                        {}
func (x UntsUntsGma) UntUntXpr()                  {}
func (x UntsUntsWma) Xpr()                        {}
func (x UntsUntsWma) UntUntXpr()                  {}
func (x UntsUntsVrnc) Xpr()                       {}
func (x UntsUntsVrnc) UntUntXpr()                 {}
func (x UntsUntsStd) Xpr()                        {}
func (x UntsUntsStd) UntUntXpr()                  {}
func (x UntsUntsZscr) Xpr()                       {}
func (x UntsUntsZscr) UntsUntsXpr()               {}
func (x UntsUntsZscrInplace) Xpr()                {}
func (x UntsUntsZscrInplace) UntsUntsXpr()        {}
func (x UntsUntsRngFul) Xpr()                     {}
func (x UntsUntsRngFul) UntUntXpr()               {}
func (x UntsUntsRngLst) Xpr()                     {}
func (x UntsUntsRngLst) UntUntXpr()               {}
func (x UntsUntsProLst) Xpr()                     {}
func (x UntsUntsProLst) UntUntXpr()               {}
func (x UntsUntsProSma) Xpr()                     {}
func (x UntsUntsProSma) UntUntXpr()               {}
func (x IntsIntsCnt) Xpr()                        {}
func (x IntsIntsCnt) UntUntXpr()                  {}
func (x IntsIntsCpy) Xpr()                        {}
func (x IntsIntsCpy) IntsIntsXpr()                {}
func (x IntsIntsClr) Xpr()                        {}
func (x IntsIntsClr) IntsIntsXpr()                {}
func (x IntsIntsRand) Xpr()                       {}
func (x IntsIntsRand) IntsIntsXpr()               {}
func (x IntsIntsMrg) Xpr()                        {}
func (x IntsIntsMrg) IntsIntsXpr()                {}
func (x IntsIntsPush) Xpr()                       {}
func (x IntsIntsPush) IntsIntsXpr()               {}
func (x IntsIntsPop) Xpr()                        {}
func (x IntsIntsPop) IntIntXpr()                  {}
func (x IntsIntsQue) Xpr()                        {}
func (x IntsIntsQue) IntsIntsXpr()                {}
func (x IntsIntsDque) Xpr()                       {}
func (x IntsIntsDque) IntIntXpr()                 {}
func (x IntsIntsIns) Xpr()                        {}
func (x IntsIntsIns) IntsIntsXpr()                {}
func (x IntsIntsUpd) Xpr()                        {}
func (x IntsIntsUpd) IntsIntsXpr()                {}
func (x IntsIntsDel) Xpr()                        {}
func (x IntsIntsDel) IntIntXpr()                  {}
func (x IntsIntsAt) Xpr()                         {}
func (x IntsIntsAt) IntIntXpr()                   {}
func (x IntsIntsIn) Xpr()                         {}
func (x IntsIntsIn) IntsIntsXpr()                 {}
func (x IntsIntsInBnd) Xpr()                      {}
func (x IntsIntsInBnd) IntsIntsXpr()              {}
func (x IntsIntsFrom) Xpr()                       {}
func (x IntsIntsFrom) IntsIntsXpr()               {}
func (x IntsIntsTo) Xpr()                         {}
func (x IntsIntsTo) IntsIntsXpr()                 {}
func (x IntsIntsFst) Xpr()                        {}
func (x IntsIntsFst) IntIntXpr()                  {}
func (x IntsIntsMdl) Xpr()                        {}
func (x IntsIntsMdl) IntIntXpr()                  {}
func (x IntsIntsLst) Xpr()                        {}
func (x IntsIntsLst) IntIntXpr()                  {}
func (x IntsIntsFstIdx) Xpr()                     {}
func (x IntsIntsFstIdx) UntUntXpr()               {}
func (x IntsIntsMdlIdx) Xpr()                     {}
func (x IntsIntsMdlIdx) UntUntXpr()               {}
func (x IntsIntsLstIdx) Xpr()                     {}
func (x IntsIntsLstIdx) UntUntXpr()               {}
func (x IntsIntsRev) Xpr()                        {}
func (x IntsIntsRev) IntsIntsXpr()                {}
func (x IntsIntsSrchIdxEql) Xpr()                 {}
func (x IntsIntsSrchIdxEql) UntUntXpr()           {}
func (x IntsIntsSrchIdx) Xpr()                    {}
func (x IntsIntsSrchIdx) UntUntXpr()              {}
func (x IntsIntsHas) Xpr()                        {}
func (x IntsIntsHas) BolBolXpr()                  {}
func (x IntsIntsSrtAsc) Xpr()                     {}
func (x IntsIntsSrtAsc) IntsIntsXpr()             {}
func (x IntsIntsSrtDsc) Xpr()                     {}
func (x IntsIntsSrtDsc) IntsIntsXpr()             {}
func (x TmesTmesBnd) Xpr()                        {}
func (x TmesTmesBnd) BndBndXpr()                  {}
func (x TmesTmesWeekdayCnt) Xpr()                 {}
func (x TmesTmesWeekdayCnt) UntUntXpr()           {}
func (x TmesTmesCnt) Xpr()                        {}
func (x TmesTmesCnt) UntUntXpr()                  {}
func (x TmesTmesCpy) Xpr()                        {}
func (x TmesTmesCpy) TmesTmesXpr()                {}
func (x TmesTmesClr) Xpr()                        {}
func (x TmesTmesClr) TmesTmesXpr()                {}
func (x TmesTmesRand) Xpr()                       {}
func (x TmesTmesRand) TmesTmesXpr()               {}
func (x TmesTmesMrg) Xpr()                        {}
func (x TmesTmesMrg) TmesTmesXpr()                {}
func (x TmesTmesPush) Xpr()                       {}
func (x TmesTmesPush) TmesTmesXpr()               {}
func (x TmesTmesPop) Xpr()                        {}
func (x TmesTmesPop) TmeTmeXpr()                  {}
func (x TmesTmesQue) Xpr()                        {}
func (x TmesTmesQue) TmesTmesXpr()                {}
func (x TmesTmesDque) Xpr()                       {}
func (x TmesTmesDque) TmeTmeXpr()                 {}
func (x TmesTmesIns) Xpr()                        {}
func (x TmesTmesIns) TmesTmesXpr()                {}
func (x TmesTmesUpd) Xpr()                        {}
func (x TmesTmesUpd) TmesTmesXpr()                {}
func (x TmesTmesDel) Xpr()                        {}
func (x TmesTmesDel) TmeTmeXpr()                  {}
func (x TmesTmesAt) Xpr()                         {}
func (x TmesTmesAt) TmeTmeXpr()                   {}
func (x TmesTmesIn) Xpr()                         {}
func (x TmesTmesIn) TmesTmesXpr()                 {}
func (x TmesTmesInBnd) Xpr()                      {}
func (x TmesTmesInBnd) TmesTmesXpr()              {}
func (x TmesTmesFrom) Xpr()                       {}
func (x TmesTmesFrom) TmesTmesXpr()               {}
func (x TmesTmesTo) Xpr()                         {}
func (x TmesTmesTo) TmesTmesXpr()                 {}
func (x TmesTmesFst) Xpr()                        {}
func (x TmesTmesFst) TmeTmeXpr()                  {}
func (x TmesTmesMdl) Xpr()                        {}
func (x TmesTmesMdl) TmeTmeXpr()                  {}
func (x TmesTmesLst) Xpr()                        {}
func (x TmesTmesLst) TmeTmeXpr()                  {}
func (x TmesTmesFstIdx) Xpr()                     {}
func (x TmesTmesFstIdx) UntUntXpr()               {}
func (x TmesTmesMdlIdx) Xpr()                     {}
func (x TmesTmesMdlIdx) UntUntXpr()               {}
func (x TmesTmesLstIdx) Xpr()                     {}
func (x TmesTmesLstIdx) UntUntXpr()               {}
func (x TmesTmesRev) Xpr()                        {}
func (x TmesTmesRev) TmesTmesXpr()                {}
func (x TmesTmesSrchIdxEql) Xpr()                 {}
func (x TmesTmesSrchIdxEql) UntUntXpr()           {}
func (x TmesTmesSrchIdx) Xpr()                    {}
func (x TmesTmesSrchIdx) UntUntXpr()              {}
func (x TmesTmesHas) Xpr()                        {}
func (x TmesTmesHas) BolBolXpr()                  {}
func (x TmesTmesSrtAsc) Xpr()                     {}
func (x TmesTmesSrtAsc) TmesTmesXpr()             {}
func (x TmesTmesSrtDsc) Xpr()                     {}
func (x TmesTmesSrtDsc) TmesTmesXpr()             {}
func (x TmesTmesInrAdd) Xpr()                     {}
func (x TmesTmesInrAdd) TmesTmesXpr()             {}
func (x TmesTmesInrSub) Xpr()                     {}
func (x TmesTmesInrSub) TmesTmesXpr()             {}
func (x TmesTmesInrMul) Xpr()                     {}
func (x TmesTmesInrMul) TmesTmesXpr()             {}
func (x TmesTmesInrDiv) Xpr()                     {}
func (x TmesTmesInrDiv) TmesTmesXpr()             {}
func (x TmesTmesInrRem) Xpr()                     {}
func (x TmesTmesInrRem) TmesTmesXpr()             {}
func (x TmesTmesInrPow) Xpr()                     {}
func (x TmesTmesInrPow) TmesTmesXpr()             {}
func (x TmesTmesInrMin) Xpr()                     {}
func (x TmesTmesInrMin) TmesTmesXpr()             {}
func (x TmesTmesInrMax) Xpr()                     {}
func (x TmesTmesInrMax) TmesTmesXpr()             {}
func (x TmesTmesSum) Xpr()                        {}
func (x TmesTmesSum) TmeTmeXpr()                  {}
func (x TmesTmesPrd) Xpr()                        {}
func (x TmesTmesPrd) TmeTmeXpr()                  {}
func (x TmesTmesMin) Xpr()                        {}
func (x TmesTmesMin) TmeTmeXpr()                  {}
func (x TmesTmesMax) Xpr()                        {}
func (x TmesTmesMax) TmeTmeXpr()                  {}
func (x TmesTmesMid) Xpr()                        {}
func (x TmesTmesMid) TmeTmeXpr()                  {}
func (x TmesTmesMdn) Xpr()                        {}
func (x TmesTmesMdn) TmeTmeXpr()                  {}
func (x TmesTmesSma) Xpr()                        {}
func (x TmesTmesSma) TmeTmeXpr()                  {}
func (x TmesTmesGma) Xpr()                        {}
func (x TmesTmesGma) TmeTmeXpr()                  {}
func (x TmesTmesWma) Xpr()                        {}
func (x TmesTmesWma) TmeTmeXpr()                  {}
func (x TmesTmesVrnc) Xpr()                       {}
func (x TmesTmesVrnc) TmeTmeXpr()                 {}
func (x TmesTmesStd) Xpr()                        {}
func (x TmesTmesStd) TmeTmeXpr()                  {}
func (x TmesTmesZscr) Xpr()                       {}
func (x TmesTmesZscr) TmesTmesXpr()               {}
func (x TmesTmesZscrInplace) Xpr()                {}
func (x TmesTmesZscrInplace) TmesTmesXpr()        {}
func (x TmesTmesRngFul) Xpr()                     {}
func (x TmesTmesRngFul) TmeTmeXpr()               {}
func (x TmesTmesRngLst) Xpr()                     {}
func (x TmesTmesRngLst) TmeTmeXpr()               {}
func (x TmesTmesProLst) Xpr()                     {}
func (x TmesTmesProLst) TmeTmeXpr()               {}
func (x TmesTmesProSma) Xpr()                     {}
func (x TmesTmesProSma) TmeTmeXpr()               {}
func (x BndsBndsCnt) Xpr()                        {}
func (x BndsBndsCnt) UntUntXpr()                  {}
func (x BndsBndsCpy) Xpr()                        {}
func (x BndsBndsCpy) BndsBndsXpr()                {}
func (x BndsBndsClr) Xpr()                        {}
func (x BndsBndsClr) BndsBndsXpr()                {}
func (x BndsBndsRand) Xpr()                       {}
func (x BndsBndsRand) BndsBndsXpr()               {}
func (x BndsBndsMrg) Xpr()                        {}
func (x BndsBndsMrg) BndsBndsXpr()                {}
func (x BndsBndsPush) Xpr()                       {}
func (x BndsBndsPush) BndsBndsXpr()               {}
func (x BndsBndsPop) Xpr()                        {}
func (x BndsBndsPop) BndBndXpr()                  {}
func (x BndsBndsQue) Xpr()                        {}
func (x BndsBndsQue) BndsBndsXpr()                {}
func (x BndsBndsDque) Xpr()                       {}
func (x BndsBndsDque) BndBndXpr()                 {}
func (x BndsBndsIns) Xpr()                        {}
func (x BndsBndsIns) BndsBndsXpr()                {}
func (x BndsBndsUpd) Xpr()                        {}
func (x BndsBndsUpd) BndsBndsXpr()                {}
func (x BndsBndsDel) Xpr()                        {}
func (x BndsBndsDel) BndBndXpr()                  {}
func (x BndsBndsAt) Xpr()                         {}
func (x BndsBndsAt) BndBndXpr()                   {}
func (x BndsBndsIn) Xpr()                         {}
func (x BndsBndsIn) BndsBndsXpr()                 {}
func (x BndsBndsInBnd) Xpr()                      {}
func (x BndsBndsInBnd) BndsBndsXpr()              {}
func (x BndsBndsFrom) Xpr()                       {}
func (x BndsBndsFrom) BndsBndsXpr()               {}
func (x BndsBndsTo) Xpr()                         {}
func (x BndsBndsTo) BndsBndsXpr()                 {}
func (x BndsBndsFst) Xpr()                        {}
func (x BndsBndsFst) BndBndXpr()                  {}
func (x BndsBndsMdl) Xpr()                        {}
func (x BndsBndsMdl) BndBndXpr()                  {}
func (x BndsBndsLst) Xpr()                        {}
func (x BndsBndsLst) BndBndXpr()                  {}
func (x BndsBndsFstIdx) Xpr()                     {}
func (x BndsBndsFstIdx) UntUntXpr()               {}
func (x BndsBndsMdlIdx) Xpr()                     {}
func (x BndsBndsMdlIdx) UntUntXpr()               {}
func (x BndsBndsLstIdx) Xpr()                     {}
func (x BndsBndsLstIdx) UntUntXpr()               {}
func (x BndsBndsRev) Xpr()                        {}
func (x BndsBndsRev) BndsBndsXpr()                {}
func (x TmeRngsCnt) Xpr()                         {}
func (x TmeRngsCnt) UntUntXpr()                   {}
func (x TmeRngsCpy) Xpr()                         {}
func (x TmeRngsCpy) TmeRngsXpr()                  {}
func (x TmeRngsClr) Xpr()                         {}
func (x TmeRngsClr) TmeRngsXpr()                  {}
func (x TmeRngsRand) Xpr()                        {}
func (x TmeRngsRand) TmeRngsXpr()                 {}
func (x TmeRngsMrg) Xpr()                         {}
func (x TmeRngsMrg) TmeRngsXpr()                  {}
func (x TmeRngsPush) Xpr()                        {}
func (x TmeRngsPush) TmeRngsXpr()                 {}
func (x TmeRngsPop) Xpr()                         {}
func (x TmeRngsPop) TmeRngXpr()                   {}
func (x TmeRngsQue) Xpr()                         {}
func (x TmeRngsQue) TmeRngsXpr()                  {}
func (x TmeRngsDque) Xpr()                        {}
func (x TmeRngsDque) TmeRngXpr()                  {}
func (x TmeRngsIns) Xpr()                         {}
func (x TmeRngsIns) TmeRngsXpr()                  {}
func (x TmeRngsUpd) Xpr()                         {}
func (x TmeRngsUpd) TmeRngsXpr()                  {}
func (x TmeRngsDel) Xpr()                         {}
func (x TmeRngsDel) TmeRngXpr()                   {}
func (x TmeRngsAt) Xpr()                          {}
func (x TmeRngsAt) TmeRngXpr()                    {}
func (x TmeRngsIn) Xpr()                          {}
func (x TmeRngsIn) TmeRngsXpr()                   {}
func (x TmeRngsInBnd) Xpr()                       {}
func (x TmeRngsInBnd) TmeRngsXpr()                {}
func (x TmeRngsFrom) Xpr()                        {}
func (x TmeRngsFrom) TmeRngsXpr()                 {}
func (x TmeRngsTo) Xpr()                          {}
func (x TmeRngsTo) TmeRngsXpr()                   {}
func (x TmeRngsFst) Xpr()                         {}
func (x TmeRngsFst) TmeRngXpr()                   {}
func (x TmeRngsMdl) Xpr()                         {}
func (x TmeRngsMdl) TmeRngXpr()                   {}
func (x TmeRngsLst) Xpr()                         {}
func (x TmeRngsLst) TmeRngXpr()                   {}
func (x TmeRngsFstIdx) Xpr()                      {}
func (x TmeRngsFstIdx) UntUntXpr()                {}
func (x TmeRngsMdlIdx) Xpr()                      {}
func (x TmeRngsMdlIdx) UntUntXpr()                {}
func (x TmeRngsLstIdx) Xpr()                      {}
func (x TmeRngsLstIdx) UntUntXpr()                {}
func (x TmeRngsRev) Xpr()                         {}
func (x TmeRngsRev) TmeRngsXpr()                  {}
func (x TmeRngsSrchIdx) Xpr()                     {}
func (x TmeRngsSrchIdx) UntUntXpr()               {}
func (x TmeRngsRngMrg) Xpr()                      {}
func (x TmeRngsRngMrg) TmeRngXpr()                {}
func (x AnaTrdOpnMid) Xpr()                       {}
func (x AnaTrdOpnMid) FltFltXpr()                 {}
func (x AnaTrdClsMid) Xpr()                       {}
func (x AnaTrdClsMid) FltFltXpr()                 {}
func (x AnaTrdsCnt) Xpr()                         {}
func (x AnaTrdsCnt) UntUntXpr()                   {}
func (x AnaTrdsCpy) Xpr()                         {}
func (x AnaTrdsCpy) AnaTrdsXpr()                  {}
func (x AnaTrdsClr) Xpr()                         {}
func (x AnaTrdsClr) AnaTrdsXpr()                  {}
func (x AnaTrdsRand) Xpr()                        {}
func (x AnaTrdsRand) AnaTrdsXpr()                 {}
func (x AnaTrdsMrg) Xpr()                         {}
func (x AnaTrdsMrg) AnaTrdsXpr()                  {}
func (x AnaTrdsPush) Xpr()                        {}
func (x AnaTrdsPush) AnaTrdsXpr()                 {}
func (x AnaTrdsPop) Xpr()                         {}
func (x AnaTrdsPop) AnaTrdXpr()                   {}
func (x AnaTrdsQue) Xpr()                         {}
func (x AnaTrdsQue) AnaTrdsXpr()                  {}
func (x AnaTrdsDque) Xpr()                        {}
func (x AnaTrdsDque) AnaTrdXpr()                  {}
func (x AnaTrdsIns) Xpr()                         {}
func (x AnaTrdsIns) AnaTrdsXpr()                  {}
func (x AnaTrdsUpd) Xpr()                         {}
func (x AnaTrdsUpd) AnaTrdsXpr()                  {}
func (x AnaTrdsDel) Xpr()                         {}
func (x AnaTrdsDel) AnaTrdXpr()                   {}
func (x AnaTrdsAt) Xpr()                          {}
func (x AnaTrdsAt) AnaTrdXpr()                    {}
func (x AnaTrdsIn) Xpr()                          {}
func (x AnaTrdsIn) AnaTrdsXpr()                   {}
func (x AnaTrdsInBnd) Xpr()                       {}
func (x AnaTrdsInBnd) AnaTrdsXpr()                {}
func (x AnaTrdsFrom) Xpr()                        {}
func (x AnaTrdsFrom) AnaTrdsXpr()                 {}
func (x AnaTrdsTo) Xpr()                          {}
func (x AnaTrdsTo) AnaTrdsXpr()                   {}
func (x AnaTrdsFst) Xpr()                         {}
func (x AnaTrdsFst) AnaTrdXpr()                   {}
func (x AnaTrdsMdl) Xpr()                         {}
func (x AnaTrdsMdl) AnaTrdXpr()                   {}
func (x AnaTrdsLst) Xpr()                         {}
func (x AnaTrdsLst) AnaTrdXpr()                   {}
func (x AnaTrdsFstIdx) Xpr()                      {}
func (x AnaTrdsFstIdx) UntUntXpr()                {}
func (x AnaTrdsMdlIdx) Xpr()                      {}
func (x AnaTrdsMdlIdx) UntUntXpr()                {}
func (x AnaTrdsLstIdx) Xpr()                      {}
func (x AnaTrdsLstIdx) UntUntXpr()                {}
func (x AnaTrdsRev) Xpr()                         {}
func (x AnaTrdsRev) AnaTrdsXpr()                  {}
func (x AnaTrdsSelClsResEql) Xpr()                {}
func (x AnaTrdsSelClsResEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsResNeq) Xpr()                {}
func (x AnaTrdsSelClsResNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsResLss) Xpr()                {}
func (x AnaTrdsSelClsResLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsResGtr) Xpr()                {}
func (x AnaTrdsSelClsResGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsResLeq) Xpr()                {}
func (x AnaTrdsSelClsResLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsResGeq) Xpr()                {}
func (x AnaTrdsSelClsResGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsReqEql) Xpr()                {}
func (x AnaTrdsSelClsReqEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsReqNeq) Xpr()                {}
func (x AnaTrdsSelClsReqNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsReqLss) Xpr()                {}
func (x AnaTrdsSelClsReqLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsReqGtr) Xpr()                {}
func (x AnaTrdsSelClsReqGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsReqLeq) Xpr()                {}
func (x AnaTrdsSelClsReqLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsReqGeq) Xpr()                {}
func (x AnaTrdsSelClsReqGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnResEql) Xpr()                {}
func (x AnaTrdsSelOpnResEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnResNeq) Xpr()                {}
func (x AnaTrdsSelOpnResNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnResLss) Xpr()                {}
func (x AnaTrdsSelOpnResLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnResGtr) Xpr()                {}
func (x AnaTrdsSelOpnResGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnResLeq) Xpr()                {}
func (x AnaTrdsSelOpnResLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnResGeq) Xpr()                {}
func (x AnaTrdsSelOpnResGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnReqEql) Xpr()                {}
func (x AnaTrdsSelOpnReqEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnReqNeq) Xpr()                {}
func (x AnaTrdsSelOpnReqNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnReqLss) Xpr()                {}
func (x AnaTrdsSelOpnReqLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnReqGtr) Xpr()                {}
func (x AnaTrdsSelOpnReqGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnReqLeq) Xpr()                {}
func (x AnaTrdsSelOpnReqLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnReqGeq) Xpr()                {}
func (x AnaTrdsSelOpnReqGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelInstrEql) Xpr()                 {}
func (x AnaTrdsSelInstrEql) AnaTrdsXpr()          {}
func (x AnaTrdsSelInstrNeq) Xpr()                 {}
func (x AnaTrdsSelInstrNeq) AnaTrdsXpr()          {}
func (x AnaTrdsSelInstrLss) Xpr()                 {}
func (x AnaTrdsSelInstrLss) AnaTrdsXpr()          {}
func (x AnaTrdsSelInstrGtr) Xpr()                 {}
func (x AnaTrdsSelInstrGtr) AnaTrdsXpr()          {}
func (x AnaTrdsSelInstrLeq) Xpr()                 {}
func (x AnaTrdsSelInstrLeq) AnaTrdsXpr()          {}
func (x AnaTrdsSelInstrGeq) Xpr()                 {}
func (x AnaTrdsSelInstrGeq) AnaTrdsXpr()          {}
func (x AnaTrdsSelUnitsEql) Xpr()                 {}
func (x AnaTrdsSelUnitsEql) AnaTrdsXpr()          {}
func (x AnaTrdsSelUnitsNeq) Xpr()                 {}
func (x AnaTrdsSelUnitsNeq) AnaTrdsXpr()          {}
func (x AnaTrdsSelUnitsLss) Xpr()                 {}
func (x AnaTrdsSelUnitsLss) AnaTrdsXpr()          {}
func (x AnaTrdsSelUnitsGtr) Xpr()                 {}
func (x AnaTrdsSelUnitsGtr) AnaTrdsXpr()          {}
func (x AnaTrdsSelUnitsLeq) Xpr()                 {}
func (x AnaTrdsSelUnitsLeq) AnaTrdsXpr()          {}
func (x AnaTrdsSelUnitsGeq) Xpr()                 {}
func (x AnaTrdsSelUnitsGeq) AnaTrdsXpr()          {}
func (x AnaTrdsSelMrgnRtioEql) Xpr()              {}
func (x AnaTrdsSelMrgnRtioEql) AnaTrdsXpr()       {}
func (x AnaTrdsSelMrgnRtioNeq) Xpr()              {}
func (x AnaTrdsSelMrgnRtioNeq) AnaTrdsXpr()       {}
func (x AnaTrdsSelMrgnRtioLss) Xpr()              {}
func (x AnaTrdsSelMrgnRtioLss) AnaTrdsXpr()       {}
func (x AnaTrdsSelMrgnRtioGtr) Xpr()              {}
func (x AnaTrdsSelMrgnRtioGtr) AnaTrdsXpr()       {}
func (x AnaTrdsSelMrgnRtioLeq) Xpr()              {}
func (x AnaTrdsSelMrgnRtioLeq) AnaTrdsXpr()       {}
func (x AnaTrdsSelMrgnRtioGeq) Xpr()              {}
func (x AnaTrdsSelMrgnRtioGeq) AnaTrdsXpr()       {}
func (x AnaTrdsSelTrdPctEql) Xpr()                {}
func (x AnaTrdsSelTrdPctEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelTrdPctNeq) Xpr()                {}
func (x AnaTrdsSelTrdPctNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelTrdPctLss) Xpr()                {}
func (x AnaTrdsSelTrdPctLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelTrdPctGtr) Xpr()                {}
func (x AnaTrdsSelTrdPctGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelTrdPctLeq) Xpr()                {}
func (x AnaTrdsSelTrdPctLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelTrdPctGeq) Xpr()                {}
func (x AnaTrdsSelTrdPctGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBalUsdActEql) Xpr()          {}
func (x AnaTrdsSelClsBalUsdActEql) AnaTrdsXpr()   {}
func (x AnaTrdsSelClsBalUsdActNeq) Xpr()          {}
func (x AnaTrdsSelClsBalUsdActNeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelClsBalUsdActLss) Xpr()          {}
func (x AnaTrdsSelClsBalUsdActLss) AnaTrdsXpr()   {}
func (x AnaTrdsSelClsBalUsdActGtr) Xpr()          {}
func (x AnaTrdsSelClsBalUsdActGtr) AnaTrdsXpr()   {}
func (x AnaTrdsSelClsBalUsdActLeq) Xpr()          {}
func (x AnaTrdsSelClsBalUsdActLeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelClsBalUsdActGeq) Xpr()          {}
func (x AnaTrdsSelClsBalUsdActGeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelClsBalUsdEql) Xpr()             {}
func (x AnaTrdsSelClsBalUsdEql) AnaTrdsXpr()      {}
func (x AnaTrdsSelClsBalUsdNeq) Xpr()             {}
func (x AnaTrdsSelClsBalUsdNeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelClsBalUsdLss) Xpr()             {}
func (x AnaTrdsSelClsBalUsdLss) AnaTrdsXpr()      {}
func (x AnaTrdsSelClsBalUsdGtr) Xpr()             {}
func (x AnaTrdsSelClsBalUsdGtr) AnaTrdsXpr()      {}
func (x AnaTrdsSelClsBalUsdLeq) Xpr()             {}
func (x AnaTrdsSelClsBalUsdLeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelClsBalUsdGeq) Xpr()             {}
func (x AnaTrdsSelClsBalUsdGeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelOpnBalUsdEql) Xpr()             {}
func (x AnaTrdsSelOpnBalUsdEql) AnaTrdsXpr()      {}
func (x AnaTrdsSelOpnBalUsdNeq) Xpr()             {}
func (x AnaTrdsSelOpnBalUsdNeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelOpnBalUsdLss) Xpr()             {}
func (x AnaTrdsSelOpnBalUsdLss) AnaTrdsXpr()      {}
func (x AnaTrdsSelOpnBalUsdGtr) Xpr()             {}
func (x AnaTrdsSelOpnBalUsdGtr) AnaTrdsXpr()      {}
func (x AnaTrdsSelOpnBalUsdLeq) Xpr()             {}
func (x AnaTrdsSelOpnBalUsdLeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelOpnBalUsdGeq) Xpr()             {}
func (x AnaTrdsSelOpnBalUsdGeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelCstOpnSpdUsdEql) Xpr()          {}
func (x AnaTrdsSelCstOpnSpdUsdEql) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstOpnSpdUsdNeq) Xpr()          {}
func (x AnaTrdsSelCstOpnSpdUsdNeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstOpnSpdUsdLss) Xpr()          {}
func (x AnaTrdsSelCstOpnSpdUsdLss) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstOpnSpdUsdGtr) Xpr()          {}
func (x AnaTrdsSelCstOpnSpdUsdGtr) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstOpnSpdUsdLeq) Xpr()          {}
func (x AnaTrdsSelCstOpnSpdUsdLeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstOpnSpdUsdGeq) Xpr()          {}
func (x AnaTrdsSelCstOpnSpdUsdGeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstClsSpdUsdEql) Xpr()          {}
func (x AnaTrdsSelCstClsSpdUsdEql) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstClsSpdUsdNeq) Xpr()          {}
func (x AnaTrdsSelCstClsSpdUsdNeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstClsSpdUsdLss) Xpr()          {}
func (x AnaTrdsSelCstClsSpdUsdLss) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstClsSpdUsdGtr) Xpr()          {}
func (x AnaTrdsSelCstClsSpdUsdGtr) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstClsSpdUsdLeq) Xpr()          {}
func (x AnaTrdsSelCstClsSpdUsdLeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstClsSpdUsdGeq) Xpr()          {}
func (x AnaTrdsSelCstClsSpdUsdGeq) AnaTrdsXpr()   {}
func (x AnaTrdsSelCstComUsdEql) Xpr()             {}
func (x AnaTrdsSelCstComUsdEql) AnaTrdsXpr()      {}
func (x AnaTrdsSelCstComUsdNeq) Xpr()             {}
func (x AnaTrdsSelCstComUsdNeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelCstComUsdLss) Xpr()             {}
func (x AnaTrdsSelCstComUsdLss) AnaTrdsXpr()      {}
func (x AnaTrdsSelCstComUsdGtr) Xpr()             {}
func (x AnaTrdsSelCstComUsdGtr) AnaTrdsXpr()      {}
func (x AnaTrdsSelCstComUsdLeq) Xpr()             {}
func (x AnaTrdsSelCstComUsdLeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelCstComUsdGeq) Xpr()             {}
func (x AnaTrdsSelCstComUsdGeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlGrsUsdEql) Xpr()             {}
func (x AnaTrdsSelPnlGrsUsdEql) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlGrsUsdNeq) Xpr()             {}
func (x AnaTrdsSelPnlGrsUsdNeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlGrsUsdLss) Xpr()             {}
func (x AnaTrdsSelPnlGrsUsdLss) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlGrsUsdGtr) Xpr()             {}
func (x AnaTrdsSelPnlGrsUsdGtr) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlGrsUsdLeq) Xpr()             {}
func (x AnaTrdsSelPnlGrsUsdLeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlGrsUsdGeq) Xpr()             {}
func (x AnaTrdsSelPnlGrsUsdGeq) AnaTrdsXpr()      {}
func (x AnaTrdsSelPnlUsdEql) Xpr()                {}
func (x AnaTrdsSelPnlUsdEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlUsdNeq) Xpr()                {}
func (x AnaTrdsSelPnlUsdNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlUsdLss) Xpr()                {}
func (x AnaTrdsSelPnlUsdLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlUsdGtr) Xpr()                {}
func (x AnaTrdsSelPnlUsdGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlUsdLeq) Xpr()                {}
func (x AnaTrdsSelPnlUsdLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlUsdGeq) Xpr()                {}
func (x AnaTrdsSelPnlUsdGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlPctPredictEql) Xpr()         {}
func (x AnaTrdsSelPnlPctPredictEql) AnaTrdsXpr()  {}
func (x AnaTrdsSelPnlPctPredictNeq) Xpr()         {}
func (x AnaTrdsSelPnlPctPredictNeq) AnaTrdsXpr()  {}
func (x AnaTrdsSelPnlPctPredictLss) Xpr()         {}
func (x AnaTrdsSelPnlPctPredictLss) AnaTrdsXpr()  {}
func (x AnaTrdsSelPnlPctPredictGtr) Xpr()         {}
func (x AnaTrdsSelPnlPctPredictGtr) AnaTrdsXpr()  {}
func (x AnaTrdsSelPnlPctPredictLeq) Xpr()         {}
func (x AnaTrdsSelPnlPctPredictLeq) AnaTrdsXpr()  {}
func (x AnaTrdsSelPnlPctPredictGeq) Xpr()         {}
func (x AnaTrdsSelPnlPctPredictGeq) AnaTrdsXpr()  {}
func (x AnaTrdsSelPnlPctEql) Xpr()                {}
func (x AnaTrdsSelPnlPctEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlPctNeq) Xpr()                {}
func (x AnaTrdsSelPnlPctNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlPctLss) Xpr()                {}
func (x AnaTrdsSelPnlPctLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlPctGtr) Xpr()                {}
func (x AnaTrdsSelPnlPctGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlPctLeq) Xpr()                {}
func (x AnaTrdsSelPnlPctLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelPnlPctGeq) Xpr()                {}
func (x AnaTrdsSelPnlPctGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelIsLongEql) Xpr()                {}
func (x AnaTrdsSelIsLongEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelIsLongNeq) Xpr()                {}
func (x AnaTrdsSelIsLongNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelDurEql) Xpr()                   {}
func (x AnaTrdsSelDurEql) AnaTrdsXpr()            {}
func (x AnaTrdsSelDurNeq) Xpr()                   {}
func (x AnaTrdsSelDurNeq) AnaTrdsXpr()            {}
func (x AnaTrdsSelDurLss) Xpr()                   {}
func (x AnaTrdsSelDurLss) AnaTrdsXpr()            {}
func (x AnaTrdsSelDurGtr) Xpr()                   {}
func (x AnaTrdsSelDurGtr) AnaTrdsXpr()            {}
func (x AnaTrdsSelDurLeq) Xpr()                   {}
func (x AnaTrdsSelDurLeq) AnaTrdsXpr()            {}
func (x AnaTrdsSelDurGeq) Xpr()                   {}
func (x AnaTrdsSelDurGeq) AnaTrdsXpr()            {}
func (x AnaTrdsSelPipEql) Xpr()                   {}
func (x AnaTrdsSelPipEql) AnaTrdsXpr()            {}
func (x AnaTrdsSelPipNeq) Xpr()                   {}
func (x AnaTrdsSelPipNeq) AnaTrdsXpr()            {}
func (x AnaTrdsSelPipLss) Xpr()                   {}
func (x AnaTrdsSelPipLss) AnaTrdsXpr()            {}
func (x AnaTrdsSelPipGtr) Xpr()                   {}
func (x AnaTrdsSelPipGtr) AnaTrdsXpr()            {}
func (x AnaTrdsSelPipLeq) Xpr()                   {}
func (x AnaTrdsSelPipLeq) AnaTrdsXpr()            {}
func (x AnaTrdsSelPipGeq) Xpr()                   {}
func (x AnaTrdsSelPipGeq) AnaTrdsXpr()            {}
func (x AnaTrdsSelClsRsnEql) Xpr()                {}
func (x AnaTrdsSelClsRsnEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsRsnNeq) Xpr()                {}
func (x AnaTrdsSelClsRsnNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsRsnLss) Xpr()                {}
func (x AnaTrdsSelClsRsnLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsRsnGtr) Xpr()                {}
func (x AnaTrdsSelClsRsnGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsRsnLeq) Xpr()                {}
func (x AnaTrdsSelClsRsnLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsRsnGeq) Xpr()                {}
func (x AnaTrdsSelClsRsnGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsSpdEql) Xpr()                {}
func (x AnaTrdsSelClsSpdEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsSpdNeq) Xpr()                {}
func (x AnaTrdsSelClsSpdNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsSpdLss) Xpr()                {}
func (x AnaTrdsSelClsSpdLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsSpdGtr) Xpr()                {}
func (x AnaTrdsSelClsSpdGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsSpdLeq) Xpr()                {}
func (x AnaTrdsSelClsSpdLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsSpdGeq) Xpr()                {}
func (x AnaTrdsSelClsSpdGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnSpdEql) Xpr()                {}
func (x AnaTrdsSelOpnSpdEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnSpdNeq) Xpr()                {}
func (x AnaTrdsSelOpnSpdNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnSpdLss) Xpr()                {}
func (x AnaTrdsSelOpnSpdLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnSpdGtr) Xpr()                {}
func (x AnaTrdsSelOpnSpdGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnSpdLeq) Xpr()                {}
func (x AnaTrdsSelOpnSpdLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnSpdGeq) Xpr()                {}
func (x AnaTrdsSelOpnSpdGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsAskEql) Xpr()                {}
func (x AnaTrdsSelClsAskEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsAskNeq) Xpr()                {}
func (x AnaTrdsSelClsAskNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsAskLss) Xpr()                {}
func (x AnaTrdsSelClsAskLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsAskGtr) Xpr()                {}
func (x AnaTrdsSelClsAskGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsAskLeq) Xpr()                {}
func (x AnaTrdsSelClsAskLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsAskGeq) Xpr()                {}
func (x AnaTrdsSelClsAskGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnAskEql) Xpr()                {}
func (x AnaTrdsSelOpnAskEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnAskNeq) Xpr()                {}
func (x AnaTrdsSelOpnAskNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnAskLss) Xpr()                {}
func (x AnaTrdsSelOpnAskLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnAskGtr) Xpr()                {}
func (x AnaTrdsSelOpnAskGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnAskLeq) Xpr()                {}
func (x AnaTrdsSelOpnAskLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnAskGeq) Xpr()                {}
func (x AnaTrdsSelOpnAskGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBidEql) Xpr()                {}
func (x AnaTrdsSelClsBidEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBidNeq) Xpr()                {}
func (x AnaTrdsSelClsBidNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBidLss) Xpr()                {}
func (x AnaTrdsSelClsBidLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBidGtr) Xpr()                {}
func (x AnaTrdsSelClsBidGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBidLeq) Xpr()                {}
func (x AnaTrdsSelClsBidLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsBidGeq) Xpr()                {}
func (x AnaTrdsSelClsBidGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnBidEql) Xpr()                {}
func (x AnaTrdsSelOpnBidEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnBidNeq) Xpr()                {}
func (x AnaTrdsSelOpnBidNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnBidLss) Xpr()                {}
func (x AnaTrdsSelOpnBidLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnBidGtr) Xpr()                {}
func (x AnaTrdsSelOpnBidGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnBidLeq) Xpr()                {}
func (x AnaTrdsSelOpnBidLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnBidGeq) Xpr()                {}
func (x AnaTrdsSelOpnBidGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsTmeEql) Xpr()                {}
func (x AnaTrdsSelClsTmeEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsTmeNeq) Xpr()                {}
func (x AnaTrdsSelClsTmeNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsTmeLss) Xpr()                {}
func (x AnaTrdsSelClsTmeLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsTmeGtr) Xpr()                {}
func (x AnaTrdsSelClsTmeGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsTmeLeq) Xpr()                {}
func (x AnaTrdsSelClsTmeLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelClsTmeGeq) Xpr()                {}
func (x AnaTrdsSelClsTmeGeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnTmeEql) Xpr()                {}
func (x AnaTrdsSelOpnTmeEql) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnTmeNeq) Xpr()                {}
func (x AnaTrdsSelOpnTmeNeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnTmeLss) Xpr()                {}
func (x AnaTrdsSelOpnTmeLss) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnTmeGtr) Xpr()                {}
func (x AnaTrdsSelOpnTmeGtr) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnTmeLeq) Xpr()                {}
func (x AnaTrdsSelOpnTmeLeq) AnaTrdsXpr()         {}
func (x AnaTrdsSelOpnTmeGeq) Xpr()                {}
func (x AnaTrdsSelOpnTmeGeq) AnaTrdsXpr()         {}
func (x AnaTrdsOpnTmes) Xpr()                     {}
func (x AnaTrdsOpnTmes) TmesTmesXpr()             {}
func (x AnaTrdsClsTmes) Xpr()                     {}
func (x AnaTrdsClsTmes) TmesTmesXpr()             {}
func (x AnaTrdsOpnBids) Xpr()                     {}
func (x AnaTrdsOpnBids) FltsFltsXpr()             {}
func (x AnaTrdsClsBids) Xpr()                     {}
func (x AnaTrdsClsBids) FltsFltsXpr()             {}
func (x AnaTrdsOpnAsks) Xpr()                     {}
func (x AnaTrdsOpnAsks) FltsFltsXpr()             {}
func (x AnaTrdsClsAsks) Xpr()                     {}
func (x AnaTrdsClsAsks) FltsFltsXpr()             {}
func (x AnaTrdsOpnSpds) Xpr()                     {}
func (x AnaTrdsOpnSpds) FltsFltsXpr()             {}
func (x AnaTrdsClsSpds) Xpr()                     {}
func (x AnaTrdsClsSpds) FltsFltsXpr()             {}
func (x AnaTrdsClsRsns) Xpr()                     {}
func (x AnaTrdsClsRsns) StrsStrsXpr()             {}
func (x AnaTrdsPips) Xpr()                        {}
func (x AnaTrdsPips) FltsFltsXpr()                {}
func (x AnaTrdsDurs) Xpr()                        {}
func (x AnaTrdsDurs) TmesTmesXpr()                {}
func (x AnaTrdsIsLongs) Xpr()                     {}
func (x AnaTrdsIsLongs) BolsBolsXpr()             {}
func (x AnaTrdsPnlPcts) Xpr()                     {}
func (x AnaTrdsPnlPcts) FltsFltsXpr()             {}
func (x AnaTrdsPnlPctPredicts) Xpr()              {}
func (x AnaTrdsPnlPctPredicts) FltsFltsXpr()      {}
func (x AnaTrdsPnlUsds) Xpr()                     {}
func (x AnaTrdsPnlUsds) FltsFltsXpr()             {}
func (x AnaTrdsPnlGrsUsds) Xpr()                  {}
func (x AnaTrdsPnlGrsUsds) FltsFltsXpr()          {}
func (x AnaTrdsCstComUsds) Xpr()                  {}
func (x AnaTrdsCstComUsds) FltsFltsXpr()          {}
func (x AnaTrdsCstClsSpdUsds) Xpr()               {}
func (x AnaTrdsCstClsSpdUsds) FltsFltsXpr()       {}
func (x AnaTrdsCstOpnSpdUsds) Xpr()               {}
func (x AnaTrdsCstOpnSpdUsds) FltsFltsXpr()       {}
func (x AnaTrdsOpnBalUsds) Xpr()                  {}
func (x AnaTrdsOpnBalUsds) FltsFltsXpr()          {}
func (x AnaTrdsClsBalUsds) Xpr()                  {}
func (x AnaTrdsClsBalUsds) FltsFltsXpr()          {}
func (x AnaTrdsClsBalUsdActs) Xpr()               {}
func (x AnaTrdsClsBalUsdActs) FltsFltsXpr()       {}
func (x AnaTrdsTrdPcts) Xpr()                     {}
func (x AnaTrdsTrdPcts) FltsFltsXpr()             {}
func (x AnaTrdsMrgnRtios) Xpr()                   {}
func (x AnaTrdsMrgnRtios) FltsFltsXpr()           {}
func (x AnaTrdsUnitss) Xpr()                      {}
func (x AnaTrdsUnitss) FltsFltsXpr()              {}
func (x AnaTrdsInstrs) Xpr()                      {}
func (x AnaTrdsInstrs) StrsStrsXpr()              {}
func (x AnaTrdsOpnReqs) Xpr()                     {}
func (x AnaTrdsOpnReqs) StrsStrsXpr()             {}
func (x AnaTrdsOpnRess) Xpr()                     {}
func (x AnaTrdsOpnRess) StrsStrsXpr()             {}
func (x AnaTrdsClsReqs) Xpr()                     {}
func (x AnaTrdsClsReqs) StrsStrsXpr()             {}
func (x AnaTrdsClsRess) Xpr()                     {}
func (x AnaTrdsClsRess) StrsStrsXpr()             {}
func (x AnaPrfmDlt) Xpr()                         {}
func (x AnaPrfmDlt) AnaPrfmDltXpr()               {}
func (x AnaPrfmsCnt) Xpr()                        {}
func (x AnaPrfmsCnt) UntUntXpr()                  {}
func (x AnaPrfmsCpy) Xpr()                        {}
func (x AnaPrfmsCpy) AnaPrfmsXpr()                {}
func (x AnaPrfmsClr) Xpr()                        {}
func (x AnaPrfmsClr) AnaPrfmsXpr()                {}
func (x AnaPrfmsRand) Xpr()                       {}
func (x AnaPrfmsRand) AnaPrfmsXpr()               {}
func (x AnaPrfmsMrg) Xpr()                        {}
func (x AnaPrfmsMrg) AnaPrfmsXpr()                {}
func (x AnaPrfmsPush) Xpr()                       {}
func (x AnaPrfmsPush) AnaPrfmsXpr()               {}
func (x AnaPrfmsPop) Xpr()                        {}
func (x AnaPrfmsPop) AnaPrfmXpr()                 {}
func (x AnaPrfmsQue) Xpr()                        {}
func (x AnaPrfmsQue) AnaPrfmsXpr()                {}
func (x AnaPrfmsDque) Xpr()                       {}
func (x AnaPrfmsDque) AnaPrfmXpr()                {}
func (x AnaPrfmsIns) Xpr()                        {}
func (x AnaPrfmsIns) AnaPrfmsXpr()                {}
func (x AnaPrfmsUpd) Xpr()                        {}
func (x AnaPrfmsUpd) AnaPrfmsXpr()                {}
func (x AnaPrfmsDel) Xpr()                        {}
func (x AnaPrfmsDel) AnaPrfmXpr()                 {}
func (x AnaPrfmsAt) Xpr()                         {}
func (x AnaPrfmsAt) AnaPrfmXpr()                  {}
func (x AnaPrfmsIn) Xpr()                         {}
func (x AnaPrfmsIn) AnaPrfmsXpr()                 {}
func (x AnaPrfmsInBnd) Xpr()                      {}
func (x AnaPrfmsInBnd) AnaPrfmsXpr()              {}
func (x AnaPrfmsFrom) Xpr()                       {}
func (x AnaPrfmsFrom) AnaPrfmsXpr()               {}
func (x AnaPrfmsTo) Xpr()                         {}
func (x AnaPrfmsTo) AnaPrfmsXpr()                 {}
func (x AnaPrfmsFst) Xpr()                        {}
func (x AnaPrfmsFst) AnaPrfmXpr()                 {}
func (x AnaPrfmsMdl) Xpr()                        {}
func (x AnaPrfmsMdl) AnaPrfmXpr()                 {}
func (x AnaPrfmsLst) Xpr()                        {}
func (x AnaPrfmsLst) AnaPrfmXpr()                 {}
func (x AnaPrfmsFstIdx) Xpr()                     {}
func (x AnaPrfmsFstIdx) UntUntXpr()               {}
func (x AnaPrfmsMdlIdx) Xpr()                     {}
func (x AnaPrfmsMdlIdx) UntUntXpr()               {}
func (x AnaPrfmsLstIdx) Xpr()                     {}
func (x AnaPrfmsLstIdx) UntUntXpr()               {}
func (x AnaPrfmsRev) Xpr()                        {}
func (x AnaPrfmsRev) AnaPrfmsXpr()                {}
func (x AnaPrfmsPnlPcts) Xpr()                    {}
func (x AnaPrfmsPnlPcts) FltsFltsXpr()            {}
func (x AnaPrfmsScsPcts) Xpr()                    {}
func (x AnaPrfmsScsPcts) FltsFltsXpr()            {}
func (x AnaPrfmsPipPerDays) Xpr()                 {}
func (x AnaPrfmsPipPerDays) FltsFltsXpr()         {}
func (x AnaPrfmsUsdPerDays) Xpr()                 {}
func (x AnaPrfmsUsdPerDays) FltsFltsXpr()         {}
func (x AnaPrfmsScsPerDays) Xpr()                 {}
func (x AnaPrfmsScsPerDays) FltsFltsXpr()         {}
func (x AnaPrfmsOpnPerDays) Xpr()                 {}
func (x AnaPrfmsOpnPerDays) FltsFltsXpr()         {}
func (x AnaPrfmsPnlUsds) Xpr()                    {}
func (x AnaPrfmsPnlUsds) FltsFltsXpr()            {}
func (x AnaPrfmsPipAvgs) Xpr()                    {}
func (x AnaPrfmsPipAvgs) FltsFltsXpr()            {}
func (x AnaPrfmsPipMdns) Xpr()                    {}
func (x AnaPrfmsPipMdns) FltsFltsXpr()            {}
func (x AnaPrfmsPipMins) Xpr()                    {}
func (x AnaPrfmsPipMins) FltsFltsXpr()            {}
func (x AnaPrfmsPipMaxs) Xpr()                    {}
func (x AnaPrfmsPipMaxs) FltsFltsXpr()            {}
func (x AnaPrfmsPipSums) Xpr()                    {}
func (x AnaPrfmsPipSums) FltsFltsXpr()            {}
func (x AnaPrfmsDurAvgs) Xpr()                    {}
func (x AnaPrfmsDurAvgs) TmesTmesXpr()            {}
func (x AnaPrfmsDurMdns) Xpr()                    {}
func (x AnaPrfmsDurMdns) TmesTmesXpr()            {}
func (x AnaPrfmsDurMins) Xpr()                    {}
func (x AnaPrfmsDurMins) TmesTmesXpr()            {}
func (x AnaPrfmsDurMaxs) Xpr()                    {}
func (x AnaPrfmsDurMaxs) TmesTmesXpr()            {}
func (x AnaPrfmsLosLimMaxs) Xpr()                 {}
func (x AnaPrfmsLosLimMaxs) FltsFltsXpr()         {}
func (x AnaPrfmsDurLimMaxs) Xpr()                 {}
func (x AnaPrfmsDurLimMaxs) TmesTmesXpr()         {}
func (x AnaPrfmsDayCnts) Xpr()                    {}
func (x AnaPrfmsDayCnts) UntsUntsXpr()            {}
func (x AnaPrfmsTrdCnts) Xpr()                    {}
func (x AnaPrfmsTrdCnts) UntsUntsXpr()            {}
func (x AnaPrfmsTrdPcts) Xpr()                    {}
func (x AnaPrfmsTrdPcts) FltsFltsXpr()            {}
func (x AnaPrfmsCstTotUsds) Xpr()                 {}
func (x AnaPrfmsCstTotUsds) FltsFltsXpr()         {}
func (x AnaPrfmsCstSpdUsds) Xpr()                 {}
func (x AnaPrfmsCstSpdUsds) FltsFltsXpr()         {}
func (x AnaPrfmsCstComUsds) Xpr()                 {}
func (x AnaPrfmsCstComUsds) FltsFltsXpr()         {}
func (x AnaPrfmsPths) Xpr()                       {}
func (x AnaPrfmsPths) StrsStrsXpr()               {}
func (x HstPrvsCnt) Xpr()                         {}
func (x HstPrvsCnt) UntUntXpr()                   {}
func (x HstPrvsCpy) Xpr()                         {}
func (x HstPrvsCpy) HstPrvsXpr()                  {}
func (x HstPrvsClr) Xpr()                         {}
func (x HstPrvsClr) HstPrvsXpr()                  {}
func (x HstPrvsRand) Xpr()                        {}
func (x HstPrvsRand) HstPrvsXpr()                 {}
func (x HstPrvsMrg) Xpr()                         {}
func (x HstPrvsMrg) HstPrvsXpr()                  {}
func (x HstPrvsPush) Xpr()                        {}
func (x HstPrvsPush) HstPrvsXpr()                 {}
func (x HstPrvsPop) Xpr()                         {}
func (x HstPrvsPop) HstPrvXpr()                   {}
func (x HstPrvsQue) Xpr()                         {}
func (x HstPrvsQue) HstPrvsXpr()                  {}
func (x HstPrvsDque) Xpr()                        {}
func (x HstPrvsDque) HstPrvXpr()                  {}
func (x HstPrvsIns) Xpr()                         {}
func (x HstPrvsIns) HstPrvsXpr()                  {}
func (x HstPrvsUpd) Xpr()                         {}
func (x HstPrvsUpd) HstPrvsXpr()                  {}
func (x HstPrvsDel) Xpr()                         {}
func (x HstPrvsDel) HstPrvXpr()                   {}
func (x HstPrvsAt) Xpr()                          {}
func (x HstPrvsAt) HstPrvXpr()                    {}
func (x HstPrvsIn) Xpr()                          {}
func (x HstPrvsIn) HstPrvsXpr()                   {}
func (x HstPrvsInBnd) Xpr()                       {}
func (x HstPrvsInBnd) HstPrvsXpr()                {}
func (x HstPrvsFrom) Xpr()                        {}
func (x HstPrvsFrom) HstPrvsXpr()                 {}
func (x HstPrvsTo) Xpr()                          {}
func (x HstPrvsTo) HstPrvsXpr()                   {}
func (x HstPrvsFst) Xpr()                         {}
func (x HstPrvsFst) HstPrvXpr()                   {}
func (x HstPrvsMdl) Xpr()                         {}
func (x HstPrvsMdl) HstPrvXpr()                   {}
func (x HstPrvsLst) Xpr()                         {}
func (x HstPrvsLst) HstPrvXpr()                   {}
func (x HstPrvsFstIdx) Xpr()                      {}
func (x HstPrvsFstIdx) UntUntXpr()                {}
func (x HstPrvsMdlIdx) Xpr()                      {}
func (x HstPrvsMdlIdx) UntUntXpr()                {}
func (x HstPrvsLstIdx) Xpr()                      {}
func (x HstPrvsLstIdx) UntUntXpr()                {}
func (x HstPrvsRev) Xpr()                         {}
func (x HstPrvsRev) HstPrvsXpr()                  {}
func (x HstInstrsCnt) Xpr()                       {}
func (x HstInstrsCnt) UntUntXpr()                 {}
func (x HstInstrsCpy) Xpr()                       {}
func (x HstInstrsCpy) HstInstrsXpr()              {}
func (x HstInstrsClr) Xpr()                       {}
func (x HstInstrsClr) HstInstrsXpr()              {}
func (x HstInstrsRand) Xpr()                      {}
func (x HstInstrsRand) HstInstrsXpr()             {}
func (x HstInstrsMrg) Xpr()                       {}
func (x HstInstrsMrg) HstInstrsXpr()              {}
func (x HstInstrsPush) Xpr()                      {}
func (x HstInstrsPush) HstInstrsXpr()             {}
func (x HstInstrsPop) Xpr()                       {}
func (x HstInstrsPop) HstInstrXpr()               {}
func (x HstInstrsQue) Xpr()                       {}
func (x HstInstrsQue) HstInstrsXpr()              {}
func (x HstInstrsDque) Xpr()                      {}
func (x HstInstrsDque) HstInstrXpr()              {}
func (x HstInstrsIns) Xpr()                       {}
func (x HstInstrsIns) HstInstrsXpr()              {}
func (x HstInstrsUpd) Xpr()                       {}
func (x HstInstrsUpd) HstInstrsXpr()              {}
func (x HstInstrsDel) Xpr()                       {}
func (x HstInstrsDel) HstInstrXpr()               {}
func (x HstInstrsAt) Xpr()                        {}
func (x HstInstrsAt) HstInstrXpr()                {}
func (x HstInstrsIn) Xpr()                        {}
func (x HstInstrsIn) HstInstrsXpr()               {}
func (x HstInstrsInBnd) Xpr()                     {}
func (x HstInstrsInBnd) HstInstrsXpr()            {}
func (x HstInstrsFrom) Xpr()                      {}
func (x HstInstrsFrom) HstInstrsXpr()             {}
func (x HstInstrsTo) Xpr()                        {}
func (x HstInstrsTo) HstInstrsXpr()               {}
func (x HstInstrsFst) Xpr()                       {}
func (x HstInstrsFst) HstInstrXpr()               {}
func (x HstInstrsMdl) Xpr()                       {}
func (x HstInstrsMdl) HstInstrXpr()               {}
func (x HstInstrsLst) Xpr()                       {}
func (x HstInstrsLst) HstInstrXpr()               {}
func (x HstInstrsFstIdx) Xpr()                    {}
func (x HstInstrsFstIdx) UntUntXpr()              {}
func (x HstInstrsMdlIdx) Xpr()                    {}
func (x HstInstrsMdlIdx) UntUntXpr()              {}
func (x HstInstrsLstIdx) Xpr()                    {}
func (x HstInstrsLstIdx) UntUntXpr()              {}
func (x HstInstrsRev) Xpr()                       {}
func (x HstInstrsRev) HstInstrsXpr()              {}
func (x HstInrvlsCnt) Xpr()                       {}
func (x HstInrvlsCnt) UntUntXpr()                 {}
func (x HstInrvlsCpy) Xpr()                       {}
func (x HstInrvlsCpy) HstInrvlsXpr()              {}
func (x HstInrvlsClr) Xpr()                       {}
func (x HstInrvlsClr) HstInrvlsXpr()              {}
func (x HstInrvlsRand) Xpr()                      {}
func (x HstInrvlsRand) HstInrvlsXpr()             {}
func (x HstInrvlsMrg) Xpr()                       {}
func (x HstInrvlsMrg) HstInrvlsXpr()              {}
func (x HstInrvlsPush) Xpr()                      {}
func (x HstInrvlsPush) HstInrvlsXpr()             {}
func (x HstInrvlsPop) Xpr()                       {}
func (x HstInrvlsPop) HstInrvlXpr()               {}
func (x HstInrvlsQue) Xpr()                       {}
func (x HstInrvlsQue) HstInrvlsXpr()              {}
func (x HstInrvlsDque) Xpr()                      {}
func (x HstInrvlsDque) HstInrvlXpr()              {}
func (x HstInrvlsIns) Xpr()                       {}
func (x HstInrvlsIns) HstInrvlsXpr()              {}
func (x HstInrvlsUpd) Xpr()                       {}
func (x HstInrvlsUpd) HstInrvlsXpr()              {}
func (x HstInrvlsDel) Xpr()                       {}
func (x HstInrvlsDel) HstInrvlXpr()               {}
func (x HstInrvlsAt) Xpr()                        {}
func (x HstInrvlsAt) HstInrvlXpr()                {}
func (x HstInrvlsIn) Xpr()                        {}
func (x HstInrvlsIn) HstInrvlsXpr()               {}
func (x HstInrvlsInBnd) Xpr()                     {}
func (x HstInrvlsInBnd) HstInrvlsXpr()            {}
func (x HstInrvlsFrom) Xpr()                      {}
func (x HstInrvlsFrom) HstInrvlsXpr()             {}
func (x HstInrvlsTo) Xpr()                        {}
func (x HstInrvlsTo) HstInrvlsXpr()               {}
func (x HstInrvlsFst) Xpr()                       {}
func (x HstInrvlsFst) HstInrvlXpr()               {}
func (x HstInrvlsMdl) Xpr()                       {}
func (x HstInrvlsMdl) HstInrvlXpr()               {}
func (x HstInrvlsLst) Xpr()                       {}
func (x HstInrvlsLst) HstInrvlXpr()               {}
func (x HstInrvlsFstIdx) Xpr()                    {}
func (x HstInrvlsFstIdx) UntUntXpr()              {}
func (x HstInrvlsMdlIdx) Xpr()                    {}
func (x HstInrvlsMdlIdx) UntUntXpr()              {}
func (x HstInrvlsLstIdx) Xpr()                    {}
func (x HstInrvlsLstIdx) UntUntXpr()              {}
func (x HstInrvlsRev) Xpr()                       {}
func (x HstInrvlsRev) HstInrvlsXpr()              {}
func (x HstSidesCnt) Xpr()                        {}
func (x HstSidesCnt) UntUntXpr()                  {}
func (x HstSidesCpy) Xpr()                        {}
func (x HstSidesCpy) HstSidesXpr()                {}
func (x HstSidesClr) Xpr()                        {}
func (x HstSidesClr) HstSidesXpr()                {}
func (x HstSidesRand) Xpr()                       {}
func (x HstSidesRand) HstSidesXpr()               {}
func (x HstSidesMrg) Xpr()                        {}
func (x HstSidesMrg) HstSidesXpr()                {}
func (x HstSidesPush) Xpr()                       {}
func (x HstSidesPush) HstSidesXpr()               {}
func (x HstSidesPop) Xpr()                        {}
func (x HstSidesPop) HstSideXpr()                 {}
func (x HstSidesQue) Xpr()                        {}
func (x HstSidesQue) HstSidesXpr()                {}
func (x HstSidesDque) Xpr()                       {}
func (x HstSidesDque) HstSideXpr()                {}
func (x HstSidesIns) Xpr()                        {}
func (x HstSidesIns) HstSidesXpr()                {}
func (x HstSidesUpd) Xpr()                        {}
func (x HstSidesUpd) HstSidesXpr()                {}
func (x HstSidesDel) Xpr()                        {}
func (x HstSidesDel) HstSideXpr()                 {}
func (x HstSidesAt) Xpr()                         {}
func (x HstSidesAt) HstSideXpr()                  {}
func (x HstSidesIn) Xpr()                         {}
func (x HstSidesIn) HstSidesXpr()                 {}
func (x HstSidesInBnd) Xpr()                      {}
func (x HstSidesInBnd) HstSidesXpr()              {}
func (x HstSidesFrom) Xpr()                       {}
func (x HstSidesFrom) HstSidesXpr()               {}
func (x HstSidesTo) Xpr()                         {}
func (x HstSidesTo) HstSidesXpr()                 {}
func (x HstSidesFst) Xpr()                        {}
func (x HstSidesFst) HstSideXpr()                 {}
func (x HstSidesMdl) Xpr()                        {}
func (x HstSidesMdl) HstSideXpr()                 {}
func (x HstSidesLst) Xpr()                        {}
func (x HstSidesLst) HstSideXpr()                 {}
func (x HstSidesFstIdx) Xpr()                     {}
func (x HstSidesFstIdx) UntUntXpr()               {}
func (x HstSidesMdlIdx) Xpr()                     {}
func (x HstSidesMdlIdx) UntUntXpr()               {}
func (x HstSidesLstIdx) Xpr()                     {}
func (x HstSidesLstIdx) UntUntXpr()               {}
func (x HstSidesRev) Xpr()                        {}
func (x HstSidesRev) HstSidesXpr()                {}
func (x HstStmsCnt) Xpr()                         {}
func (x HstStmsCnt) UntUntXpr()                   {}
func (x HstStmsCpy) Xpr()                         {}
func (x HstStmsCpy) HstStmsXpr()                  {}
func (x HstStmsClr) Xpr()                         {}
func (x HstStmsClr) HstStmsXpr()                  {}
func (x HstStmsRand) Xpr()                        {}
func (x HstStmsRand) HstStmsXpr()                 {}
func (x HstStmsMrg) Xpr()                         {}
func (x HstStmsMrg) HstStmsXpr()                  {}
func (x HstStmsPush) Xpr()                        {}
func (x HstStmsPush) HstStmsXpr()                 {}
func (x HstStmsPop) Xpr()                         {}
func (x HstStmsPop) HstStmXpr()                   {}
func (x HstStmsQue) Xpr()                         {}
func (x HstStmsQue) HstStmsXpr()                  {}
func (x HstStmsDque) Xpr()                        {}
func (x HstStmsDque) HstStmXpr()                  {}
func (x HstStmsIns) Xpr()                         {}
func (x HstStmsIns) HstStmsXpr()                  {}
func (x HstStmsUpd) Xpr()                         {}
func (x HstStmsUpd) HstStmsXpr()                  {}
func (x HstStmsDel) Xpr()                         {}
func (x HstStmsDel) HstStmXpr()                   {}
func (x HstStmsAt) Xpr()                          {}
func (x HstStmsAt) HstStmXpr()                    {}
func (x HstStmsIn) Xpr()                          {}
func (x HstStmsIn) HstStmsXpr()                   {}
func (x HstStmsInBnd) Xpr()                       {}
func (x HstStmsInBnd) HstStmsXpr()                {}
func (x HstStmsFrom) Xpr()                        {}
func (x HstStmsFrom) HstStmsXpr()                 {}
func (x HstStmsTo) Xpr()                          {}
func (x HstStmsTo) HstStmsXpr()                   {}
func (x HstStmsFst) Xpr()                         {}
func (x HstStmsFst) HstStmXpr()                   {}
func (x HstStmsMdl) Xpr()                         {}
func (x HstStmsMdl) HstStmXpr()                   {}
func (x HstStmsLst) Xpr()                         {}
func (x HstStmsLst) HstStmXpr()                   {}
func (x HstStmsFstIdx) Xpr()                      {}
func (x HstStmsFstIdx) UntUntXpr()                {}
func (x HstStmsMdlIdx) Xpr()                      {}
func (x HstStmsMdlIdx) UntUntXpr()                {}
func (x HstStmsLstIdx) Xpr()                      {}
func (x HstStmsLstIdx) UntUntXpr()                {}
func (x HstStmsRev) Xpr()                         {}
func (x HstStmsRev) HstStmsXpr()                  {}
func (x HstCndsCnt) Xpr()                         {}
func (x HstCndsCnt) UntUntXpr()                   {}
func (x HstCndsCpy) Xpr()                         {}
func (x HstCndsCpy) HstCndsXpr()                  {}
func (x HstCndsClr) Xpr()                         {}
func (x HstCndsClr) HstCndsXpr()                  {}
func (x HstCndsRand) Xpr()                        {}
func (x HstCndsRand) HstCndsXpr()                 {}
func (x HstCndsMrg) Xpr()                         {}
func (x HstCndsMrg) HstCndsXpr()                  {}
func (x HstCndsPush) Xpr()                        {}
func (x HstCndsPush) HstCndsXpr()                 {}
func (x HstCndsPop) Xpr()                         {}
func (x HstCndsPop) HstCndXpr()                   {}
func (x HstCndsQue) Xpr()                         {}
func (x HstCndsQue) HstCndsXpr()                  {}
func (x HstCndsDque) Xpr()                        {}
func (x HstCndsDque) HstCndXpr()                  {}
func (x HstCndsIns) Xpr()                         {}
func (x HstCndsIns) HstCndsXpr()                  {}
func (x HstCndsUpd) Xpr()                         {}
func (x HstCndsUpd) HstCndsXpr()                  {}
func (x HstCndsDel) Xpr()                         {}
func (x HstCndsDel) HstCndXpr()                   {}
func (x HstCndsAt) Xpr()                          {}
func (x HstCndsAt) HstCndXpr()                    {}
func (x HstCndsIn) Xpr()                          {}
func (x HstCndsIn) HstCndsXpr()                   {}
func (x HstCndsInBnd) Xpr()                       {}
func (x HstCndsInBnd) HstCndsXpr()                {}
func (x HstCndsFrom) Xpr()                        {}
func (x HstCndsFrom) HstCndsXpr()                 {}
func (x HstCndsTo) Xpr()                          {}
func (x HstCndsTo) HstCndsXpr()                   {}
func (x HstCndsFst) Xpr()                         {}
func (x HstCndsFst) HstCndXpr()                   {}
func (x HstCndsMdl) Xpr()                         {}
func (x HstCndsMdl) HstCndXpr()                   {}
func (x HstCndsLst) Xpr()                         {}
func (x HstCndsLst) HstCndXpr()                   {}
func (x HstCndsFstIdx) Xpr()                      {}
func (x HstCndsFstIdx) UntUntXpr()                {}
func (x HstCndsMdlIdx) Xpr()                      {}
func (x HstCndsMdlIdx) UntUntXpr()                {}
func (x HstCndsLstIdx) Xpr()                      {}
func (x HstCndsLstIdx) UntUntXpr()                {}
func (x HstCndsRev) Xpr()                         {}
func (x HstCndsRev) HstCndsXpr()                  {}
func (x HstStgysCnt) Xpr()                        {}
func (x HstStgysCnt) UntUntXpr()                  {}
func (x HstStgysCpy) Xpr()                        {}
func (x HstStgysCpy) HstStgysXpr()                {}
func (x HstStgysClr) Xpr()                        {}
func (x HstStgysClr) HstStgysXpr()                {}
func (x HstStgysRand) Xpr()                       {}
func (x HstStgysRand) HstStgysXpr()               {}
func (x HstStgysMrg) Xpr()                        {}
func (x HstStgysMrg) HstStgysXpr()                {}
func (x HstStgysPush) Xpr()                       {}
func (x HstStgysPush) HstStgysXpr()               {}
func (x HstStgysPop) Xpr()                        {}
func (x HstStgysPop) HstStgyXpr()                 {}
func (x HstStgysQue) Xpr()                        {}
func (x HstStgysQue) HstStgysXpr()                {}
func (x HstStgysDque) Xpr()                       {}
func (x HstStgysDque) HstStgyXpr()                {}
func (x HstStgysIns) Xpr()                        {}
func (x HstStgysIns) HstStgysXpr()                {}
func (x HstStgysUpd) Xpr()                        {}
func (x HstStgysUpd) HstStgysXpr()                {}
func (x HstStgysDel) Xpr()                        {}
func (x HstStgysDel) HstStgyXpr()                 {}
func (x HstStgysAt) Xpr()                         {}
func (x HstStgysAt) HstStgyXpr()                  {}
func (x HstStgysIn) Xpr()                         {}
func (x HstStgysIn) HstStgysXpr()                 {}
func (x HstStgysInBnd) Xpr()                      {}
func (x HstStgysInBnd) HstStgysXpr()              {}
func (x HstStgysFrom) Xpr()                       {}
func (x HstStgysFrom) HstStgysXpr()               {}
func (x HstStgysTo) Xpr()                         {}
func (x HstStgysTo) HstStgysXpr()                 {}
func (x HstStgysFst) Xpr()                        {}
func (x HstStgysFst) HstStgyXpr()                 {}
func (x HstStgysMdl) Xpr()                        {}
func (x HstStgysMdl) HstStgyXpr()                 {}
func (x HstStgysLst) Xpr()                        {}
func (x HstStgysLst) HstStgyXpr()                 {}
func (x HstStgysFstIdx) Xpr()                     {}
func (x HstStgysFstIdx) UntUntXpr()               {}
func (x HstStgysMdlIdx) Xpr()                     {}
func (x HstStgysMdlIdx) UntUntXpr()               {}
func (x HstStgysLstIdx) Xpr()                     {}
func (x HstStgysLstIdx) UntUntXpr()               {}
func (x HstStgysRev) Xpr()                        {}
func (x HstStgysRev) HstStgysXpr()                {}
func (x RltPrvsCnt) Xpr()                         {}
func (x RltPrvsCnt) UntUntXpr()                   {}
func (x RltPrvsCpy) Xpr()                         {}
func (x RltPrvsCpy) RltPrvsXpr()                  {}
func (x RltPrvsClr) Xpr()                         {}
func (x RltPrvsClr) RltPrvsXpr()                  {}
func (x RltPrvsRand) Xpr()                        {}
func (x RltPrvsRand) RltPrvsXpr()                 {}
func (x RltPrvsMrg) Xpr()                         {}
func (x RltPrvsMrg) RltPrvsXpr()                  {}
func (x RltPrvsPush) Xpr()                        {}
func (x RltPrvsPush) RltPrvsXpr()                 {}
func (x RltPrvsPop) Xpr()                         {}
func (x RltPrvsPop) RltPrvXpr()                   {}
func (x RltPrvsQue) Xpr()                         {}
func (x RltPrvsQue) RltPrvsXpr()                  {}
func (x RltPrvsDque) Xpr()                        {}
func (x RltPrvsDque) RltPrvXpr()                  {}
func (x RltPrvsIns) Xpr()                         {}
func (x RltPrvsIns) RltPrvsXpr()                  {}
func (x RltPrvsUpd) Xpr()                         {}
func (x RltPrvsUpd) RltPrvsXpr()                  {}
func (x RltPrvsDel) Xpr()                         {}
func (x RltPrvsDel) RltPrvXpr()                   {}
func (x RltPrvsAt) Xpr()                          {}
func (x RltPrvsAt) RltPrvXpr()                    {}
func (x RltPrvsIn) Xpr()                          {}
func (x RltPrvsIn) RltPrvsXpr()                   {}
func (x RltPrvsInBnd) Xpr()                       {}
func (x RltPrvsInBnd) RltPrvsXpr()                {}
func (x RltPrvsFrom) Xpr()                        {}
func (x RltPrvsFrom) RltPrvsXpr()                 {}
func (x RltPrvsTo) Xpr()                          {}
func (x RltPrvsTo) RltPrvsXpr()                   {}
func (x RltPrvsFst) Xpr()                         {}
func (x RltPrvsFst) RltPrvXpr()                   {}
func (x RltPrvsMdl) Xpr()                         {}
func (x RltPrvsMdl) RltPrvXpr()                   {}
func (x RltPrvsLst) Xpr()                         {}
func (x RltPrvsLst) RltPrvXpr()                   {}
func (x RltPrvsFstIdx) Xpr()                      {}
func (x RltPrvsFstIdx) UntUntXpr()                {}
func (x RltPrvsMdlIdx) Xpr()                      {}
func (x RltPrvsMdlIdx) UntUntXpr()                {}
func (x RltPrvsLstIdx) Xpr()                      {}
func (x RltPrvsLstIdx) UntUntXpr()                {}
func (x RltPrvsRev) Xpr()                         {}
func (x RltPrvsRev) RltPrvsXpr()                  {}
func (x RltInstrsCnt) Xpr()                       {}
func (x RltInstrsCnt) UntUntXpr()                 {}
func (x RltInstrsCpy) Xpr()                       {}
func (x RltInstrsCpy) RltInstrsXpr()              {}
func (x RltInstrsClr) Xpr()                       {}
func (x RltInstrsClr) RltInstrsXpr()              {}
func (x RltInstrsRand) Xpr()                      {}
func (x RltInstrsRand) RltInstrsXpr()             {}
func (x RltInstrsMrg) Xpr()                       {}
func (x RltInstrsMrg) RltInstrsXpr()              {}
func (x RltInstrsPush) Xpr()                      {}
func (x RltInstrsPush) RltInstrsXpr()             {}
func (x RltInstrsPop) Xpr()                       {}
func (x RltInstrsPop) RltInstrXpr()               {}
func (x RltInstrsQue) Xpr()                       {}
func (x RltInstrsQue) RltInstrsXpr()              {}
func (x RltInstrsDque) Xpr()                      {}
func (x RltInstrsDque) RltInstrXpr()              {}
func (x RltInstrsIns) Xpr()                       {}
func (x RltInstrsIns) RltInstrsXpr()              {}
func (x RltInstrsUpd) Xpr()                       {}
func (x RltInstrsUpd) RltInstrsXpr()              {}
func (x RltInstrsDel) Xpr()                       {}
func (x RltInstrsDel) RltInstrXpr()               {}
func (x RltInstrsAt) Xpr()                        {}
func (x RltInstrsAt) RltInstrXpr()                {}
func (x RltInstrsIn) Xpr()                        {}
func (x RltInstrsIn) RltInstrsXpr()               {}
func (x RltInstrsInBnd) Xpr()                     {}
func (x RltInstrsInBnd) RltInstrsXpr()            {}
func (x RltInstrsFrom) Xpr()                      {}
func (x RltInstrsFrom) RltInstrsXpr()             {}
func (x RltInstrsTo) Xpr()                        {}
func (x RltInstrsTo) RltInstrsXpr()               {}
func (x RltInstrsFst) Xpr()                       {}
func (x RltInstrsFst) RltInstrXpr()               {}
func (x RltInstrsMdl) Xpr()                       {}
func (x RltInstrsMdl) RltInstrXpr()               {}
func (x RltInstrsLst) Xpr()                       {}
func (x RltInstrsLst) RltInstrXpr()               {}
func (x RltInstrsFstIdx) Xpr()                    {}
func (x RltInstrsFstIdx) UntUntXpr()              {}
func (x RltInstrsMdlIdx) Xpr()                    {}
func (x RltInstrsMdlIdx) UntUntXpr()              {}
func (x RltInstrsLstIdx) Xpr()                    {}
func (x RltInstrsLstIdx) UntUntXpr()              {}
func (x RltInstrsRev) Xpr()                       {}
func (x RltInstrsRev) RltInstrsXpr()              {}
func (x RltInrvlsCnt) Xpr()                       {}
func (x RltInrvlsCnt) UntUntXpr()                 {}
func (x RltInrvlsCpy) Xpr()                       {}
func (x RltInrvlsCpy) RltInrvlsXpr()              {}
func (x RltInrvlsClr) Xpr()                       {}
func (x RltInrvlsClr) RltInrvlsXpr()              {}
func (x RltInrvlsRand) Xpr()                      {}
func (x RltInrvlsRand) RltInrvlsXpr()             {}
func (x RltInrvlsMrg) Xpr()                       {}
func (x RltInrvlsMrg) RltInrvlsXpr()              {}
func (x RltInrvlsPush) Xpr()                      {}
func (x RltInrvlsPush) RltInrvlsXpr()             {}
func (x RltInrvlsPop) Xpr()                       {}
func (x RltInrvlsPop) RltInrvlXpr()               {}
func (x RltInrvlsQue) Xpr()                       {}
func (x RltInrvlsQue) RltInrvlsXpr()              {}
func (x RltInrvlsDque) Xpr()                      {}
func (x RltInrvlsDque) RltInrvlXpr()              {}
func (x RltInrvlsIns) Xpr()                       {}
func (x RltInrvlsIns) RltInrvlsXpr()              {}
func (x RltInrvlsUpd) Xpr()                       {}
func (x RltInrvlsUpd) RltInrvlsXpr()              {}
func (x RltInrvlsDel) Xpr()                       {}
func (x RltInrvlsDel) RltInrvlXpr()               {}
func (x RltInrvlsAt) Xpr()                        {}
func (x RltInrvlsAt) RltInrvlXpr()                {}
func (x RltInrvlsIn) Xpr()                        {}
func (x RltInrvlsIn) RltInrvlsXpr()               {}
func (x RltInrvlsInBnd) Xpr()                     {}
func (x RltInrvlsInBnd) RltInrvlsXpr()            {}
func (x RltInrvlsFrom) Xpr()                      {}
func (x RltInrvlsFrom) RltInrvlsXpr()             {}
func (x RltInrvlsTo) Xpr()                        {}
func (x RltInrvlsTo) RltInrvlsXpr()               {}
func (x RltInrvlsFst) Xpr()                       {}
func (x RltInrvlsFst) RltInrvlXpr()               {}
func (x RltInrvlsMdl) Xpr()                       {}
func (x RltInrvlsMdl) RltInrvlXpr()               {}
func (x RltInrvlsLst) Xpr()                       {}
func (x RltInrvlsLst) RltInrvlXpr()               {}
func (x RltInrvlsFstIdx) Xpr()                    {}
func (x RltInrvlsFstIdx) UntUntXpr()              {}
func (x RltInrvlsMdlIdx) Xpr()                    {}
func (x RltInrvlsMdlIdx) UntUntXpr()              {}
func (x RltInrvlsLstIdx) Xpr()                    {}
func (x RltInrvlsLstIdx) UntUntXpr()              {}
func (x RltInrvlsRev) Xpr()                       {}
func (x RltInrvlsRev) RltInrvlsXpr()              {}
func (x RltSidesCnt) Xpr()                        {}
func (x RltSidesCnt) UntUntXpr()                  {}
func (x RltSidesCpy) Xpr()                        {}
func (x RltSidesCpy) RltSidesXpr()                {}
func (x RltSidesClr) Xpr()                        {}
func (x RltSidesClr) RltSidesXpr()                {}
func (x RltSidesRand) Xpr()                       {}
func (x RltSidesRand) RltSidesXpr()               {}
func (x RltSidesMrg) Xpr()                        {}
func (x RltSidesMrg) RltSidesXpr()                {}
func (x RltSidesPush) Xpr()                       {}
func (x RltSidesPush) RltSidesXpr()               {}
func (x RltSidesPop) Xpr()                        {}
func (x RltSidesPop) RltSideXpr()                 {}
func (x RltSidesQue) Xpr()                        {}
func (x RltSidesQue) RltSidesXpr()                {}
func (x RltSidesDque) Xpr()                       {}
func (x RltSidesDque) RltSideXpr()                {}
func (x RltSidesIns) Xpr()                        {}
func (x RltSidesIns) RltSidesXpr()                {}
func (x RltSidesUpd) Xpr()                        {}
func (x RltSidesUpd) RltSidesXpr()                {}
func (x RltSidesDel) Xpr()                        {}
func (x RltSidesDel) RltSideXpr()                 {}
func (x RltSidesAt) Xpr()                         {}
func (x RltSidesAt) RltSideXpr()                  {}
func (x RltSidesIn) Xpr()                         {}
func (x RltSidesIn) RltSidesXpr()                 {}
func (x RltSidesInBnd) Xpr()                      {}
func (x RltSidesInBnd) RltSidesXpr()              {}
func (x RltSidesFrom) Xpr()                       {}
func (x RltSidesFrom) RltSidesXpr()               {}
func (x RltSidesTo) Xpr()                         {}
func (x RltSidesTo) RltSidesXpr()                 {}
func (x RltSidesFst) Xpr()                        {}
func (x RltSidesFst) RltSideXpr()                 {}
func (x RltSidesMdl) Xpr()                        {}
func (x RltSidesMdl) RltSideXpr()                 {}
func (x RltSidesLst) Xpr()                        {}
func (x RltSidesLst) RltSideXpr()                 {}
func (x RltSidesFstIdx) Xpr()                     {}
func (x RltSidesFstIdx) UntUntXpr()               {}
func (x RltSidesMdlIdx) Xpr()                     {}
func (x RltSidesMdlIdx) UntUntXpr()               {}
func (x RltSidesLstIdx) Xpr()                     {}
func (x RltSidesLstIdx) UntUntXpr()               {}
func (x RltSidesRev) Xpr()                        {}
func (x RltSidesRev) RltSidesXpr()                {}
func (x RltStmsCnt) Xpr()                         {}
func (x RltStmsCnt) UntUntXpr()                   {}
func (x RltStmsCpy) Xpr()                         {}
func (x RltStmsCpy) RltStmsXpr()                  {}
func (x RltStmsClr) Xpr()                         {}
func (x RltStmsClr) RltStmsXpr()                  {}
func (x RltStmsRand) Xpr()                        {}
func (x RltStmsRand) RltStmsXpr()                 {}
func (x RltStmsMrg) Xpr()                         {}
func (x RltStmsMrg) RltStmsXpr()                  {}
func (x RltStmsPush) Xpr()                        {}
func (x RltStmsPush) RltStmsXpr()                 {}
func (x RltStmsPop) Xpr()                         {}
func (x RltStmsPop) RltStmXpr()                   {}
func (x RltStmsQue) Xpr()                         {}
func (x RltStmsQue) RltStmsXpr()                  {}
func (x RltStmsDque) Xpr()                        {}
func (x RltStmsDque) RltStmXpr()                  {}
func (x RltStmsIns) Xpr()                         {}
func (x RltStmsIns) RltStmsXpr()                  {}
func (x RltStmsUpd) Xpr()                         {}
func (x RltStmsUpd) RltStmsXpr()                  {}
func (x RltStmsDel) Xpr()                         {}
func (x RltStmsDel) RltStmXpr()                   {}
func (x RltStmsAt) Xpr()                          {}
func (x RltStmsAt) RltStmXpr()                    {}
func (x RltStmsIn) Xpr()                          {}
func (x RltStmsIn) RltStmsXpr()                   {}
func (x RltStmsInBnd) Xpr()                       {}
func (x RltStmsInBnd) RltStmsXpr()                {}
func (x RltStmsFrom) Xpr()                        {}
func (x RltStmsFrom) RltStmsXpr()                 {}
func (x RltStmsTo) Xpr()                          {}
func (x RltStmsTo) RltStmsXpr()                   {}
func (x RltStmsFst) Xpr()                         {}
func (x RltStmsFst) RltStmXpr()                   {}
func (x RltStmsMdl) Xpr()                         {}
func (x RltStmsMdl) RltStmXpr()                   {}
func (x RltStmsLst) Xpr()                         {}
func (x RltStmsLst) RltStmXpr()                   {}
func (x RltStmsFstIdx) Xpr()                      {}
func (x RltStmsFstIdx) UntUntXpr()                {}
func (x RltStmsMdlIdx) Xpr()                      {}
func (x RltStmsMdlIdx) UntUntXpr()                {}
func (x RltStmsLstIdx) Xpr()                      {}
func (x RltStmsLstIdx) UntUntXpr()                {}
func (x RltStmsRev) Xpr()                         {}
func (x RltStmsRev) RltStmsXpr()                  {}
func (x RltCndsCnt) Xpr()                         {}
func (x RltCndsCnt) UntUntXpr()                   {}
func (x RltCndsCpy) Xpr()                         {}
func (x RltCndsCpy) RltCndsXpr()                  {}
func (x RltCndsClr) Xpr()                         {}
func (x RltCndsClr) RltCndsXpr()                  {}
func (x RltCndsRand) Xpr()                        {}
func (x RltCndsRand) RltCndsXpr()                 {}
func (x RltCndsMrg) Xpr()                         {}
func (x RltCndsMrg) RltCndsXpr()                  {}
func (x RltCndsPush) Xpr()                        {}
func (x RltCndsPush) RltCndsXpr()                 {}
func (x RltCndsPop) Xpr()                         {}
func (x RltCndsPop) RltCndXpr()                   {}
func (x RltCndsQue) Xpr()                         {}
func (x RltCndsQue) RltCndsXpr()                  {}
func (x RltCndsDque) Xpr()                        {}
func (x RltCndsDque) RltCndXpr()                  {}
func (x RltCndsIns) Xpr()                         {}
func (x RltCndsIns) RltCndsXpr()                  {}
func (x RltCndsUpd) Xpr()                         {}
func (x RltCndsUpd) RltCndsXpr()                  {}
func (x RltCndsDel) Xpr()                         {}
func (x RltCndsDel) RltCndXpr()                   {}
func (x RltCndsAt) Xpr()                          {}
func (x RltCndsAt) RltCndXpr()                    {}
func (x RltCndsIn) Xpr()                          {}
func (x RltCndsIn) RltCndsXpr()                   {}
func (x RltCndsInBnd) Xpr()                       {}
func (x RltCndsInBnd) RltCndsXpr()                {}
func (x RltCndsFrom) Xpr()                        {}
func (x RltCndsFrom) RltCndsXpr()                 {}
func (x RltCndsTo) Xpr()                          {}
func (x RltCndsTo) RltCndsXpr()                   {}
func (x RltCndsFst) Xpr()                         {}
func (x RltCndsFst) RltCndXpr()                   {}
func (x RltCndsMdl) Xpr()                         {}
func (x RltCndsMdl) RltCndXpr()                   {}
func (x RltCndsLst) Xpr()                         {}
func (x RltCndsLst) RltCndXpr()                   {}
func (x RltCndsFstIdx) Xpr()                      {}
func (x RltCndsFstIdx) UntUntXpr()                {}
func (x RltCndsMdlIdx) Xpr()                      {}
func (x RltCndsMdlIdx) UntUntXpr()                {}
func (x RltCndsLstIdx) Xpr()                      {}
func (x RltCndsLstIdx) UntUntXpr()                {}
func (x RltCndsRev) Xpr()                         {}
func (x RltCndsRev) RltCndsXpr()                  {}
func (x RltStgysCnt) Xpr()                        {}
func (x RltStgysCnt) UntUntXpr()                  {}
func (x RltStgysCpy) Xpr()                        {}
func (x RltStgysCpy) RltStgysXpr()                {}
func (x RltStgysClr) Xpr()                        {}
func (x RltStgysClr) RltStgysXpr()                {}
func (x RltStgysRand) Xpr()                       {}
func (x RltStgysRand) RltStgysXpr()               {}
func (x RltStgysMrg) Xpr()                        {}
func (x RltStgysMrg) RltStgysXpr()                {}
func (x RltStgysPush) Xpr()                       {}
func (x RltStgysPush) RltStgysXpr()               {}
func (x RltStgysPop) Xpr()                        {}
func (x RltStgysPop) RltStgyXpr()                 {}
func (x RltStgysQue) Xpr()                        {}
func (x RltStgysQue) RltStgysXpr()                {}
func (x RltStgysDque) Xpr()                       {}
func (x RltStgysDque) RltStgyXpr()                {}
func (x RltStgysIns) Xpr()                        {}
func (x RltStgysIns) RltStgysXpr()                {}
func (x RltStgysUpd) Xpr()                        {}
func (x RltStgysUpd) RltStgysXpr()                {}
func (x RltStgysDel) Xpr()                        {}
func (x RltStgysDel) RltStgyXpr()                 {}
func (x RltStgysAt) Xpr()                         {}
func (x RltStgysAt) RltStgyXpr()                  {}
func (x RltStgysIn) Xpr()                         {}
func (x RltStgysIn) RltStgysXpr()                 {}
func (x RltStgysInBnd) Xpr()                      {}
func (x RltStgysInBnd) RltStgysXpr()              {}
func (x RltStgysFrom) Xpr()                       {}
func (x RltStgysFrom) RltStgysXpr()               {}
func (x RltStgysTo) Xpr()                         {}
func (x RltStgysTo) RltStgysXpr()                 {}
func (x RltStgysFst) Xpr()                        {}
func (x RltStgysFst) RltStgyXpr()                 {}
func (x RltStgysMdl) Xpr()                        {}
func (x RltStgysMdl) RltStgyXpr()                 {}
func (x RltStgysLst) Xpr()                        {}
func (x RltStgysLst) RltStgyXpr()                 {}
func (x RltStgysFstIdx) Xpr()                     {}
func (x RltStgysFstIdx) UntUntXpr()               {}
func (x RltStgysMdlIdx) Xpr()                     {}
func (x RltStgysMdlIdx) UntUntXpr()               {}
func (x RltStgysLstIdx) Xpr()                     {}
func (x RltStgysLstIdx) UntUntXpr()               {}
func (x RltStgysRev) Xpr()                        {}
func (x RltStgysRev) RltStgysXpr()                {}
func (x ClrClrOpa) Xpr()                          {}
func (x ClrClrOpa) ClrClrXpr()                    {}
func (x ClrClrInv) Xpr()                          {}
func (x ClrClrInv) ClrClrXpr()                    {}
func (x PenPenOpa) Xpr()                          {}
func (x PenPenOpa) PenPenXpr()                    {}
func (x PenPenInv) Xpr()                          {}
func (x PenPenInv) PenPenXpr()                    {}
func (x PenPensCnt) Xpr()                         {}
func (x PenPensCnt) UntUntXpr()                   {}
func (x PenPensCpy) Xpr()                         {}
func (x PenPensCpy) PenPensXpr()                  {}
func (x PenPensClr) Xpr()                         {}
func (x PenPensClr) PenPensXpr()                  {}
func (x PenPensRand) Xpr()                        {}
func (x PenPensRand) PenPensXpr()                 {}
func (x PenPensMrg) Xpr()                         {}
func (x PenPensMrg) PenPensXpr()                  {}
func (x PenPensPush) Xpr()                        {}
func (x PenPensPush) PenPensXpr()                 {}
func (x PenPensPop) Xpr()                         {}
func (x PenPensPop) PenPenXpr()                   {}
func (x PenPensQue) Xpr()                         {}
func (x PenPensQue) PenPensXpr()                  {}
func (x PenPensDque) Xpr()                        {}
func (x PenPensDque) PenPenXpr()                  {}
func (x PenPensIns) Xpr()                         {}
func (x PenPensIns) PenPensXpr()                  {}
func (x PenPensUpd) Xpr()                         {}
func (x PenPensUpd) PenPensXpr()                  {}
func (x PenPensDel) Xpr()                         {}
func (x PenPensDel) PenPenXpr()                   {}
func (x PenPensAt) Xpr()                          {}
func (x PenPensAt) PenPenXpr()                    {}
func (x PenPensIn) Xpr()                          {}
func (x PenPensIn) PenPensXpr()                   {}
func (x PenPensInBnd) Xpr()                       {}
func (x PenPensInBnd) PenPensXpr()                {}
func (x PenPensFrom) Xpr()                        {}
func (x PenPensFrom) PenPensXpr()                 {}
func (x PenPensTo) Xpr()                          {}
func (x PenPensTo) PenPensXpr()                   {}
func (x PenPensFst) Xpr()                         {}
func (x PenPensFst) PenPenXpr()                   {}
func (x PenPensMdl) Xpr()                         {}
func (x PenPensMdl) PenPenXpr()                   {}
func (x PenPensLst) Xpr()                         {}
func (x PenPensLst) PenPenXpr()                   {}
func (x PenPensFstIdx) Xpr()                      {}
func (x PenPensFstIdx) UntUntXpr()                {}
func (x PenPensMdlIdx) Xpr()                      {}
func (x PenPensMdlIdx) UntUntXpr()                {}
func (x PenPensLstIdx) Xpr()                      {}
func (x PenPensLstIdx) UntUntXpr()                {}
func (x PenPensRev) Xpr()                         {}
func (x PenPensRev) PenPensXpr()                  {}
func (x PltPltsCnt) Xpr()                         {}
func (x PltPltsCnt) UntUntXpr()                   {}
func (x PltPltsCpy) Xpr()                         {}
func (x PltPltsCpy) PltPltsXpr()                  {}
func (x PltPltsClr) Xpr()                         {}
func (x PltPltsClr) PltPltsXpr()                  {}
func (x PltPltsRand) Xpr()                        {}
func (x PltPltsRand) PltPltsXpr()                 {}
func (x PltPltsMrg) Xpr()                         {}
func (x PltPltsMrg) PltPltsXpr()                  {}
func (x PltPltsPush) Xpr()                        {}
func (x PltPltsPush) PltPltsXpr()                 {}
func (x PltPltsPop) Xpr()                         {}
func (x PltPltsPop) PltPltXpr()                   {}
func (x PltPltsQue) Xpr()                         {}
func (x PltPltsQue) PltPltsXpr()                  {}
func (x PltPltsDque) Xpr()                        {}
func (x PltPltsDque) PltPltXpr()                  {}
func (x PltPltsIns) Xpr()                         {}
func (x PltPltsIns) PltPltsXpr()                  {}
func (x PltPltsUpd) Xpr()                         {}
func (x PltPltsUpd) PltPltsXpr()                  {}
func (x PltPltsDel) Xpr()                         {}
func (x PltPltsDel) PltPltXpr()                   {}
func (x PltPltsAt) Xpr()                          {}
func (x PltPltsAt) PltPltXpr()                    {}
func (x PltPltsIn) Xpr()                          {}
func (x PltPltsIn) PltPltsXpr()                   {}
func (x PltPltsInBnd) Xpr()                       {}
func (x PltPltsInBnd) PltPltsXpr()                {}
func (x PltPltsFrom) Xpr()                        {}
func (x PltPltsFrom) PltPltsXpr()                 {}
func (x PltPltsTo) Xpr()                          {}
func (x PltPltsTo) PltPltsXpr()                   {}
func (x PltPltsFst) Xpr()                         {}
func (x PltPltsFst) PltPltXpr()                   {}
func (x PltPltsMdl) Xpr()                         {}
func (x PltPltsMdl) PltPltXpr()                   {}
func (x PltPltsLst) Xpr()                         {}
func (x PltPltsLst) PltPltXpr()                   {}
func (x PltPltsFstIdx) Xpr()                      {}
func (x PltPltsFstIdx) UntUntXpr()                {}
func (x PltPltsMdlIdx) Xpr()                      {}
func (x PltPltsMdlIdx) UntUntXpr()                {}
func (x PltPltsLstIdx) Xpr()                      {}
func (x PltPltsLstIdx) UntUntXpr()                {}
func (x PltPltsRev) Xpr()                         {}
func (x PltPltsRev) PltPltsXpr()                  {}
func (x PltTmeAxisXVis) Xpr()                     {}
func (x PltTmeAxisXVis) PltTmeAxisXXpr()          {}
func (x PltFltAxisYVis) Xpr()                     {}
func (x PltFltAxisYVis) PltFltAxisYXpr()          {}
func (x PltStmX) Xpr()                            {}
func (x PltStmX) PltTmeAxisXXpr()                 {}
func (x PltStmY) Xpr()                            {}
func (x PltStmY) PltFltAxisYXpr()                 {}
func (x PltStmStm) Xpr()                          {}
func (x PltStmStm) PltStmXpr()                    {}
func (x PltStmStm) PltPltXpr()                    {}
func (x PltStmStmBnd) Xpr()                       {}
func (x PltStmStmBnd) PltStmXpr()                 {}
func (x PltStmStmBnd) PltPltXpr()                 {}
func (x PltStmCnd) Xpr()                          {}
func (x PltStmCnd) PltStmXpr()                    {}
func (x PltStmCnd) PltPltXpr()                    {}
func (x PltStmHrzLn) Xpr()                        {}
func (x PltStmHrzLn) PltStmXpr()                  {}
func (x PltStmHrzLn) PltPltXpr()                  {}
func (x PltStmVrtLn) Xpr()                        {}
func (x PltStmVrtLn) PltStmXpr()                  {}
func (x PltStmVrtLn) PltPltXpr()                  {}
func (x PltStmHrzBnd) Xpr()                       {}
func (x PltStmHrzBnd) PltStmXpr()                 {}
func (x PltStmHrzBnd) PltPltXpr()                 {}
func (x PltStmVrtBnd) Xpr()                       {}
func (x PltStmVrtBnd) PltStmXpr()                 {}
func (x PltStmVrtBnd) PltPltXpr()                 {}
func (x PltStmHrzSclVal) Xpr()                    {}
func (x PltStmHrzSclVal) PltStmXpr()              {}
func (x PltStmHrzSclVal) PltPltXpr()              {}
func (x PltStmVrtSclVal) Xpr()                    {}
func (x PltStmVrtSclVal) PltStmXpr()              {}
func (x PltStmVrtSclVal) PltPltXpr()              {}
func (x PltStmSho) Xpr()                          {}
func (x PltStmSho) PltPltXpr()                    {}
func (x PltStmSiz) Xpr()                          {}
func (x PltStmSiz) PltPltXpr()                    {}
func (x PltStmScl) Xpr()                          {}
func (x PltStmScl) PltPltXpr()                    {}
func (x PltStmHrzScl) Xpr()                       {}
func (x PltStmHrzScl) PltPltXpr()                 {}
func (x PltStmVrtScl) Xpr()                       {}
func (x PltStmVrtScl) PltPltXpr()                 {}
func (x PltFltsSctrFlts) Xpr()                    {}
func (x PltFltsSctrFlts) PltFltsSctrXpr()         {}
func (x PltFltsSctrFlts) PltPltXpr()              {}
func (x PltFltsSctrPrfLos) Xpr()                  {}
func (x PltFltsSctrPrfLos) PltFltsSctrXpr()       {}
func (x PltFltsSctrPrfLos) PltPltXpr()            {}
func (x PltFltsSctrSho) Xpr()                     {}
func (x PltFltsSctrSho) PltPltXpr()               {}
func (x PltFltsSctrSiz) Xpr()                     {}
func (x PltFltsSctrSiz) PltPltXpr()               {}
func (x PltFltsSctrScl) Xpr()                     {}
func (x PltFltsSctrScl) PltPltXpr()               {}
func (x PltFltsSctrHrzScl) Xpr()                  {}
func (x PltFltsSctrHrzScl) PltPltXpr()            {}
func (x PltFltsSctrVrtScl) Xpr()                  {}
func (x PltFltsSctrVrtScl) PltPltXpr()            {}
func (x PltFltsSctrDistFlts) Xpr()                {}
func (x PltFltsSctrDistFlts) PltFltsSctrDistXpr() {}
func (x PltFltsSctrDistFlts) PltPltXpr()          {}
func (x PltFltsSctrDistSho) Xpr()                 {}
func (x PltFltsSctrDistSho) PltPltXpr()           {}
func (x PltFltsSctrDistSiz) Xpr()                 {}
func (x PltFltsSctrDistSiz) PltPltXpr()           {}
func (x PltFltsSctrDistScl) Xpr()                 {}
func (x PltFltsSctrDistScl) PltPltXpr()           {}
func (x PltFltsSctrDistHrzScl) Xpr()              {}
func (x PltFltsSctrDistHrzScl) PltPltXpr()        {}
func (x PltFltsSctrDistVrtScl) Xpr()              {}
func (x PltFltsSctrDistVrtScl) PltPltXpr()        {}
func (x PltHrzPlt) Xpr()                          {}
func (x PltHrzPlt) PltHrzXpr()                    {}
func (x PltHrzPlt) PltPltXpr()                    {}
func (x PltHrzSho) Xpr()                          {}
func (x PltHrzSho) PltPltXpr()                    {}
func (x PltHrzSiz) Xpr()                          {}
func (x PltHrzSiz) PltPltXpr()                    {}
func (x PltHrzScl) Xpr()                          {}
func (x PltHrzScl) PltPltXpr()                    {}
func (x PltHrzHrzScl) Xpr()                       {}
func (x PltHrzHrzScl) PltPltXpr()                 {}
func (x PltHrzVrtScl) Xpr()                       {}
func (x PltHrzVrtScl) PltPltXpr()                 {}
func (x PltVrtPlt) Xpr()                          {}
func (x PltVrtPlt) PltVrtXpr()                    {}
func (x PltVrtPlt) PltPltXpr()                    {}
func (x PltVrtSho) Xpr()                          {}
func (x PltVrtSho) PltPltXpr()                    {}
func (x PltVrtSiz) Xpr()                          {}
func (x PltVrtSiz) PltPltXpr()                    {}
func (x PltVrtScl) Xpr()                          {}
func (x PltVrtScl) PltPltXpr()                    {}
func (x PltVrtHrzScl) Xpr()                       {}
func (x PltVrtHrzScl) PltPltXpr()                 {}
func (x PltVrtVrtScl) Xpr()                       {}
func (x PltVrtVrtScl) PltPltXpr()                 {}
func (x PltDpthPlt) Xpr()                         {}
func (x PltDpthPlt) PltDpthXpr()                  {}
func (x PltDpthPlt) PltPltXpr()                   {}
func (x PltDpthSho) Xpr()                         {}
func (x PltDpthSho) PltPltXpr()                   {}
func (x PltDpthSiz) Xpr()                         {}
func (x PltDpthSiz) PltPltXpr()                   {}
func (x PltDpthScl) Xpr()                         {}
func (x PltDpthScl) PltPltXpr()                   {}
func (x PltDpthHrzScl) Xpr()                      {}
func (x PltDpthHrzScl) PltPltXpr()                {}
func (x PltDpthVrtScl) Xpr()                      {}
func (x PltDpthVrtScl) PltPltXpr()                {}
func (x SysMuLck) Xpr()                           {}
func (x SysMuLck) SysMuXpr()                      {}
func (x SysMuUlck) Xpr()                          {}
func (x SysMuUlck) SysMuXpr()                     {}
func (x HstPrvName) Xpr()                         {}
func (x HstPrvName) StrStrXpr()                   {}
func (x HstPrvEurUsd) Xpr()                       {}
func (x HstPrvEurUsd) HstInstrXpr()               {}
func (x HstPrvAudUsd) Xpr()                       {}
func (x HstPrvAudUsd) HstInstrXpr()               {}
func (x HstPrvNzdUsd) Xpr()                       {}
func (x HstPrvNzdUsd) HstInstrXpr()               {}
func (x HstPrvGbpUsd) Xpr()                       {}
func (x HstPrvGbpUsd) HstInstrXpr()               {}
func (x HstInstrName) Xpr()                       {}
func (x HstInstrName) StrStrXpr()                 {}
func (x HstInstrI) Xpr()                          {}
func (x HstInstrI) HstInrvlXpr()                  {}
func (x HstInrvlName) Xpr()                       {}
func (x HstInrvlName) StrStrXpr()                 {}
func (x HstInrvlBid) Xpr()                        {}
func (x HstInrvlBid) HstSideXpr()                 {}
func (x HstInrvlAsk) Xpr()                        {}
func (x HstInrvlAsk) HstSideXpr()                 {}
func (x HstSideName) Xpr()                        {}
func (x HstSideName) StrStrXpr()                  {}
func (x HstSideFst) Xpr()                         {}
func (x HstSideFst) HstStmXpr()                   {}
func (x HstSideLst) Xpr()                         {}
func (x HstSideLst) HstStmXpr()                   {}
func (x HstSideSum) Xpr()                         {}
func (x HstSideSum) HstStmXpr()                   {}
func (x HstSidePrd) Xpr()                         {}
func (x HstSidePrd) HstStmXpr()                   {}
func (x HstSideMin) Xpr()                         {}
func (x HstSideMin) HstStmXpr()                   {}
func (x HstSideMax) Xpr()                         {}
func (x HstSideMax) HstStmXpr()                   {}
func (x HstSideMid) Xpr()                         {}
func (x HstSideMid) HstStmXpr()                   {}
func (x HstSideMdn) Xpr()                         {}
func (x HstSideMdn) HstStmXpr()                   {}
func (x HstSideSma) Xpr()                         {}
func (x HstSideSma) HstStmXpr()                   {}
func (x HstSideGma) Xpr()                         {}
func (x HstSideGma) HstStmXpr()                   {}
func (x HstSideWma) Xpr()                         {}
func (x HstSideWma) HstStmXpr()                   {}
func (x HstSideRsi) Xpr()                         {}
func (x HstSideRsi) HstStmXpr()                   {}
func (x HstSideWrsi) Xpr()                        {}
func (x HstSideWrsi) HstStmXpr()                  {}
func (x HstSideAlma) Xpr()                        {}
func (x HstSideAlma) HstStmXpr()                  {}
func (x HstSideVrnc) Xpr()                        {}
func (x HstSideVrnc) HstStmXpr()                  {}
func (x HstSideStd) Xpr()                         {}
func (x HstSideStd) HstStmXpr()                   {}
func (x HstSideRngFul) Xpr()                      {}
func (x HstSideRngFul) HstStmXpr()                {}
func (x HstSideRngLst) Xpr()                      {}
func (x HstSideRngLst) HstStmXpr()                {}
func (x HstSideProLst) Xpr()                      {}
func (x HstSideProLst) HstStmXpr()                {}
func (x HstSideProSma) Xpr()                      {}
func (x HstSideProSma) HstStmXpr()                {}
func (x HstSideProAlma) Xpr()                     {}
func (x HstSideProAlma) HstStmXpr()               {}
func (x HstSideSar) Xpr()                         {}
func (x HstSideSar) HstStmXpr()                   {}
func (x HstSideEma) Xpr()                         {}
func (x HstSideEma) HstStmXpr()                   {}
func (x HstStmName) Xpr()                         {}
func (x HstStmName) StrStrXpr()                   {}
func (x HstStmAt) Xpr()                           {}
func (x HstStmAt) FltsFltsXpr()                   {}
func (x HstStmUnaPos) Xpr()                       {}
func (x HstStmUnaPos) HstStmXpr()                 {}
func (x HstStmUnaNeg) Xpr()                       {}
func (x HstStmUnaNeg) HstStmXpr()                 {}
func (x HstStmUnaInv) Xpr()                       {}
func (x HstStmUnaInv) HstStmXpr()                 {}
func (x HstStmUnaSqr) Xpr()                       {}
func (x HstStmUnaSqr) HstStmXpr()                 {}
func (x HstStmUnaSqrt) Xpr()                      {}
func (x HstStmUnaSqrt) HstStmXpr()                {}
func (x HstStmSclAdd) Xpr()                       {}
func (x HstStmSclAdd) HstStmXpr()                 {}
func (x HstStmSclSub) Xpr()                       {}
func (x HstStmSclSub) HstStmXpr()                 {}
func (x HstStmSclMul) Xpr()                       {}
func (x HstStmSclMul) HstStmXpr()                 {}
func (x HstStmSclDiv) Xpr()                       {}
func (x HstStmSclDiv) HstStmXpr()                 {}
func (x HstStmSclRem) Xpr()                       {}
func (x HstStmSclRem) HstStmXpr()                 {}
func (x HstStmSclPow) Xpr()                       {}
func (x HstStmSclPow) HstStmXpr()                 {}
func (x HstStmSclMin) Xpr()                       {}
func (x HstStmSclMin) HstStmXpr()                 {}
func (x HstStmSclMax) Xpr()                       {}
func (x HstStmSclMax) HstStmXpr()                 {}
func (x HstStmSelEql) Xpr()                       {}
func (x HstStmSelEql) HstStmXpr()                 {}
func (x HstStmSelNeq) Xpr()                       {}
func (x HstStmSelNeq) HstStmXpr()                 {}
func (x HstStmSelLss) Xpr()                       {}
func (x HstStmSelLss) HstStmXpr()                 {}
func (x HstStmSelGtr) Xpr()                       {}
func (x HstStmSelGtr) HstStmXpr()                 {}
func (x HstStmSelLeq) Xpr()                       {}
func (x HstStmSelLeq) HstStmXpr()                 {}
func (x HstStmSelGeq) Xpr()                       {}
func (x HstStmSelGeq) HstStmXpr()                 {}
func (x HstStmAggFst) Xpr()                       {}
func (x HstStmAggFst) HstStmXpr()                 {}
func (x HstStmAggLst) Xpr()                       {}
func (x HstStmAggLst) HstStmXpr()                 {}
func (x HstStmAggSum) Xpr()                       {}
func (x HstStmAggSum) HstStmXpr()                 {}
func (x HstStmAggPrd) Xpr()                       {}
func (x HstStmAggPrd) HstStmXpr()                 {}
func (x HstStmAggMin) Xpr()                       {}
func (x HstStmAggMin) HstStmXpr()                 {}
func (x HstStmAggMax) Xpr()                       {}
func (x HstStmAggMax) HstStmXpr()                 {}
func (x HstStmAggMid) Xpr()                       {}
func (x HstStmAggMid) HstStmXpr()                 {}
func (x HstStmAggMdn) Xpr()                       {}
func (x HstStmAggMdn) HstStmXpr()                 {}
func (x HstStmAggSma) Xpr()                       {}
func (x HstStmAggSma) HstStmXpr()                 {}
func (x HstStmAggGma) Xpr()                       {}
func (x HstStmAggGma) HstStmXpr()                 {}
func (x HstStmAggWma) Xpr()                       {}
func (x HstStmAggWma) HstStmXpr()                 {}
func (x HstStmAggRsi) Xpr()                       {}
func (x HstStmAggRsi) HstStmXpr()                 {}
func (x HstStmAggWrsi) Xpr()                      {}
func (x HstStmAggWrsi) HstStmXpr()                {}
func (x HstStmAggAlma) Xpr()                      {}
func (x HstStmAggAlma) HstStmXpr()                {}
func (x HstStmAggVrnc) Xpr()                      {}
func (x HstStmAggVrnc) HstStmXpr()                {}
func (x HstStmAggStd) Xpr()                       {}
func (x HstStmAggStd) HstStmXpr()                 {}
func (x HstStmAggRngFul) Xpr()                    {}
func (x HstStmAggRngFul) HstStmXpr()              {}
func (x HstStmAggRngLst) Xpr()                    {}
func (x HstStmAggRngLst) HstStmXpr()              {}
func (x HstStmAggProLst) Xpr()                    {}
func (x HstStmAggProLst) HstStmXpr()              {}
func (x HstStmAggProSma) Xpr()                    {}
func (x HstStmAggProSma) HstStmXpr()              {}
func (x HstStmAggProAlma) Xpr()                   {}
func (x HstStmAggProAlma) HstStmXpr()             {}
func (x HstStmAggEma) Xpr()                       {}
func (x HstStmAggEma) HstStmXpr()                 {}
func (x HstStmInrAdd) Xpr()                       {}
func (x HstStmInrAdd) HstStmXpr()                 {}
func (x HstStmInrSub) Xpr()                       {}
func (x HstStmInrSub) HstStmXpr()                 {}
func (x HstStmInrMul) Xpr()                       {}
func (x HstStmInrMul) HstStmXpr()                 {}
func (x HstStmInrDiv) Xpr()                       {}
func (x HstStmInrDiv) HstStmXpr()                 {}
func (x HstStmInrRem) Xpr()                       {}
func (x HstStmInrRem) HstStmXpr()                 {}
func (x HstStmInrPow) Xpr()                       {}
func (x HstStmInrPow) HstStmXpr()                 {}
func (x HstStmInrMin) Xpr()                       {}
func (x HstStmInrMin) HstStmXpr()                 {}
func (x HstStmInrMax) Xpr()                       {}
func (x HstStmInrMax) HstStmXpr()                 {}
func (x HstStmInrSlp) Xpr()                       {}
func (x HstStmInrSlp) HstStmXpr()                 {}
func (x HstStmOtrAdd) Xpr()                       {}
func (x HstStmOtrAdd) HstStmXpr()                 {}
func (x HstStmOtrSub) Xpr()                       {}
func (x HstStmOtrSub) HstStmXpr()                 {}
func (x HstStmOtrMul) Xpr()                       {}
func (x HstStmOtrMul) HstStmXpr()                 {}
func (x HstStmOtrDiv) Xpr()                       {}
func (x HstStmOtrDiv) HstStmXpr()                 {}
func (x HstStmOtrRem) Xpr()                       {}
func (x HstStmOtrRem) HstStmXpr()                 {}
func (x HstStmOtrPow) Xpr()                       {}
func (x HstStmOtrPow) HstStmXpr()                 {}
func (x HstStmOtrMin) Xpr()                       {}
func (x HstStmOtrMin) HstStmXpr()                 {}
func (x HstStmOtrMax) Xpr()                       {}
func (x HstStmOtrMax) HstStmXpr()                 {}
func (x HstStmSclEql) Xpr()                       {}
func (x HstStmSclEql) HstCndXpr()                 {}
func (x HstStmSclNeq) Xpr()                       {}
func (x HstStmSclNeq) HstCndXpr()                 {}
func (x HstStmSclLss) Xpr()                       {}
func (x HstStmSclLss) HstCndXpr()                 {}
func (x HstStmSclGtr) Xpr()                       {}
func (x HstStmSclGtr) HstCndXpr()                 {}
func (x HstStmSclLeq) Xpr()                       {}
func (x HstStmSclLeq) HstCndXpr()                 {}
func (x HstStmSclGeq) Xpr()                       {}
func (x HstStmSclGeq) HstCndXpr()                 {}
func (x HstStmInrEql) Xpr()                       {}
func (x HstStmInrEql) HstCndXpr()                 {}
func (x HstStmInrNeq) Xpr()                       {}
func (x HstStmInrNeq) HstCndXpr()                 {}
func (x HstStmInrLss) Xpr()                       {}
func (x HstStmInrLss) HstCndXpr()                 {}
func (x HstStmInrGtr) Xpr()                       {}
func (x HstStmInrGtr) HstCndXpr()                 {}
func (x HstStmInrLeq) Xpr()                       {}
func (x HstStmInrLeq) HstCndXpr()                 {}
func (x HstStmInrGeq) Xpr()                       {}
func (x HstStmInrGeq) HstCndXpr()                 {}
func (x HstStmOtrEql) Xpr()                       {}
func (x HstStmOtrEql) HstCndXpr()                 {}
func (x HstStmOtrNeq) Xpr()                       {}
func (x HstStmOtrNeq) HstCndXpr()                 {}
func (x HstStmOtrLss) Xpr()                       {}
func (x HstStmOtrLss) HstCndXpr()                 {}
func (x HstStmOtrGtr) Xpr()                       {}
func (x HstStmOtrGtr) HstCndXpr()                 {}
func (x HstStmOtrLeq) Xpr()                       {}
func (x HstStmOtrLeq) HstCndXpr()                 {}
func (x HstStmOtrGeq) Xpr()                       {}
func (x HstStmOtrGeq) HstCndXpr()                 {}
func (x HstCndName) Xpr()                         {}
func (x HstCndName) StrStrXpr()                   {}
func (x HstCndAnd) Xpr()                          {}
func (x HstCndAnd) HstCndXpr()                    {}
func (x HstCndSeq) Xpr()                          {}
func (x HstCndSeq) HstCndXpr()                    {}
func (x HstCndStgy) Xpr()                         {}
func (x HstCndStgy) HstStgyXpr()                  {}
func (x HstStgyName) Xpr()                        {}
func (x HstStgyName) StrStrXpr()                  {}
func (x RltPrvMayTrd) Xpr()                       {}
func (x RltPrvMayTrd) BolBolXpr()                 {}
func (x RltPrvEurUsd) Xpr()                       {}
func (x RltPrvEurUsd) RltInstrXpr()               {}
func (x RltPrvAudUsd) Xpr()                       {}
func (x RltPrvAudUsd) RltInstrXpr()               {}
func (x RltPrvNzdUsd) Xpr()                       {}
func (x RltPrvNzdUsd) RltInstrXpr()               {}
func (x RltPrvGbpUsd) Xpr()                       {}
func (x RltPrvGbpUsd) RltInstrXpr()               {}
func (x RltInstrI) Xpr()                          {}
func (x RltInstrI) RltInrvlXpr()                  {}
func (x RltInrvlBid) Xpr()                        {}
func (x RltInrvlBid) RltSideXpr()                 {}
func (x RltInrvlAsk) Xpr()                        {}
func (x RltInrvlAsk) RltSideXpr()                 {}
func (x RltSideFst) Xpr()                         {}
func (x RltSideFst) RltStmXpr()                   {}
func (x RltSideLst) Xpr()                         {}
func (x RltSideLst) RltStmXpr()                   {}
func (x RltSideSum) Xpr()                         {}
func (x RltSideSum) RltStmXpr()                   {}
func (x RltSidePrd) Xpr()                         {}
func (x RltSidePrd) RltStmXpr()                   {}
func (x RltSideMin) Xpr()                         {}
func (x RltSideMin) RltStmXpr()                   {}
func (x RltSideMax) Xpr()                         {}
func (x RltSideMax) RltStmXpr()                   {}
func (x RltSideMid) Xpr()                         {}
func (x RltSideMid) RltStmXpr()                   {}
func (x RltSideMdn) Xpr()                         {}
func (x RltSideMdn) RltStmXpr()                   {}
func (x RltSideSma) Xpr()                         {}
func (x RltSideSma) RltStmXpr()                   {}
func (x RltSideGma) Xpr()                         {}
func (x RltSideGma) RltStmXpr()                   {}
func (x RltSideWma) Xpr()                         {}
func (x RltSideWma) RltStmXpr()                   {}
func (x RltSideRsi) Xpr()                         {}
func (x RltSideRsi) RltStmXpr()                   {}
func (x RltSideWrsi) Xpr()                        {}
func (x RltSideWrsi) RltStmXpr()                  {}
func (x RltSideAlma) Xpr()                        {}
func (x RltSideAlma) RltStmXpr()                  {}
func (x RltSideVrnc) Xpr()                        {}
func (x RltSideVrnc) RltStmXpr()                  {}
func (x RltSideStd) Xpr()                         {}
func (x RltSideStd) RltStmXpr()                   {}
func (x RltSideRngFul) Xpr()                      {}
func (x RltSideRngFul) RltStmXpr()                {}
func (x RltSideRngLst) Xpr()                      {}
func (x RltSideRngLst) RltStmXpr()                {}
func (x RltSideProLst) Xpr()                      {}
func (x RltSideProLst) RltStmXpr()                {}
func (x RltSideProSma) Xpr()                      {}
func (x RltSideProSma) RltStmXpr()                {}
func (x RltSideProAlma) Xpr()                     {}
func (x RltSideProAlma) RltStmXpr()               {}
func (x RltSideSar) Xpr()                         {}
func (x RltSideSar) RltStmXpr()                   {}
func (x RltSideEma) Xpr()                         {}
func (x RltSideEma) RltStmXpr()                   {}
func (x RltStmUnaPos) Xpr()                       {}
func (x RltStmUnaPos) RltStmXpr()                 {}
func (x RltStmUnaNeg) Xpr()                       {}
func (x RltStmUnaNeg) RltStmXpr()                 {}
func (x RltStmUnaInv) Xpr()                       {}
func (x RltStmUnaInv) RltStmXpr()                 {}
func (x RltStmUnaSqr) Xpr()                       {}
func (x RltStmUnaSqr) RltStmXpr()                 {}
func (x RltStmUnaSqrt) Xpr()                      {}
func (x RltStmUnaSqrt) RltStmXpr()                {}
func (x RltStmSclAdd) Xpr()                       {}
func (x RltStmSclAdd) RltStmXpr()                 {}
func (x RltStmSclSub) Xpr()                       {}
func (x RltStmSclSub) RltStmXpr()                 {}
func (x RltStmSclMul) Xpr()                       {}
func (x RltStmSclMul) RltStmXpr()                 {}
func (x RltStmSclDiv) Xpr()                       {}
func (x RltStmSclDiv) RltStmXpr()                 {}
func (x RltStmSclRem) Xpr()                       {}
func (x RltStmSclRem) RltStmXpr()                 {}
func (x RltStmSclPow) Xpr()                       {}
func (x RltStmSclPow) RltStmXpr()                 {}
func (x RltStmSclMin) Xpr()                       {}
func (x RltStmSclMin) RltStmXpr()                 {}
func (x RltStmSclMax) Xpr()                       {}
func (x RltStmSclMax) RltStmXpr()                 {}
func (x RltStmSelEql) Xpr()                       {}
func (x RltStmSelEql) RltStmXpr()                 {}
func (x RltStmSelNeq) Xpr()                       {}
func (x RltStmSelNeq) RltStmXpr()                 {}
func (x RltStmSelLss) Xpr()                       {}
func (x RltStmSelLss) RltStmXpr()                 {}
func (x RltStmSelGtr) Xpr()                       {}
func (x RltStmSelGtr) RltStmXpr()                 {}
func (x RltStmSelLeq) Xpr()                       {}
func (x RltStmSelLeq) RltStmXpr()                 {}
func (x RltStmSelGeq) Xpr()                       {}
func (x RltStmSelGeq) RltStmXpr()                 {}
func (x RltStmAggFst) Xpr()                       {}
func (x RltStmAggFst) RltStmXpr()                 {}
func (x RltStmAggLst) Xpr()                       {}
func (x RltStmAggLst) RltStmXpr()                 {}
func (x RltStmAggSum) Xpr()                       {}
func (x RltStmAggSum) RltStmXpr()                 {}
func (x RltStmAggPrd) Xpr()                       {}
func (x RltStmAggPrd) RltStmXpr()                 {}
func (x RltStmAggMin) Xpr()                       {}
func (x RltStmAggMin) RltStmXpr()                 {}
func (x RltStmAggMax) Xpr()                       {}
func (x RltStmAggMax) RltStmXpr()                 {}
func (x RltStmAggMid) Xpr()                       {}
func (x RltStmAggMid) RltStmXpr()                 {}
func (x RltStmAggMdn) Xpr()                       {}
func (x RltStmAggMdn) RltStmXpr()                 {}
func (x RltStmAggSma) Xpr()                       {}
func (x RltStmAggSma) RltStmXpr()                 {}
func (x RltStmAggGma) Xpr()                       {}
func (x RltStmAggGma) RltStmXpr()                 {}
func (x RltStmAggWma) Xpr()                       {}
func (x RltStmAggWma) RltStmXpr()                 {}
func (x RltStmAggRsi) Xpr()                       {}
func (x RltStmAggRsi) RltStmXpr()                 {}
func (x RltStmAggWrsi) Xpr()                      {}
func (x RltStmAggWrsi) RltStmXpr()                {}
func (x RltStmAggAlma) Xpr()                      {}
func (x RltStmAggAlma) RltStmXpr()                {}
func (x RltStmAggVrnc) Xpr()                      {}
func (x RltStmAggVrnc) RltStmXpr()                {}
func (x RltStmAggStd) Xpr()                       {}
func (x RltStmAggStd) RltStmXpr()                 {}
func (x RltStmAggRngFul) Xpr()                    {}
func (x RltStmAggRngFul) RltStmXpr()              {}
func (x RltStmAggRngLst) Xpr()                    {}
func (x RltStmAggRngLst) RltStmXpr()              {}
func (x RltStmAggProLst) Xpr()                    {}
func (x RltStmAggProLst) RltStmXpr()              {}
func (x RltStmAggProSma) Xpr()                    {}
func (x RltStmAggProSma) RltStmXpr()              {}
func (x RltStmAggProAlma) Xpr()                   {}
func (x RltStmAggProAlma) RltStmXpr()             {}
func (x RltStmAggEma) Xpr()                       {}
func (x RltStmAggEma) RltStmXpr()                 {}
func (x RltStmInrAdd) Xpr()                       {}
func (x RltStmInrAdd) RltStmXpr()                 {}
func (x RltStmInrSub) Xpr()                       {}
func (x RltStmInrSub) RltStmXpr()                 {}
func (x RltStmInrMul) Xpr()                       {}
func (x RltStmInrMul) RltStmXpr()                 {}
func (x RltStmInrDiv) Xpr()                       {}
func (x RltStmInrDiv) RltStmXpr()                 {}
func (x RltStmInrRem) Xpr()                       {}
func (x RltStmInrRem) RltStmXpr()                 {}
func (x RltStmInrPow) Xpr()                       {}
func (x RltStmInrPow) RltStmXpr()                 {}
func (x RltStmInrMin) Xpr()                       {}
func (x RltStmInrMin) RltStmXpr()                 {}
func (x RltStmInrMax) Xpr()                       {}
func (x RltStmInrMax) RltStmXpr()                 {}
func (x RltStmInrSlp) Xpr()                       {}
func (x RltStmInrSlp) RltStmXpr()                 {}
func (x RltStmOtrAdd) Xpr()                       {}
func (x RltStmOtrAdd) RltStmXpr()                 {}
func (x RltStmOtrSub) Xpr()                       {}
func (x RltStmOtrSub) RltStmXpr()                 {}
func (x RltStmOtrMul) Xpr()                       {}
func (x RltStmOtrMul) RltStmXpr()                 {}
func (x RltStmOtrDiv) Xpr()                       {}
func (x RltStmOtrDiv) RltStmXpr()                 {}
func (x RltStmOtrRem) Xpr()                       {}
func (x RltStmOtrRem) RltStmXpr()                 {}
func (x RltStmOtrPow) Xpr()                       {}
func (x RltStmOtrPow) RltStmXpr()                 {}
func (x RltStmOtrMin) Xpr()                       {}
func (x RltStmOtrMin) RltStmXpr()                 {}
func (x RltStmOtrMax) Xpr()                       {}
func (x RltStmOtrMax) RltStmXpr()                 {}
func (x RltStmSclEql) Xpr()                       {}
func (x RltStmSclEql) RltCndXpr()                 {}
func (x RltStmSclNeq) Xpr()                       {}
func (x RltStmSclNeq) RltCndXpr()                 {}
func (x RltStmSclLss) Xpr()                       {}
func (x RltStmSclLss) RltCndXpr()                 {}
func (x RltStmSclGtr) Xpr()                       {}
func (x RltStmSclGtr) RltCndXpr()                 {}
func (x RltStmSclLeq) Xpr()                       {}
func (x RltStmSclLeq) RltCndXpr()                 {}
func (x RltStmSclGeq) Xpr()                       {}
func (x RltStmSclGeq) RltCndXpr()                 {}
func (x RltStmInrEql) Xpr()                       {}
func (x RltStmInrEql) RltCndXpr()                 {}
func (x RltStmInrNeq) Xpr()                       {}
func (x RltStmInrNeq) RltCndXpr()                 {}
func (x RltStmInrLss) Xpr()                       {}
func (x RltStmInrLss) RltCndXpr()                 {}
func (x RltStmInrGtr) Xpr()                       {}
func (x RltStmInrGtr) RltCndXpr()                 {}
func (x RltStmInrLeq) Xpr()                       {}
func (x RltStmInrLeq) RltCndXpr()                 {}
func (x RltStmInrGeq) Xpr()                       {}
func (x RltStmInrGeq) RltCndXpr()                 {}
func (x RltStmOtrEql) Xpr()                       {}
func (x RltStmOtrEql) RltCndXpr()                 {}
func (x RltStmOtrNeq) Xpr()                       {}
func (x RltStmOtrNeq) RltCndXpr()                 {}
func (x RltStmOtrLss) Xpr()                       {}
func (x RltStmOtrLss) RltCndXpr()                 {}
func (x RltStmOtrGtr) Xpr()                       {}
func (x RltStmOtrGtr) RltCndXpr()                 {}
func (x RltStmOtrLeq) Xpr()                       {}
func (x RltStmOtrLeq) RltCndXpr()                 {}
func (x RltStmOtrGeq) Xpr()                       {}
func (x RltStmOtrGeq) RltCndXpr()                 {}
func (x RltCndAnd) Xpr()                          {}
func (x RltCndAnd) RltCndXpr()                    {}
func (x RltCndSeq) Xpr()                          {}
func (x RltCndSeq) RltCndXpr()                    {}
func (x RltCndStgy) Xpr()                         {}
func (x RltCndStgy) RltStgyXpr()                  {}
func (x PltPltSho) Xpr()                          {}
func (x PltPltSho) PltPltXpr()                    {}
func (x PltPltSiz) Xpr()                          {}
func (x PltPltSiz) PltPltXpr()                    {}
func (x PltPltScl) Xpr()                          {}
func (x PltPltScl) PltPltXpr()                    {}
func (x PltPltHrzScl) Xpr()                       {}
func (x PltPltHrzScl) PltPltXpr()                 {}
func (x PltPltVrtScl) Xpr()                       {}
func (x PltPltVrtScl) PltPltXpr()                 {}
func (x PllWait) Xpr()                            {}
func (x *Xprr) Prs(txt string) (scp *Scp, xprs []Xpr) {
	x.Reset(txt)
	scp = NewScp()
	return scp, x.Xprs(scp)
}
func (x *Xprr) Prsf(format string, args ...interface{}) (scp *Scp, xprs []Xpr) {
	return x.Prs(fmt.Sprintf(format, args...))
}
func (x *Xprr) Xprs(scp *Scp) (r []Xpr) {
	for !x.End {
		r = append(r, x.Xpr(scp))
		x.SkpSpceCmnt()
	}
	return r
}
func (x *Xprr) Xpr(scp *Scp, retNil ...bool) (r Xpr) {
	x.SkpSpceCmnt()
	var ok bool
	scn := x.Scn // lit: bsc
	strLitTrm, ok := x.StrLit()
	if ok {
		return x.StrStrXpr(scp, &StrStrLit{Trm: strLitTrm})
	}
	x.Scn = scn
	bolLitTrm, ok := x.BolLit()
	if ok {
		return x.BolBolXpr(scp, &BolBolLit{Trm: bolLitTrm})
	}
	x.Scn = scn
	fltLitTrm, ok := x.FltLit()
	if ok {
		return x.FltFltXpr(scp, &FltFltLit{Trm: fltLitTrm})
	}
	x.Scn = scn
	fltRngLitTrm, ok := x.FltRngLit()
	if ok {
		return x.FltRngXpr(scp, &FltRngLit{Trm: fltRngLitTrm})
	}
	x.Scn = scn
	untLitTrm, ok := x.UntLit()
	if ok {
		return x.UntUntXpr(scp, &UntUntLit{Trm: untLitTrm})
	}
	x.Scn = scn
	intLitTrm, ok := x.IntLit()
	if ok {
		return x.IntIntXpr(scp, &IntIntLit{Trm: intLitTrm})
	}
	x.Scn = scn
	tmeLitTrm, ok := x.TmeLit()
	if ok {
		return x.TmeTmeXpr(scp, &TmeTmeLit{Trm: tmeLitTrm})
	}
	x.Scn = scn
	tmeRngLitTrm, ok := x.TmeRngLit()
	if ok {
		return x.TmeRngXpr(scp, &TmeRngLit{Trm: tmeRngLitTrm})
	}
	x.Scn = scn
	bndLitTrm, ok := x.BndLit()
	if ok {
		return x.BndBndXpr(scp, &BndBndLit{Trm: bndLitTrm})
	}
	x.Scn = scn
	pllWait, ok := x.PllWait() // pllWait
	if ok {
		x.NextLprn()
		x.SkpSpceCmnt()
		pllWaitScp := NewScp(scp)
		var xprs []Xpr
		for {
			cur := x.Xpr(pllWaitScp, true)
			if cur == nil {
				break
			}
			xprs = append(xprs, cur)
		}
		x.NextRprn()
		return &PllWait{Trm: pllWait, Xprs: xprs, Scp: pllWaitScp}
	}
	x.Scn = scn
	switch x.Ch {
	case '[': // arr: lit
		tmeRngsLitTrm, ok := x.TmeRngsLit()
		if ok {
			return x.TmeRngsXpr(scp, &TmeRngsLit{Trm: tmeRngsLitTrm})
		}
		x.Scn = scn
		strsLitTrm, ok := x.StrsLit()
		if ok {
			return x.StrsStrsXpr(scp, &StrsStrsLit{Trm: strsLitTrm})
		}
		x.Scn = scn
		bolsLitTrm, ok := x.BolsLit()
		if ok {
			return x.BolsBolsXpr(scp, &BolsBolsLit{Trm: bolsLitTrm})
		}
		x.Scn = scn
		fltsLitTrm, ok := x.FltsLit()
		if ok {
			return x.FltsFltsXpr(scp, &FltsFltsLit{Trm: fltsLitTrm})
		}
		x.Scn = scn
		untsLitTrm, ok := x.UntsLit()
		if ok {
			return x.UntsUntsXpr(scp, &UntsUntsLit{Trm: untsLitTrm})
		}
		x.Scn = scn
		intsLitTrm, ok := x.IntsLit()
		if ok {
			return x.IntsIntsXpr(scp, &IntsIntsLit{Trm: intsLitTrm})
		}
		x.Scn = scn
		tmesLitTrm, ok := x.TmesLit()
		if ok {
			return x.TmesTmesXpr(scp, &TmesTmesLit{Trm: tmesLitTrm})
		}
		x.Scn = scn
		bndsLitTrm, ok := x.BndsLit()
		if ok {
			return x.BndsBndsXpr(scp, &BndsBndsLit{Trm: bndsLitTrm})
		}
		x.Scn = scn
		objsLitTrm, ok := x.ObjsLit() // arr: obj
		if ok {
			x.Scn = scn
			x.NextRune() // skp lsqr
			var xprs []Xpr
			for !x.End && x.Ch != ']' {
				xprs = append(xprs, x.Xpr(scp))
				x.SkpSpceCmnt()
			}
			x.NextRune() // skp rsqr
			if len(xprs) == 0 {
				x.Panicf("empty array")
			}
			switch xprs[0].(type) {
			case AnaTrdXpr:
				i0 := make([]AnaTrdXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(AnaTrdXpr)
					if !ok {
						x.Panicf("inconsistent array (0:AnaTrdXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.AnaTrdsXpr(scp, &AnaNewTrds{Trm: objsLitTrm.Bnd, I0: i0})
			case AnaPrfmXpr:
				i0 := make([]AnaPrfmXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(AnaPrfmXpr)
					if !ok {
						x.Panicf("inconsistent array (0:AnaPrfmXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.AnaPrfmsXpr(scp, &AnaNewPrfms{Trm: objsLitTrm.Bnd, I0: i0})
			case HstPrvXpr:
				i0 := make([]HstPrvXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstPrvXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstPrvXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstPrvsXpr(scp, &HstNewPrvs{Trm: objsLitTrm.Bnd, I0: i0})
			case HstInstrXpr:
				i0 := make([]HstInstrXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstInstrXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstInstrXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstInstrsXpr(scp, &HstNewInstrs{Trm: objsLitTrm.Bnd, I0: i0})
			case HstInrvlXpr:
				i0 := make([]HstInrvlXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstInrvlXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstInrvlXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstInrvlsXpr(scp, &HstNewInrvls{Trm: objsLitTrm.Bnd, I0: i0})
			case HstSideXpr:
				i0 := make([]HstSideXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstSideXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstSideXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstSidesXpr(scp, &HstNewSides{Trm: objsLitTrm.Bnd, I0: i0})
			case HstStmXpr:
				i0 := make([]HstStmXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstStmXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstStmXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstStmsXpr(scp, &HstNewStms{Trm: objsLitTrm.Bnd, I0: i0})
			case HstCndXpr:
				i0 := make([]HstCndXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstCndXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstCndXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstCndsXpr(scp, &HstNewCnds{Trm: objsLitTrm.Bnd, I0: i0})
			case HstStgyXpr:
				i0 := make([]HstStgyXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(HstStgyXpr)
					if !ok {
						x.Panicf("inconsistent array (0:HstStgyXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.HstStgysXpr(scp, &HstNewStgys{Trm: objsLitTrm.Bnd, I0: i0})
			case RltPrvXpr:
				i0 := make([]RltPrvXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltPrvXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltPrvXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltPrvsXpr(scp, &RltNewPrvs{Trm: objsLitTrm.Bnd, I0: i0})
			case RltInstrXpr:
				i0 := make([]RltInstrXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltInstrXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltInstrXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltInstrsXpr(scp, &RltNewInstrs{Trm: objsLitTrm.Bnd, I0: i0})
			case RltInrvlXpr:
				i0 := make([]RltInrvlXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltInrvlXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltInrvlXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltInrvlsXpr(scp, &RltNewInrvls{Trm: objsLitTrm.Bnd, I0: i0})
			case RltSideXpr:
				i0 := make([]RltSideXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltSideXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltSideXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltSidesXpr(scp, &RltNewSides{Trm: objsLitTrm.Bnd, I0: i0})
			case RltStmXpr:
				i0 := make([]RltStmXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltStmXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltStmXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltStmsXpr(scp, &RltNewStms{Trm: objsLitTrm.Bnd, I0: i0})
			case RltCndXpr:
				i0 := make([]RltCndXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltCndXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltCndXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltCndsXpr(scp, &RltNewCnds{Trm: objsLitTrm.Bnd, I0: i0})
			case RltStgyXpr:
				i0 := make([]RltStgyXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(RltStgyXpr)
					if !ok {
						x.Panicf("inconsistent array (0:RltStgyXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.RltStgysXpr(scp, &RltNewStgys{Trm: objsLitTrm.Bnd, I0: i0})
			case PenPenXpr:
				i0 := make([]PenPenXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(PenPenXpr)
					if !ok {
						x.Panicf("inconsistent array (0:PenPenXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.PenPensXpr(scp, &PenNewPens{Trm: objsLitTrm.Bnd, I0: i0})
			case PltPltXpr:
				i0 := make([]PltPltXpr, len(xprs))
				for n, xpr := range xprs {
					elm, ok := xpr.(PltPltXpr)
					if !ok {
						x.Panicf("inconsistent array (0:PltPltXpr %v:%v)", n, xpr)
					}
					i0[n] = elm
				}
				return x.PltPltsXpr(scp, &PltNewPlts{Trm: objsLitTrm.Bnd, I0: i0})
			}
		}
		x.Scn = scn
	case 'a':
		r, ok = x.AnaPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'b':
		r, ok = x.BolPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.BndPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.BolsPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.BndsPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'c':
		r, ok = x.ClrPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'f':
		r, ok = x.FltPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.FltsPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.FntPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'h':
		r, ok = x.HstPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'i':
		r, ok = x.IntPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.IntsPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'l':
		r, ok = x.LogPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'p':
		r, ok = x.PenPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.PltPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'r':
		r, ok = x.RltPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 's':
		r, ok = x.SysPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.StrPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.StrsPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 't':
		r, ok = x.TmePkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.TmesPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	case 'u':
		r, ok = x.UntPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
		r, ok = x.UntsPkgXpr(scp)
		if ok {
			return r
		}
		x.Scn = scn
	}
	idn, ok := x.IdnLit() // acs
	if ok {
		xprKnd, exists := scp.Knd(x.Txt[idn.Idx:idn.Lim])
		if !exists {
			x.Panicf("acs xpr: idn '%v' not declared", x.Txt[idn.Idx:idn.Lim])
		}
		switch xprKnd {
		case knd.SysMu:
			return x.SysMuXpr(scp, &SysMuAcs{Trm: idn.Bnd})
		case knd.StrStr:
			return x.StrStrXpr(scp, &StrStrAcs{Trm: idn.Bnd})
		case knd.BolBol:
			return x.BolBolXpr(scp, &BolBolAcs{Trm: idn.Bnd})
		case knd.FltFlt:
			return x.FltFltXpr(scp, &FltFltAcs{Trm: idn.Bnd})
		case knd.FltRng:
			return x.FltRngXpr(scp, &FltRngAcs{Trm: idn.Bnd})
		case knd.UntUnt:
			return x.UntUntXpr(scp, &UntUntAcs{Trm: idn.Bnd})
		case knd.IntInt:
			return x.IntIntXpr(scp, &IntIntAcs{Trm: idn.Bnd})
		case knd.TmeTme:
			return x.TmeTmeXpr(scp, &TmeTmeAcs{Trm: idn.Bnd})
		case knd.TmeRng:
			return x.TmeRngXpr(scp, &TmeRngAcs{Trm: idn.Bnd})
		case knd.TmeRngs:
			return x.TmeRngsXpr(scp, &TmeRngsAcs{Trm: idn.Bnd})
		case knd.BndBnd:
			return x.BndBndXpr(scp, &BndBndAcs{Trm: idn.Bnd})
		case knd.StrsStrs:
			return x.StrsStrsXpr(scp, &StrsStrsAcs{Trm: idn.Bnd})
		case knd.BolsBols:
			return x.BolsBolsXpr(scp, &BolsBolsAcs{Trm: idn.Bnd})
		case knd.FltsFlts:
			return x.FltsFltsXpr(scp, &FltsFltsAcs{Trm: idn.Bnd})
		case knd.UntsUnts:
			return x.UntsUntsXpr(scp, &UntsUntsAcs{Trm: idn.Bnd})
		case knd.IntsInts:
			return x.IntsIntsXpr(scp, &IntsIntsAcs{Trm: idn.Bnd})
		case knd.TmesTmes:
			return x.TmesTmesXpr(scp, &TmesTmesAcs{Trm: idn.Bnd})
		case knd.BndsBnds:
			return x.BndsBndsXpr(scp, &BndsBndsAcs{Trm: idn.Bnd})
		case knd.AnaTrd:
			return x.AnaTrdXpr(scp, &AnaTrdAcs{Trm: idn.Bnd})
		case knd.AnaTrds:
			return x.AnaTrdsXpr(scp, &AnaTrdsAcs{Trm: idn.Bnd})
		case knd.AnaPrfm:
			return x.AnaPrfmXpr(scp, &AnaPrfmAcs{Trm: idn.Bnd})
		case knd.AnaPrfms:
			return x.AnaPrfmsXpr(scp, &AnaPrfmsAcs{Trm: idn.Bnd})
		case knd.AnaPrfmDlt:
			return x.AnaPrfmDltXpr(scp, &AnaPrfmDltAcs{Trm: idn.Bnd})
		case knd.AnaPort:
			return x.AnaPortXpr(scp, &AnaPortAcs{Trm: idn.Bnd})
		case knd.HstPrv:
			return x.HstPrvXpr(scp, &HstPrvAcs{Trm: idn.Bnd})
		case knd.HstInstr:
			return x.HstInstrXpr(scp, &HstInstrAcs{Trm: idn.Bnd})
		case knd.HstInrvl:
			return x.HstInrvlXpr(scp, &HstInrvlAcs{Trm: idn.Bnd})
		case knd.HstSide:
			return x.HstSideXpr(scp, &HstSideAcs{Trm: idn.Bnd})
		case knd.HstStm:
			return x.HstStmXpr(scp, &HstStmAcs{Trm: idn.Bnd})
		case knd.HstCnd:
			return x.HstCndXpr(scp, &HstCndAcs{Trm: idn.Bnd})
		case knd.HstStgy:
			return x.HstStgyXpr(scp, &HstStgyAcs{Trm: idn.Bnd})
		case knd.HstPrvs:
			return x.HstPrvsXpr(scp, &HstPrvsAcs{Trm: idn.Bnd})
		case knd.HstInstrs:
			return x.HstInstrsXpr(scp, &HstInstrsAcs{Trm: idn.Bnd})
		case knd.HstInrvls:
			return x.HstInrvlsXpr(scp, &HstInrvlsAcs{Trm: idn.Bnd})
		case knd.HstSides:
			return x.HstSidesXpr(scp, &HstSidesAcs{Trm: idn.Bnd})
		case knd.HstStms:
			return x.HstStmsXpr(scp, &HstStmsAcs{Trm: idn.Bnd})
		case knd.HstCnds:
			return x.HstCndsXpr(scp, &HstCndsAcs{Trm: idn.Bnd})
		case knd.HstStgys:
			return x.HstStgysXpr(scp, &HstStgysAcs{Trm: idn.Bnd})
		case knd.RltPrv:
			return x.RltPrvXpr(scp, &RltPrvAcs{Trm: idn.Bnd})
		case knd.RltInstr:
			return x.RltInstrXpr(scp, &RltInstrAcs{Trm: idn.Bnd})
		case knd.RltInrvl:
			return x.RltInrvlXpr(scp, &RltInrvlAcs{Trm: idn.Bnd})
		case knd.RltSide:
			return x.RltSideXpr(scp, &RltSideAcs{Trm: idn.Bnd})
		case knd.RltStm:
			return x.RltStmXpr(scp, &RltStmAcs{Trm: idn.Bnd})
		case knd.RltCnd:
			return x.RltCndXpr(scp, &RltCndAcs{Trm: idn.Bnd})
		case knd.RltStgy:
			return x.RltStgyXpr(scp, &RltStgyAcs{Trm: idn.Bnd})
		case knd.RltPrvs:
			return x.RltPrvsXpr(scp, &RltPrvsAcs{Trm: idn.Bnd})
		case knd.RltInstrs:
			return x.RltInstrsXpr(scp, &RltInstrsAcs{Trm: idn.Bnd})
		case knd.RltInrvls:
			return x.RltInrvlsXpr(scp, &RltInrvlsAcs{Trm: idn.Bnd})
		case knd.RltSides:
			return x.RltSidesXpr(scp, &RltSidesAcs{Trm: idn.Bnd})
		case knd.RltStms:
			return x.RltStmsXpr(scp, &RltStmsAcs{Trm: idn.Bnd})
		case knd.RltCnds:
			return x.RltCndsXpr(scp, &RltCndsAcs{Trm: idn.Bnd})
		case knd.RltStgys:
			return x.RltStgysXpr(scp, &RltStgysAcs{Trm: idn.Bnd})
		case knd.FntFnt:
			return x.FntFntXpr(scp, &FntFntAcs{Trm: idn.Bnd})
		case knd.ClrClr:
			return x.ClrClrXpr(scp, &ClrClrAcs{Trm: idn.Bnd})
		case knd.PenPen:
			return x.PenPenXpr(scp, &PenPenAcs{Trm: idn.Bnd})
		case knd.PenPens:
			return x.PenPensXpr(scp, &PenPensAcs{Trm: idn.Bnd})
		case knd.PltPlt:
			return x.PltPltXpr(scp, &PltPltAcs{Trm: idn.Bnd})
		case knd.PltPlts:
			return x.PltPltsXpr(scp, &PltPltsAcs{Trm: idn.Bnd})
		case knd.PltStm:
			return x.PltStmXpr(scp, &PltStmAcs{Trm: idn.Bnd})
		case knd.PltFltsSctr:
			return x.PltFltsSctrXpr(scp, &PltFltsSctrAcs{Trm: idn.Bnd})
		case knd.PltFltsSctrDist:
			return x.PltFltsSctrDistXpr(scp, &PltFltsSctrDistAcs{Trm: idn.Bnd})
		case knd.PltHrz:
			return x.PltHrzXpr(scp, &PltHrzAcs{Trm: idn.Bnd})
		case knd.PltVrt:
			return x.PltVrtXpr(scp, &PltVrtAcs{Trm: idn.Bnd})
		case knd.PltDpth:
			return x.PltDpthXpr(scp, &PltDpthAcs{Trm: idn.Bnd})
		}
	}
	x.Scn = scn // rewind
	if len(retNil) > 0 && retNil[0] {
		return nil
	}
	panic(x.Erf("Xpr: no expression found"))
}
func (x *Xprr) SysPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Sys()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'n':
				newMuTrm, ok := x.NewMu()
				if ok {
					x.NextLprn()
					cur := &SysNewMu{Trm: newMuTrm}
					x.NextRprn()
					return x.SysMuXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("SysPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) SysIdnXpr(scp *Scp, X SysIdnXpr) Xpr {
	if x.HasMem() {
		x.Panicf("SysIdnXpr: no expression found")
	}
	return X
}
func (x *Xprr) SysMuXpr(scp *Scp, X SysMuXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Sys asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Sys asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Sys asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.SysMu)
				return x.SysMuXpr(scp, &SysMuAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'l':
			lckTrm, ok := x.Lck()
			if ok {
				x.NextLprn()
				cur := &SysMuLck{Trm: lckTrm, X: X}
				x.NextRprn()
				return x.SysMuXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			ulckTrm, ok := x.Ulck()
			if ok {
				x.NextLprn()
				cur := &SysMuUlck{Trm: ulckTrm, X: X}
				x.NextRprn()
				return x.SysMuXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("SysMuXpr: no expression found")
	}
	return X
}
func (x *Xprr) LogPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Log()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'i':
				ifoTrm, ok := x.Ifo()
				if ok {
					x.NextLprn()
					var i0 []Xpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(Xpr)
						if !ok {
							x.Panicf("LogPkgXpr: Ifo: non Xpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &LogIfo{Trm: ifoTrm, I0: i0}
					x.NextRprn()
					return x.StrStrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				ifofTrm, ok := x.Ifof()
				if ok {
					x.NextLprn()
					i0 := x.Xpr(scp).(StrStrXpr)
					var i1 []Xpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(Xpr)
						if !ok {
							x.Panicf("LogPkgXpr: Ifof: non Xpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i1 = append(i1, v)
					}
					cur := &LogIfof{Trm: ifofTrm, I0: i0, I1: i1}
					x.NextRprn()
					return x.StrStrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("LogPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) LogLogrXpr(scp *Scp, X LogLogrXpr) Xpr {
	if x.HasMem() {
		x.Panicf("LogLogrXpr: no expression found")
	}
	return X
}
func (x *Xprr) StrPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Str()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'e':
				emptyTrm, ok := x.Empty()
				if ok {
					return x.StrStrXpr(scp, &StrEmpty{Trm: emptyTrm}), true
				}
				x.Scn = scn // rewind
			case 'f':
				fmtTrm, ok := x.Fmt()
				if ok {
					x.NextLprn()
					i0 := x.Xpr(scp).(StrStrXpr)
					var i1 []Xpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(Xpr)
						if !ok {
							x.Panicf("StrPkgXpr: Fmt: non Xpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i1 = append(i1, v)
					}
					cur := &StrFmt{Trm: fmtTrm, I0: i0, I1: i1}
					x.NextRprn()
					return x.StrStrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'z':
				zeroTrm, ok := x.Zero()
				if ok {
					return x.StrStrXpr(scp, &StrZero{Trm: zeroTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("StrPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) StrStrXpr(scp *Scp, X StrStrXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Str asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Str asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Str asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.StrStr)
				return x.StrStrXpr(scp, &StrStrAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'e':
			eqlTrm, ok := x.Eql()
			if ok {
				x.NextLprn()
				cur := &StrStrEql{Trm: eqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gtrTrm, ok := x.Gtr()
			if ok {
				x.NextLprn()
				cur := &StrStrGtr{Trm: gtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			geqTrm, ok := x.Geq()
			if ok {
				x.NextLprn()
				cur := &StrStrGeq{Trm: geqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lowerTrm, ok := x.Lower()
			if ok {
				x.NextLprn()
				cur := &StrStrLower{Trm: lowerTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lssTrm, ok := x.Lss()
			if ok {
				x.NextLprn()
				cur := &StrStrLss{Trm: lssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			leqTrm, ok := x.Leq()
			if ok {
				x.NextLprn()
				cur := &StrStrLeq{Trm: leqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			neqTrm, ok := x.Neq()
			if ok {
				x.NextLprn()
				cur := &StrStrNeq{Trm: neqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			upperTrm, ok := x.Upper()
			if ok {
				x.NextLprn()
				cur := &StrStrUpper{Trm: upperTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("StrStrXpr: no expression found")
	}
	return X
}
func (x *Xprr) BolPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Bol()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'f':
				flsTrm, ok := x.Fls()
				if ok {
					return x.BolBolXpr(scp, &BolFls{Trm: flsTrm}), true
				}
				x.Scn = scn // rewind
			case 't':
				truTrm, ok := x.Tru()
				if ok {
					return x.BolBolXpr(scp, &BolTru{Trm: truTrm}), true
				}
				x.Scn = scn // rewind
			case 'z':
				zeroTrm, ok := x.Zero()
				if ok {
					return x.BolBolXpr(scp, &BolZero{Trm: zeroTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("BolPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) BolBolXpr(scp *Scp, X BolBolXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bol asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Bol asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Bol asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BolBol)
				return x.BolBolXpr(scp, &BolBolAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'e':
			elseTrm, ok := x.Else()
			if ok {
				x.NextLprn()
				elseScp := NewScp(scp)
				var xprs []Xpr
				for {
					cur := x.Xpr(elseScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return x.BolBolXpr(scp, &BolBolElse{Trm: elseTrm, X: X, Xprs: xprs, Scp: elseScp})
			}
			x.Scn = scn
			eqlTrm, ok := x.Eql()
			if ok {
				x.NextLprn()
				cur := &BolBolEql{Trm: eqlTrm, X: X, I0: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			notTrm, ok := x.Not()
			if ok {
				x.NextLprn()
				cur := &BolBolNot{Trm: notTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			neqTrm, ok := x.Neq()
			if ok {
				x.NextLprn()
				cur := &BolBolNeq{Trm: neqTrm, X: X, I0: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			thenTrm, ok := x.Then()
			if ok {
				x.NextLprn()
				thenScp := NewScp(scp)
				var xprs []Xpr
				for {
					cur := x.Xpr(thenScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return x.BolBolXpr(scp, &BolBolThen{Trm: thenTrm, X: X, Xprs: xprs, Scp: thenScp})
			}
			x.Scn = scn
		}
		x.Panicf("BolBolXpr: no expression found")
	}
	return X
}
func (x *Xprr) FltPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Flt()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'h':
				hndrdTrm, ok := x.Hndrd()
				if ok {
					return x.FltFltXpr(scp, &FltHndrd{Trm: hndrdTrm}), true
				}
				x.Scn = scn // rewind
			case 'm':
				minTrm, ok := x.Min()
				if ok {
					return x.FltFltXpr(scp, &FltMin{Trm: minTrm}), true
				}
				x.Scn = scn // rewind
				maxTrm, ok := x.Max()
				if ok {
					return x.FltFltXpr(scp, &FltMax{Trm: maxTrm}), true
				}
				x.Scn = scn // rewind
			case 'n':
				negOneTrm, ok := x.NegOne()
				if ok {
					return x.FltFltXpr(scp, &FltNegOne{Trm: negOneTrm}), true
				}
				x.Scn = scn // rewind
				newRngTrm, ok := x.NewRng()
				if ok {
					x.NextLprn()
					cur := &FltNewRng{Trm: newRngTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltRngXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newRngArndTrm, ok := x.NewRngArnd()
				if ok {
					x.NextLprn()
					cur := &FltNewRngArnd{Trm: newRngArndTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltRngXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newRngFulTrm, ok := x.NewRngFul()
				if ok {
					x.NextLprn()
					cur := &FltNewRngFul{Trm: newRngFulTrm}
					x.NextRprn()
					return x.FltRngXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'o':
				oneTrm, ok := x.One()
				if ok {
					return x.FltFltXpr(scp, &FltOne{Trm: oneTrm}), true
				}
				x.Scn = scn // rewind
			case 't':
				tinyTrm, ok := x.Tiny()
				if ok {
					return x.FltFltXpr(scp, &FltTiny{Trm: tinyTrm}), true
				}
				x.Scn = scn // rewind
			case 'z':
				zeroTrm, ok := x.Zero()
				if ok {
					return x.FltFltXpr(scp, &FltZero{Trm: zeroTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("FltPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) FltFltXpr(scp *Scp, X FltFltXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Flt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Flt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Flt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.FltFlt)
				return x.FltFltXpr(scp, &FltFltAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			addTrm, ok := x.Add()
			if ok {
				x.NextLprn()
				cur := &FltFltAdd{Trm: addTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgTrm, ok := x.Avg()
			if ok {
				x.NextLprn()
				cur := &FltFltAvg{Trm: avgTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgGeoTrm, ok := x.AvgGeo()
			if ok {
				x.NextLprn()
				cur := &FltFltAvgGeo{Trm: avgGeoTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			divTrm, ok := x.Div()
			if ok {
				x.NextLprn()
				cur := &FltFltDiv{Trm: divTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eqlTrm, ok := x.Eql()
			if ok {
				x.NextLprn()
				cur := &FltFltEql{Trm: eqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gtrTrm, ok := x.Gtr()
			if ok {
				x.NextLprn()
				cur := &FltFltGtr{Trm: gtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			geqTrm, ok := x.Geq()
			if ok {
				x.NextLprn()
				cur := &FltFltGeq{Trm: geqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			isNaNTrm, ok := x.IsNaN()
			if ok {
				x.NextLprn()
				cur := &FltFltIsNaN{Trm: isNaNTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isInfPosTrm, ok := x.IsInfPos()
			if ok {
				x.NextLprn()
				cur := &FltFltIsInfPos{Trm: isInfPosTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isInfNegTrm, ok := x.IsInfNeg()
			if ok {
				x.NextLprn()
				cur := &FltFltIsInfNeg{Trm: isInfNegTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isValidTrm, ok := x.IsValid()
			if ok {
				x.NextLprn()
				cur := &FltFltIsValid{Trm: isValidTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			invTrm, ok := x.Inv()
			if ok {
				x.NextLprn()
				cur := &FltFltInv{Trm: invTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lssTrm, ok := x.Lss()
			if ok {
				x.NextLprn()
				cur := &FltFltLss{Trm: lssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			leqTrm, ok := x.Leq()
			if ok {
				x.NextLprn()
				cur := &FltFltLeq{Trm: leqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mulTrm, ok := x.Mul()
			if ok {
				x.NextLprn()
				cur := &FltFltMul{Trm: mulTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &FltFltMin{Trm: minTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &FltFltMax{Trm: maxTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &FltFltMid{Trm: midTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			neqTrm, ok := x.Neq()
			if ok {
				x.NextLprn()
				cur := &FltFltNeq{Trm: neqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			negTrm, ok := x.Neg()
			if ok {
				x.NextLprn()
				cur := &FltFltNeg{Trm: negTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pctTrm, ok := x.Pct()
			if ok {
				x.NextLprn()
				cur := &FltFltPct{Trm: pctTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			posTrm, ok := x.Pos()
			if ok {
				x.NextLprn()
				cur := &FltFltPos{Trm: posTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			powTrm, ok := x.Pow()
			if ok {
				x.NextLprn()
				cur := &FltFltPow{Trm: powTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			remTrm, ok := x.Rem()
			if ok {
				x.NextLprn()
				cur := &FltFltRem{Trm: remTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			subTrm, ok := x.Sub()
			if ok {
				x.NextLprn()
				cur := &FltFltSub{Trm: subTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrTrm, ok := x.Sqr()
			if ok {
				x.NextLprn()
				cur := &FltFltSqr{Trm: sqrTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrtTrm, ok := x.Sqrt()
			if ok {
				x.NextLprn()
				cur := &FltFltSqrt{Trm: sqrtTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selEqlTrm, ok := x.SelEql()
			if ok {
				x.NextLprn()
				cur := &FltFltSelEql{Trm: selEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selNeqTrm, ok := x.SelNeq()
			if ok {
				x.NextLprn()
				cur := &FltFltSelNeq{Trm: selNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLssTrm, ok := x.SelLss()
			if ok {
				x.NextLprn()
				cur := &FltFltSelLss{Trm: selLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGtrTrm, ok := x.SelGtr()
			if ok {
				x.NextLprn()
				cur := &FltFltSelGtr{Trm: selGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLeqTrm, ok := x.SelLeq()
			if ok {
				x.NextLprn()
				cur := &FltFltSelLeq{Trm: selLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGeqTrm, ok := x.SelGeq()
			if ok {
				x.NextLprn()
				cur := &FltFltSelGeq{Trm: selGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			trncTrm, ok := x.Trnc()
			if ok {
				x.NextLprn()
				cur := &FltFltTrnc{Trm: trncTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("FltFltXpr: no expression found")
	}
	return X
}
func (x *Xprr) FltRngXpr(scp *Scp, X FltRngXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Flt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Flt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Flt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.FltRng)
				return x.FltRngXpr(scp, &FltRngAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'e':
			ensureTrm, ok := x.Ensure()
			if ok {
				x.NextLprn()
				cur := &FltRngEnsure{Trm: ensureTrm, X: X}
				x.NextRprn()
				return x.FltRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			isValidTrm, ok := x.IsValid()
			if ok {
				x.NextLprn()
				cur := &FltRngIsValid{Trm: isValidTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lenTrm, ok := x.Len()
			if ok {
				x.NextLprn()
				cur := &FltRngLen{Trm: lenTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			minSubTrm, ok := x.MinSub()
			if ok {
				x.NextLprn()
				cur := &FltRngMinSub{Trm: minSubTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxAddTrm, ok := x.MaxAdd()
			if ok {
				x.NextLprn()
				cur := &FltRngMaxAdd{Trm: maxAddTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				cur := &FltRngMrg{Trm: mrgTrm, X: X, I0: x.Xpr(scp).(FltRngXpr)}
				x.NextRprn()
				return x.FltRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("FltRngXpr: no expression found")
	}
	return X
}
func (x *Xprr) UntPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Unt()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				minTrm, ok := x.Min()
				if ok {
					return x.UntUntXpr(scp, &UntMin{Trm: minTrm}), true
				}
				x.Scn = scn // rewind
				maxTrm, ok := x.Max()
				if ok {
					return x.UntUntXpr(scp, &UntMax{Trm: maxTrm}), true
				}
				x.Scn = scn // rewind
			case 'o':
				oneTrm, ok := x.One()
				if ok {
					return x.UntUntXpr(scp, &UntOne{Trm: oneTrm}), true
				}
				x.Scn = scn // rewind
			case 'z':
				zeroTrm, ok := x.Zero()
				if ok {
					return x.UntUntXpr(scp, &UntZero{Trm: zeroTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("UntPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) UntUntXpr(scp *Scp, X UntUntXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Unt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Unt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Unt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.UntUnt)
				return x.UntUntXpr(scp, &UntUntAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			addTrm, ok := x.Add()
			if ok {
				x.NextLprn()
				cur := &UntUntAdd{Trm: addTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgTrm, ok := x.Avg()
			if ok {
				x.NextLprn()
				cur := &UntUntAvg{Trm: avgTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgGeoTrm, ok := x.AvgGeo()
			if ok {
				x.NextLprn()
				cur := &UntUntAvgGeo{Trm: avgGeoTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			divTrm, ok := x.Div()
			if ok {
				x.NextLprn()
				cur := &UntUntDiv{Trm: divTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eqlTrm, ok := x.Eql()
			if ok {
				x.NextLprn()
				cur := &UntUntEql{Trm: eqlTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gtrTrm, ok := x.Gtr()
			if ok {
				x.NextLprn()
				cur := &UntUntGtr{Trm: gtrTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			geqTrm, ok := x.Geq()
			if ok {
				x.NextLprn()
				cur := &UntUntGeq{Trm: geqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lssTrm, ok := x.Lss()
			if ok {
				x.NextLprn()
				cur := &UntUntLss{Trm: lssTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			leqTrm, ok := x.Leq()
			if ok {
				x.NextLprn()
				cur := &UntUntLeq{Trm: leqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mulTrm, ok := x.Mul()
			if ok {
				x.NextLprn()
				cur := &UntUntMul{Trm: mulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &UntUntMin{Trm: minTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &UntUntMax{Trm: maxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &UntUntMid{Trm: midTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			neqTrm, ok := x.Neq()
			if ok {
				x.NextLprn()
				cur := &UntUntNeq{Trm: neqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			powTrm, ok := x.Pow()
			if ok {
				x.NextLprn()
				cur := &UntUntPow{Trm: powTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			remTrm, ok := x.Rem()
			if ok {
				x.NextLprn()
				cur := &UntUntRem{Trm: remTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			subTrm, ok := x.Sub()
			if ok {
				x.NextLprn()
				cur := &UntUntSub{Trm: subTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrTrm, ok := x.Sqr()
			if ok {
				x.NextLprn()
				cur := &UntUntSqr{Trm: sqrTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrtTrm, ok := x.Sqrt()
			if ok {
				x.NextLprn()
				cur := &UntUntSqrt{Trm: sqrtTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("UntUntXpr: no expression found")
	}
	return X
}
func (x *Xprr) IntPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Int()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				minTrm, ok := x.Min()
				if ok {
					return x.IntIntXpr(scp, &IntMin{Trm: minTrm}), true
				}
				x.Scn = scn // rewind
				maxTrm, ok := x.Max()
				if ok {
					return x.IntIntXpr(scp, &IntMax{Trm: maxTrm}), true
				}
				x.Scn = scn // rewind
			case 'n':
				negOneTrm, ok := x.NegOne()
				if ok {
					return x.IntIntXpr(scp, &IntNegOne{Trm: negOneTrm}), true
				}
				x.Scn = scn // rewind
			case 'o':
				oneTrm, ok := x.One()
				if ok {
					return x.IntIntXpr(scp, &IntOne{Trm: oneTrm}), true
				}
				x.Scn = scn // rewind
			case 'z':
				zeroTrm, ok := x.Zero()
				if ok {
					return x.IntIntXpr(scp, &IntZero{Trm: zeroTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("IntPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) IntIntXpr(scp *Scp, X IntIntXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Int asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Int asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Int asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.IntInt)
				return x.IntIntXpr(scp, &IntIntAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			addTrm, ok := x.Add()
			if ok {
				x.NextLprn()
				cur := &IntIntAdd{Trm: addTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgTrm, ok := x.Avg()
			if ok {
				x.NextLprn()
				cur := &IntIntAvg{Trm: avgTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgGeoTrm, ok := x.AvgGeo()
			if ok {
				x.NextLprn()
				cur := &IntIntAvgGeo{Trm: avgGeoTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			divTrm, ok := x.Div()
			if ok {
				x.NextLprn()
				cur := &IntIntDiv{Trm: divTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eqlTrm, ok := x.Eql()
			if ok {
				x.NextLprn()
				cur := &IntIntEql{Trm: eqlTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gtrTrm, ok := x.Gtr()
			if ok {
				x.NextLprn()
				cur := &IntIntGtr{Trm: gtrTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			geqTrm, ok := x.Geq()
			if ok {
				x.NextLprn()
				cur := &IntIntGeq{Trm: geqTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			invTrm, ok := x.Inv()
			if ok {
				x.NextLprn()
				cur := &IntIntInv{Trm: invTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lssTrm, ok := x.Lss()
			if ok {
				x.NextLprn()
				cur := &IntIntLss{Trm: lssTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			leqTrm, ok := x.Leq()
			if ok {
				x.NextLprn()
				cur := &IntIntLeq{Trm: leqTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mulTrm, ok := x.Mul()
			if ok {
				x.NextLprn()
				cur := &IntIntMul{Trm: mulTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &IntIntMin{Trm: minTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &IntIntMax{Trm: maxTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &IntIntMid{Trm: midTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			neqTrm, ok := x.Neq()
			if ok {
				x.NextLprn()
				cur := &IntIntNeq{Trm: neqTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			negTrm, ok := x.Neg()
			if ok {
				x.NextLprn()
				cur := &IntIntNeg{Trm: negTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			posTrm, ok := x.Pos()
			if ok {
				x.NextLprn()
				cur := &IntIntPos{Trm: posTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			powTrm, ok := x.Pow()
			if ok {
				x.NextLprn()
				cur := &IntIntPow{Trm: powTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			remTrm, ok := x.Rem()
			if ok {
				x.NextLprn()
				cur := &IntIntRem{Trm: remTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			subTrm, ok := x.Sub()
			if ok {
				x.NextLprn()
				cur := &IntIntSub{Trm: subTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrTrm, ok := x.Sqr()
			if ok {
				x.NextLprn()
				cur := &IntIntSqr{Trm: sqrTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrtTrm, ok := x.Sqrt()
			if ok {
				x.NextLprn()
				cur := &IntIntSqrt{Trm: sqrtTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("IntIntXpr: no expression found")
	}
	return X
}
func (x *Xprr) TmePkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Tme()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'd':
				dayTrm, ok := x.Day()
				if ok {
					return x.TmeTmeXpr(scp, &TmeDay{Trm: dayTrm}), true
				}
				x.Scn = scn // rewind
				d1Trm, ok := x.D1()
				if ok {
					return x.TmeTmeXpr(scp, &TmeD1{Trm: d1Trm}), true
				}
				x.Scn = scn // rewind
			case 'h':
				hourTrm, ok := x.Hour()
				if ok {
					return x.TmeTmeXpr(scp, &TmeHour{Trm: hourTrm}), true
				}
				x.Scn = scn // rewind
				h1Trm, ok := x.H1()
				if ok {
					return x.TmeTmeXpr(scp, &TmeH1{Trm: h1Trm}), true
				}
				x.Scn = scn // rewind
			case 'm':
				minTrm, ok := x.Min()
				if ok {
					return x.TmeTmeXpr(scp, &TmeMin{Trm: minTrm}), true
				}
				x.Scn = scn // rewind
				maxTrm, ok := x.Max()
				if ok {
					return x.TmeTmeXpr(scp, &TmeMax{Trm: maxTrm}), true
				}
				x.Scn = scn // rewind
				minuteTrm, ok := x.Minute()
				if ok {
					return x.TmeTmeXpr(scp, &TmeMinute{Trm: minuteTrm}), true
				}
				x.Scn = scn // rewind
				m1Trm, ok := x.M1()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM1{Trm: m1Trm}), true
				}
				x.Scn = scn // rewind
				m5Trm, ok := x.M5()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM5{Trm: m5Trm}), true
				}
				x.Scn = scn // rewind
				m10Trm, ok := x.M10()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM10{Trm: m10Trm}), true
				}
				x.Scn = scn // rewind
				m15Trm, ok := x.M15()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM15{Trm: m15Trm}), true
				}
				x.Scn = scn // rewind
				m20Trm, ok := x.M20()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM20{Trm: m20Trm}), true
				}
				x.Scn = scn // rewind
				m30Trm, ok := x.M30()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM30{Trm: m30Trm}), true
				}
				x.Scn = scn // rewind
				m40Trm, ok := x.M40()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM40{Trm: m40Trm}), true
				}
				x.Scn = scn // rewind
				m50Trm, ok := x.M50()
				if ok {
					return x.TmeTmeXpr(scp, &TmeM50{Trm: m50Trm}), true
				}
				x.Scn = scn // rewind
				makeRngsTrm, ok := x.MakeRngs()
				if ok {
					x.NextLprn()
					cur := &TmeMakeRngs{Trm: makeRngsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.TmeRngsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpRngsTrm, ok := x.MakeEmpRngs()
				if ok {
					x.NextLprn()
					cur := &TmeMakeEmpRngs{Trm: makeEmpRngsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.TmeRngsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				negOneTrm, ok := x.NegOne()
				if ok {
					return x.TmeTmeXpr(scp, &TmeNegOne{Trm: negOneTrm}), true
				}
				x.Scn = scn // rewind
				nowTrm, ok := x.Now()
				if ok {
					x.NextLprn()
					cur := &TmeNow{Trm: nowTrm}
					x.NextRprn()
					return x.TmeTmeXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newRngTrm, ok := x.NewRng()
				if ok {
					x.NextLprn()
					cur := &TmeNewRng{Trm: newRngTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmeRngXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newRngArndTrm, ok := x.NewRngArnd()
				if ok {
					x.NextLprn()
					cur := &TmeNewRngArnd{Trm: newRngArndTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmeRngXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newRngFulTrm, ok := x.NewRngFul()
				if ok {
					x.NextLprn()
					cur := &TmeNewRngFul{Trm: newRngFulTrm}
					x.NextRprn()
					return x.TmeRngXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newRngsTrm, ok := x.NewRngs()
				if ok {
					x.NextLprn()
					var i0 []TmeRngXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(TmeRngXpr)
						if !ok {
							x.Panicf("TmePkgXpr: NewRngs: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &TmeNewRngs{Trm: newRngsTrm, I0: i0}
					x.NextRprn()
					return x.TmeRngsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'o':
				oneTrm, ok := x.One()
				if ok {
					return x.TmeTmeXpr(scp, &TmeOne{Trm: oneTrm}), true
				}
				x.Scn = scn // rewind
			case 'r':
				resolutionTrm, ok := x.Resolution()
				if ok {
					return x.TmeTmeXpr(scp, &TmeResolution{Trm: resolutionTrm}), true
				}
				x.Scn = scn // rewind
			case 's':
				secondTrm, ok := x.Second()
				if ok {
					return x.TmeTmeXpr(scp, &TmeSecond{Trm: secondTrm}), true
				}
				x.Scn = scn // rewind
				s1Trm, ok := x.S1()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS1{Trm: s1Trm}), true
				}
				x.Scn = scn // rewind
				s5Trm, ok := x.S5()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS5{Trm: s5Trm}), true
				}
				x.Scn = scn // rewind
				s10Trm, ok := x.S10()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS10{Trm: s10Trm}), true
				}
				x.Scn = scn // rewind
				s15Trm, ok := x.S15()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS15{Trm: s15Trm}), true
				}
				x.Scn = scn // rewind
				s20Trm, ok := x.S20()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS20{Trm: s20Trm}), true
				}
				x.Scn = scn // rewind
				s30Trm, ok := x.S30()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS30{Trm: s30Trm}), true
				}
				x.Scn = scn // rewind
				s40Trm, ok := x.S40()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS40{Trm: s40Trm}), true
				}
				x.Scn = scn // rewind
				s50Trm, ok := x.S50()
				if ok {
					return x.TmeTmeXpr(scp, &TmeS50{Trm: s50Trm}), true
				}
				x.Scn = scn // rewind
			case 'w':
				weekTrm, ok := x.Week()
				if ok {
					return x.TmeTmeXpr(scp, &TmeWeek{Trm: weekTrm}), true
				}
				x.Scn = scn // rewind
			case 'z':
				zeroTrm, ok := x.Zero()
				if ok {
					return x.TmeTmeXpr(scp, &TmeZero{Trm: zeroTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("TmePkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) TmeTmeXpr(scp *Scp, X TmeTmeXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tme asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Tme asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Tme asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeTme)
				return x.TmeTmeXpr(scp, &TmeTmeAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			addTrm, ok := x.Add()
			if ok {
				x.NextLprn()
				cur := &TmeTmeAdd{Trm: addTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgTrm, ok := x.Avg()
			if ok {
				x.NextLprn()
				cur := &TmeTmeAvg{Trm: avgTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			avgGeoTrm, ok := x.AvgGeo()
			if ok {
				x.NextLprn()
				cur := &TmeTmeAvgGeo{Trm: avgGeoTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dteTrm, ok := x.Dte()
			if ok {
				x.NextLprn()
				cur := &TmeTmeDte{Trm: dteTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			divTrm, ok := x.Div()
			if ok {
				x.NextLprn()
				cur := &TmeTmeDiv{Trm: divTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eqlTrm, ok := x.Eql()
			if ok {
				x.NextLprn()
				cur := &TmeTmeEql{Trm: eqlTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gtrTrm, ok := x.Gtr()
			if ok {
				x.NextLprn()
				cur := &TmeTmeGtr{Trm: gtrTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			geqTrm, ok := x.Geq()
			if ok {
				x.NextLprn()
				cur := &TmeTmeGeq{Trm: geqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			isSundayTrm, ok := x.IsSunday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsSunday{Trm: isSundayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isMondayTrm, ok := x.IsMonday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsMonday{Trm: isMondayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isTuesdayTrm, ok := x.IsTuesday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsTuesday{Trm: isTuesdayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isWednesdayTrm, ok := x.IsWednesday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsWednesday{Trm: isWednesdayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isThursdayTrm, ok := x.IsThursday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsThursday{Trm: isThursdayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isFridayTrm, ok := x.IsFriday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsFriday{Trm: isFridayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isSaturdayTrm, ok := x.IsSaturday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeIsSaturday{Trm: isSaturdayTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			invTrm, ok := x.Inv()
			if ok {
				x.NextLprn()
				cur := &TmeTmeInv{Trm: invTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lssTrm, ok := x.Lss()
			if ok {
				x.NextLprn()
				cur := &TmeTmeLss{Trm: lssTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			leqTrm, ok := x.Leq()
			if ok {
				x.NextLprn()
				cur := &TmeTmeLeq{Trm: leqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mulTrm, ok := x.Mul()
			if ok {
				x.NextLprn()
				cur := &TmeTmeMul{Trm: mulTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &TmeTmeMin{Trm: minTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &TmeTmeMax{Trm: maxTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &TmeTmeMid{Trm: midTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			neqTrm, ok := x.Neq()
			if ok {
				x.NextLprn()
				cur := &TmeTmeNeq{Trm: neqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			negTrm, ok := x.Neg()
			if ok {
				x.NextLprn()
				cur := &TmeTmeNeg{Trm: negTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			posTrm, ok := x.Pos()
			if ok {
				x.NextLprn()
				cur := &TmeTmePos{Trm: posTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			powTrm, ok := x.Pow()
			if ok {
				x.NextLprn()
				cur := &TmeTmePow{Trm: powTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			remTrm, ok := x.Rem()
			if ok {
				x.NextLprn()
				cur := &TmeTmeRem{Trm: remTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			subTrm, ok := x.Sub()
			if ok {
				x.NextLprn()
				cur := &TmeTmeSub{Trm: subTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrTrm, ok := x.Sqr()
			if ok {
				x.NextLprn()
				cur := &TmeTmeSqr{Trm: sqrTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sqrtTrm, ok := x.Sqrt()
			if ok {
				x.NextLprn()
				cur := &TmeTmeSqrt{Trm: sqrtTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toSundayTrm, ok := x.ToSunday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToSunday{Trm: toSundayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			toMondayTrm, ok := x.ToMonday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToMonday{Trm: toMondayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			toTuesdayTrm, ok := x.ToTuesday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToTuesday{Trm: toTuesdayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			toWednesdayTrm, ok := x.ToWednesday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToWednesday{Trm: toWednesdayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			toThursdayTrm, ok := x.ToThursday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToThursday{Trm: toThursdayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			toFridayTrm, ok := x.ToFriday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToFriday{Trm: toFridayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			toSaturdayTrm, ok := x.ToSaturday()
			if ok {
				x.NextLprn()
				cur := &TmeTmeToSaturday{Trm: toSaturdayTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			weekdayCntTrm, ok := x.WeekdayCnt()
			if ok {
				x.NextLprn()
				cur := &TmeTmeWeekdayCnt{Trm: weekdayCntTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("TmeTmeXpr: no expression found")
	}
	return X
}
func (x *Xprr) TmeRngXpr(scp *Scp, X TmeRngXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tme asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Tme asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Tme asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeRng)
				return x.TmeRngXpr(scp, &TmeRngAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'e':
			ensureTrm, ok := x.Ensure()
			if ok {
				x.NextLprn()
				cur := &TmeRngEnsure{Trm: ensureTrm, X: X}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			isValidTrm, ok := x.IsValid()
			if ok {
				x.NextLprn()
				cur := &TmeRngIsValid{Trm: isValidTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lenTrm, ok := x.Len()
			if ok {
				x.NextLprn()
				cur := &TmeRngLen{Trm: lenTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			minSubTrm, ok := x.MinSub()
			if ok {
				x.NextLprn()
				cur := &TmeRngMinSub{Trm: minSubTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxAddTrm, ok := x.MaxAdd()
			if ok {
				x.NextLprn()
				cur := &TmeRngMaxAdd{Trm: maxAddTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				cur := &TmeRngMrg{Trm: mrgTrm, X: X, I0: x.Xpr(scp).(TmeRngXpr)}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("TmeRngXpr: no expression found")
	}
	return X
}
func (x *Xprr) TmeRngsXpr(scp *Scp, X TmeRngsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tme asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Tme asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Tme asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeRngs)
				return x.TmeRngsXpr(scp, &TmeRngsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &TmeRngsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &TmeRngsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &TmeRngsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &TmeRngsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &TmeRngsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &TmeRngsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tme 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeRng)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &TmeRngsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &TmeRngsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &TmeRngsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &TmeRngsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &TmeRngsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(TmeRngXpr)}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &TmeRngsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &TmeRngsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &TmeRngsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &TmeRngsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []TmeRngsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngsXpr)
					if !ok {
						x.Panicf("TmeRngsXpr: Mrg: non TmeRngsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &TmeRngsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &TmeRngsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &TmeRngsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tme 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeRng)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &TmeRngsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("TmeRngsXpr: Push: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &TmeRngsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &TmeRngsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("TmeRngsXpr: Que: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &TmeRngsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &TmeRngsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &TmeRngsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngMrgTrm, ok := x.RngMrg()
			if ok {
				x.NextLprn()
				cur := &TmeRngsRngMrg{Trm: rngMrgTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeRngXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			srchIdxTrm, ok := x.SrchIdx()
			if ok {
				x.NextLprn()
				cur := &TmeRngsSrchIdx{Trm: srchIdxTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &TmeRngsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &TmeRngsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(TmeRngXpr)}
				x.NextRprn()
				return x.TmeRngsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("TmeRngsXpr: no expression found")
	}
	return X
}
func (x *Xprr) BndPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Bnd()
	if ok {
		x.Panicf("BndPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) BndBndXpr(scp *Scp, X BndBndXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bnd asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Bnd asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Bnd asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BndBnd)
				return x.BndBndXpr(scp, &BndBndAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &BndBndCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			isValidTrm, ok := x.IsValid()
			if ok {
				x.NextLprn()
				cur := &BndBndIsValid{Trm: isValidTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lenTrm, ok := x.Len()
			if ok {
				x.NextLprn()
				cur := &BndBndLen{Trm: lenTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &BndBndLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("BndBndXpr: no expression found")
	}
	return X
}
func (x *Xprr) StrsPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Strs()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &StrsMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.StrsStrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &StrsMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.StrsStrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []StrStrXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(StrStrXpr)
						if !ok {
							x.Panicf("StrsPkgXpr: New: non StrStrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &StrsNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.StrsStrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("StrsPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) StrsStrsXpr(scp *Scp, X StrsStrsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Strs asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Strs asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Strs asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.StrsStrs)
				return x.StrsStrsXpr(scp, &StrsStrsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &StrsStrsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &StrsStrsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &StrsStrsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &StrsStrsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &StrsStrsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &StrsStrsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Strs 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.StrStr)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &StrsStrsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &StrsStrsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &StrsStrsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &StrsStrsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hasTrm, ok := x.Has()
			if ok {
				x.NextLprn()
				cur := &StrsStrsHas{Trm: hasTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &StrsStrsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &StrsStrsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &StrsStrsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &StrsStrsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &StrsStrsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []StrsStrsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(StrsStrsXpr)
					if !ok {
						x.Panicf("StrsStrsXpr: Mrg: non StrsStrsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &StrsStrsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &StrsStrsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &StrsStrsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Strs 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.StrStr)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &StrsStrsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []StrStrXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(StrStrXpr)
					if !ok {
						x.Panicf("StrsStrsXpr: Push: non StrStrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &StrsStrsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &StrsStrsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []StrStrXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(StrStrXpr)
					if !ok {
						x.Panicf("StrsStrsXpr: Que: non StrStrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &StrsStrsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &StrsStrsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &StrsStrsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			srchIdxEqlTrm, ok := x.SrchIdxEql()
			if ok {
				x.NextLprn()
				cur := &StrsStrsSrchIdxEql{Trm: srchIdxEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srchIdxTrm, ok := x.SrchIdx()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(StrStrXpr)
				var i1 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("StrsStrsXpr: SrchIdx: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &StrsStrsSrchIdx{Trm: srchIdxTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtAscTrm, ok := x.SrtAsc()
			if ok {
				x.NextLprn()
				cur := &StrsStrsSrtAsc{Trm: srtAscTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtDscTrm, ok := x.SrtDsc()
			if ok {
				x.NextLprn()
				cur := &StrsStrsSrtDsc{Trm: srtDscTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &StrsStrsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &StrsStrsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("StrsStrsXpr: no expression found")
	}
	return X
}
func (x *Xprr) BolsPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Bols()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &BolsMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.BolsBolsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &BolsMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.BolsBolsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []BolBolXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(BolBolXpr)
						if !ok {
							x.Panicf("BolsPkgXpr: New: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &BolsNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.BolsBolsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("BolsPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) BolsBolsXpr(scp *Scp, X BolsBolsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bols asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Bols asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Bols asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BolsBols)
				return x.BolsBolsXpr(scp, &BolsBolsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &BolsBolsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &BolsBolsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &BolsBolsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &BolsBolsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &BolsBolsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &BolsBolsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bols 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BolBol)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &BolsBolsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &BolsBolsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &BolsBolsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &BolsBolsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &BolsBolsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &BolsBolsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &BolsBolsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &BolsBolsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &BolsBolsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []BolsBolsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolsBolsXpr)
					if !ok {
						x.Panicf("BolsBolsXpr: Mrg: non BolsBolsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &BolsBolsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &BolsBolsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &BolsBolsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bols 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BolBol)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &BolsBolsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("BolsBolsXpr: Push: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &BolsBolsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &BolsBolsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("BolsBolsXpr: Que: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &BolsBolsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &BolsBolsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &BolsBolsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &BolsBolsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &BolsBolsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("BolsBolsXpr: no expression found")
	}
	return X
}
func (x *Xprr) FltsPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Flts()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'a':
				addsLssTrm, ok := x.AddsLss()
				if ok {
					x.NextLprn()
					cur := &FltsAddsLss{Trm: addsLssTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				addsLeqTrm, ok := x.AddsLeq()
				if ok {
					x.NextLprn()
					cur := &FltsAddsLeq{Trm: addsLeqTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'd':
				divsGtrTrm, ok := x.DivsGtr()
				if ok {
					x.NextLprn()
					cur := &FltsDivsGtr{Trm: divsGtrTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				divsGeqTrm, ok := x.DivsGeq()
				if ok {
					x.NextLprn()
					cur := &FltsDivsGeq{Trm: divsGeqTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'f':
				fibsLeqTrm, ok := x.FibsLeq()
				if ok {
					x.NextLprn()
					cur := &FltsFibsLeq{Trm: fibsLeqTrm, I0: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &FltsMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &FltsMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				mulsLssTrm, ok := x.MulsLss()
				if ok {
					x.NextLprn()
					cur := &FltsMulsLss{Trm: mulsLssTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				mulsLeqTrm, ok := x.MulsLeq()
				if ok {
					x.NextLprn()
					cur := &FltsMulsLeq{Trm: mulsLeqTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []FltFltXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(FltFltXpr)
						if !ok {
							x.Panicf("FltsPkgXpr: New: non FltFltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &FltsNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 's':
				subsGtrTrm, ok := x.SubsGtr()
				if ok {
					x.NextLprn()
					cur := &FltsSubsGtr{Trm: subsGtrTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				subsGeqTrm, ok := x.SubsGeq()
				if ok {
					x.NextLprn()
					cur := &FltsSubsGeq{Trm: subsGeqTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.FltsFltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("FltsPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) FltsFltsXpr(scp *Scp, X FltsFltsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Flts asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Flts asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Flts asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.FltsFlts)
				return x.FltsFltsXpr(scp, &FltsFltsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &FltsFltsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			almaTrm, ok := x.Alma()
			if ok {
				x.NextLprn()
				cur := &FltsFltsAlma{Trm: almaTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &FltsFltsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntEqlTrm, ok := x.CntEql()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCntEql{Trm: cntEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntNeqTrm, ok := x.CntNeq()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCntNeq{Trm: cntNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntLssTrm, ok := x.CntLss()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCntLss{Trm: cntLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntGtrTrm, ok := x.CntGtr()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCntGtr{Trm: cntGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntLeqTrm, ok := x.CntLeq()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCntLeq{Trm: cntLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntGeqTrm, ok := x.CntGeq()
			if ok {
				x.NextLprn()
				cur := &FltsFltsCntGeq{Trm: cntGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cntrDistTrm, ok := x.CntrDist()
			if ok {
				x.NextLprn()
				var i0 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("FltsFltsXpr: CntrDist: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &FltsFltsCntrDist{Trm: cntrDistTrm, X: X, I0: i0}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &FltsFltsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &FltsFltsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Flts 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.FltFlt)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &FltsFltsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &FltsFltsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &FltsFltsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &FltsFltsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gmaTrm, ok := x.Gma()
			if ok {
				x.NextLprn()
				cur := &FltsFltsGma{Trm: gmaTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hasTrm, ok := x.Has()
			if ok {
				x.NextLprn()
				cur := &FltsFltsHas{Trm: hasTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &FltsFltsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &FltsFltsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrAddTrm, ok := x.InrAdd()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrAdd{Trm: inrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSubTrm, ok := x.InrSub()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrSub{Trm: inrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMulTrm, ok := x.InrMul()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrMul{Trm: inrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrDivTrm, ok := x.InrDiv()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrDiv{Trm: inrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrRemTrm, ok := x.InrRem()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrRem{Trm: inrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrPowTrm, ok := x.InrPow()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrPow{Trm: inrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMinTrm, ok := x.InrMin()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrMin{Trm: inrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMaxTrm, ok := x.InrMax()
			if ok {
				x.NextLprn()
				cur := &FltsFltsInrMax{Trm: inrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &FltsFltsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &FltsFltsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []FltsFltsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(FltsFltsXpr)
					if !ok {
						x.Panicf("FltsFltsXpr: Mrg: non FltsFltsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &FltsFltsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &FltsFltsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &FltsFltsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &FltsFltsMin{Trm: minTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &FltsFltsMax{Trm: maxTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &FltsFltsMid{Trm: midTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdnTrm, ok := x.Mdn()
			if ok {
				x.NextLprn()
				cur := &FltsFltsMdn{Trm: mdnTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Flts 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.FltFlt)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &FltsFltsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []FltFltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(FltFltXpr)
					if !ok {
						x.Panicf("FltsFltsXpr: Push: non FltFltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &FltsFltsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &FltsFltsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			prdTrm, ok := x.Prd()
			if ok {
				x.NextLprn()
				cur := &FltsFltsPrd{Trm: prdTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proLstTrm, ok := x.ProLst()
			if ok {
				x.NextLprn()
				cur := &FltsFltsProLst{Trm: proLstTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proSmaTrm, ok := x.ProSma()
			if ok {
				x.NextLprn()
				cur := &FltsFltsProSma{Trm: proSmaTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proTrm, ok := x.Pro()
			if ok {
				x.NextLprn()
				cur := &FltsFltsPro{Trm: proTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proAlmaTrm, ok := x.ProAlma()
			if ok {
				x.NextLprn()
				cur := &FltsFltsProAlma{Trm: proAlmaTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []FltFltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(FltFltXpr)
					if !ok {
						x.Panicf("FltsFltsXpr: Que: non FltFltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &FltsFltsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &FltsFltsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &FltsFltsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngFulTrm, ok := x.RngFul()
			if ok {
				x.NextLprn()
				cur := &FltsFltsRngFul{Trm: rngFulTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngLstTrm, ok := x.RngLst()
			if ok {
				x.NextLprn()
				cur := &FltsFltsRngLst{Trm: rngLstTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rsiTrm, ok := x.Rsi()
			if ok {
				x.NextLprn()
				cur := &FltsFltsRsi{Trm: rsiTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			srchIdxEqlTrm, ok := x.SrchIdxEql()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSrchIdxEql{Trm: srchIdxEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srchIdxTrm, ok := x.SrchIdx()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(FltFltXpr)
				var i1 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("FltsFltsXpr: SrchIdx: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &FltsFltsSrchIdx{Trm: srchIdxTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtAscTrm, ok := x.SrtAsc()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSrtAsc{Trm: srtAscTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtDscTrm, ok := x.SrtDsc()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSrtDsc{Trm: srtDscTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclAddTrm, ok := x.SclAdd()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclAdd{Trm: sclAddTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclSubTrm, ok := x.SclSub()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclSub{Trm: sclSubTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMulTrm, ok := x.SclMul()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclMul{Trm: sclMulTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclDivTrm, ok := x.SclDiv()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclDiv{Trm: sclDivTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclRemTrm, ok := x.SclRem()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclRem{Trm: sclRemTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclPowTrm, ok := x.SclPow()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclPow{Trm: sclPowTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMinTrm, ok := x.SclMin()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclMin{Trm: sclMinTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMaxTrm, ok := x.SclMax()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSclMax{Trm: sclMaxTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selEqlTrm, ok := x.SelEql()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSelEql{Trm: selEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selNeqTrm, ok := x.SelNeq()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSelNeq{Trm: selNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLssTrm, ok := x.SelLss()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSelLss{Trm: selLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGtrTrm, ok := x.SelGtr()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSelGtr{Trm: selGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLeqTrm, ok := x.SelLeq()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSelLeq{Trm: selLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGeqTrm, ok := x.SelGeq()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSelGeq{Trm: selGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sumTrm, ok := x.Sum()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSum{Trm: sumTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			smaTrm, ok := x.Sma()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSma{Trm: smaTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stdTrm, ok := x.Std()
			if ok {
				x.NextLprn()
				cur := &FltsFltsStd{Trm: stdTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			subSumPosTrm, ok := x.SubSumPos()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSubSumPos{Trm: subSumPosTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			subSumNegTrm, ok := x.SubSumNeg()
			if ok {
				x.NextLprn()
				cur := &FltsFltsSubSumNeg{Trm: subSumNegTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &FltsFltsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &FltsFltsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaPosTrm, ok := x.UnaPos()
			if ok {
				x.NextLprn()
				cur := &FltsFltsUnaPos{Trm: unaPosTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaNegTrm, ok := x.UnaNeg()
			if ok {
				x.NextLprn()
				cur := &FltsFltsUnaNeg{Trm: unaNegTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaInvTrm, ok := x.UnaInv()
			if ok {
				x.NextLprn()
				cur := &FltsFltsUnaInv{Trm: unaInvTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaSqrTrm, ok := x.UnaSqr()
			if ok {
				x.NextLprn()
				cur := &FltsFltsUnaSqr{Trm: unaSqrTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaSqrtTrm, ok := x.UnaSqrt()
			if ok {
				x.NextLprn()
				cur := &FltsFltsUnaSqrt{Trm: unaSqrtTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrncTrm, ok := x.Vrnc()
			if ok {
				x.NextLprn()
				cur := &FltsFltsVrnc{Trm: vrncTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			wmaTrm, ok := x.Wma()
			if ok {
				x.NextLprn()
				cur := &FltsFltsWma{Trm: wmaTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			wrsiTrm, ok := x.Wrsi()
			if ok {
				x.NextLprn()
				cur := &FltsFltsWrsi{Trm: wrsiTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'z':
			zscrTrm, ok := x.Zscr()
			if ok {
				x.NextLprn()
				cur := &FltsFltsZscr{Trm: zscrTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			zscrInplaceTrm, ok := x.ZscrInplace()
			if ok {
				x.NextLprn()
				cur := &FltsFltsZscrInplace{Trm: zscrInplaceTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("FltsFltsXpr: no expression found")
	}
	return X
}
func (x *Xprr) UntsPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Unts()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'a':
				addsLssTrm, ok := x.AddsLss()
				if ok {
					x.NextLprn()
					cur := &UntsAddsLss{Trm: addsLssTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				addsLeqTrm, ok := x.AddsLeq()
				if ok {
					x.NextLprn()
					cur := &UntsAddsLeq{Trm: addsLeqTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'd':
				divsGtrTrm, ok := x.DivsGtr()
				if ok {
					x.NextLprn()
					cur := &UntsDivsGtr{Trm: divsGtrTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				divsGeqTrm, ok := x.DivsGeq()
				if ok {
					x.NextLprn()
					cur := &UntsDivsGeq{Trm: divsGeqTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'f':
				fibsLeqTrm, ok := x.FibsLeq()
				if ok {
					x.NextLprn()
					cur := &UntsFibsLeq{Trm: fibsLeqTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &UntsMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &UntsMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				mulsLssTrm, ok := x.MulsLss()
				if ok {
					x.NextLprn()
					cur := &UntsMulsLss{Trm: mulsLssTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				mulsLeqTrm, ok := x.MulsLeq()
				if ok {
					x.NextLprn()
					cur := &UntsMulsLeq{Trm: mulsLeqTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []UntUntXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(UntUntXpr)
						if !ok {
							x.Panicf("UntsPkgXpr: New: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &UntsNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 's':
				subsGtrTrm, ok := x.SubsGtr()
				if ok {
					x.NextLprn()
					cur := &UntsSubsGtr{Trm: subsGtrTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				subsGeqTrm, ok := x.SubsGeq()
				if ok {
					x.NextLprn()
					cur := &UntsSubsGeq{Trm: subsGeqTrm, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr), I2: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.UntsUntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("UntsPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) UntsUntsXpr(scp *Scp, X UntsUntsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Unts asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Unts asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Unts asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.UntsUnts)
				return x.UntsUntsXpr(scp, &UntsUntsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &UntsUntsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &UntsUntsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &UntsUntsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &UntsUntsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &UntsUntsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &UntsUntsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Unts 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.UntUnt)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &UntsUntsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &UntsUntsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &UntsUntsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &UntsUntsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gmaTrm, ok := x.Gma()
			if ok {
				x.NextLprn()
				cur := &UntsUntsGma{Trm: gmaTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hasTrm, ok := x.Has()
			if ok {
				x.NextLprn()
				cur := &UntsUntsHas{Trm: hasTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &UntsUntsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &UntsUntsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrAddTrm, ok := x.InrAdd()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrAdd{Trm: inrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSubTrm, ok := x.InrSub()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrSub{Trm: inrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMulTrm, ok := x.InrMul()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrMul{Trm: inrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrDivTrm, ok := x.InrDiv()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrDiv{Trm: inrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrRemTrm, ok := x.InrRem()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrRem{Trm: inrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrPowTrm, ok := x.InrPow()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrPow{Trm: inrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMinTrm, ok := x.InrMin()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrMin{Trm: inrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMaxTrm, ok := x.InrMax()
			if ok {
				x.NextLprn()
				cur := &UntsUntsInrMax{Trm: inrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &UntsUntsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &UntsUntsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []UntsUntsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(UntsUntsXpr)
					if !ok {
						x.Panicf("UntsUntsXpr: Mrg: non UntsUntsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &UntsUntsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &UntsUntsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &UntsUntsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &UntsUntsMin{Trm: minTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &UntsUntsMax{Trm: maxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &UntsUntsMid{Trm: midTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdnTrm, ok := x.Mdn()
			if ok {
				x.NextLprn()
				cur := &UntsUntsMdn{Trm: mdnTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Unts 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.UntUnt)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &UntsUntsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []UntUntXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(UntUntXpr)
					if !ok {
						x.Panicf("UntsUntsXpr: Push: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &UntsUntsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &UntsUntsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			prdTrm, ok := x.Prd()
			if ok {
				x.NextLprn()
				cur := &UntsUntsPrd{Trm: prdTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proLstTrm, ok := x.ProLst()
			if ok {
				x.NextLprn()
				cur := &UntsUntsProLst{Trm: proLstTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proSmaTrm, ok := x.ProSma()
			if ok {
				x.NextLprn()
				cur := &UntsUntsProSma{Trm: proSmaTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []UntUntXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(UntUntXpr)
					if !ok {
						x.Panicf("UntsUntsXpr: Que: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &UntsUntsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &UntsUntsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &UntsUntsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngFulTrm, ok := x.RngFul()
			if ok {
				x.NextLprn()
				cur := &UntsUntsRngFul{Trm: rngFulTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngLstTrm, ok := x.RngLst()
			if ok {
				x.NextLprn()
				cur := &UntsUntsRngLst{Trm: rngLstTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			srchIdxEqlTrm, ok := x.SrchIdxEql()
			if ok {
				x.NextLprn()
				cur := &UntsUntsSrchIdxEql{Trm: srchIdxEqlTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srchIdxTrm, ok := x.SrchIdx()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(UntUntXpr)
				var i1 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("UntsUntsXpr: SrchIdx: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &UntsUntsSrchIdx{Trm: srchIdxTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtAscTrm, ok := x.SrtAsc()
			if ok {
				x.NextLprn()
				cur := &UntsUntsSrtAsc{Trm: srtAscTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtDscTrm, ok := x.SrtDsc()
			if ok {
				x.NextLprn()
				cur := &UntsUntsSrtDsc{Trm: srtDscTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sumTrm, ok := x.Sum()
			if ok {
				x.NextLprn()
				cur := &UntsUntsSum{Trm: sumTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			smaTrm, ok := x.Sma()
			if ok {
				x.NextLprn()
				cur := &UntsUntsSma{Trm: smaTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stdTrm, ok := x.Std()
			if ok {
				x.NextLprn()
				cur := &UntsUntsStd{Trm: stdTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &UntsUntsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &UntsUntsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrncTrm, ok := x.Vrnc()
			if ok {
				x.NextLprn()
				cur := &UntsUntsVrnc{Trm: vrncTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			wmaTrm, ok := x.Wma()
			if ok {
				x.NextLprn()
				cur := &UntsUntsWma{Trm: wmaTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'z':
			zscrTrm, ok := x.Zscr()
			if ok {
				x.NextLprn()
				cur := &UntsUntsZscr{Trm: zscrTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			zscrInplaceTrm, ok := x.ZscrInplace()
			if ok {
				x.NextLprn()
				cur := &UntsUntsZscrInplace{Trm: zscrInplaceTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("UntsUntsXpr: no expression found")
	}
	return X
}
func (x *Xprr) IntsPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Ints()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &IntsMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.IntsIntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &IntsMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.IntsIntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []IntIntXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(IntIntXpr)
						if !ok {
							x.Panicf("IntsPkgXpr: New: non IntIntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &IntsNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.IntsIntsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("IntsPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) IntsIntsXpr(scp *Scp, X IntsIntsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ints asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ints asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ints asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.IntsInts)
				return x.IntsIntsXpr(scp, &IntsIntsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &IntsIntsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &IntsIntsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &IntsIntsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &IntsIntsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &IntsIntsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &IntsIntsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ints 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.IntInt)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &IntsIntsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &IntsIntsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &IntsIntsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &IntsIntsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hasTrm, ok := x.Has()
			if ok {
				x.NextLprn()
				cur := &IntsIntsHas{Trm: hasTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &IntsIntsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &IntsIntsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &IntsIntsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &IntsIntsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &IntsIntsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []IntsIntsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(IntsIntsXpr)
					if !ok {
						x.Panicf("IntsIntsXpr: Mrg: non IntsIntsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &IntsIntsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &IntsIntsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &IntsIntsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ints 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.IntInt)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &IntsIntsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []IntIntXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(IntIntXpr)
					if !ok {
						x.Panicf("IntsIntsXpr: Push: non IntIntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &IntsIntsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &IntsIntsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.IntIntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []IntIntXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(IntIntXpr)
					if !ok {
						x.Panicf("IntsIntsXpr: Que: non IntIntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &IntsIntsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &IntsIntsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &IntsIntsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			srchIdxEqlTrm, ok := x.SrchIdxEql()
			if ok {
				x.NextLprn()
				cur := &IntsIntsSrchIdxEql{Trm: srchIdxEqlTrm, X: X, I0: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srchIdxTrm, ok := x.SrchIdx()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(IntIntXpr)
				var i1 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("IntsIntsXpr: SrchIdx: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &IntsIntsSrchIdx{Trm: srchIdxTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtAscTrm, ok := x.SrtAsc()
			if ok {
				x.NextLprn()
				cur := &IntsIntsSrtAsc{Trm: srtAscTrm, X: X}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtDscTrm, ok := x.SrtDsc()
			if ok {
				x.NextLprn()
				cur := &IntsIntsSrtDsc{Trm: srtDscTrm, X: X}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &IntsIntsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &IntsIntsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(IntIntXpr)}
				x.NextRprn()
				return x.IntsIntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("IntsIntsXpr: no expression found")
	}
	return X
}
func (x *Xprr) TmesPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Tmes()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'a':
				addsLssTrm, ok := x.AddsLss()
				if ok {
					x.NextLprn()
					cur := &TmesAddsLss{Trm: addsLssTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				addsLeqTrm, ok := x.AddsLeq()
				if ok {
					x.NextLprn()
					cur := &TmesAddsLeq{Trm: addsLeqTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'd':
				divsGtrTrm, ok := x.DivsGtr()
				if ok {
					x.NextLprn()
					cur := &TmesDivsGtr{Trm: divsGtrTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				divsGeqTrm, ok := x.DivsGeq()
				if ok {
					x.NextLprn()
					cur := &TmesDivsGeq{Trm: divsGeqTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'f':
				fibsLeqTrm, ok := x.FibsLeq()
				if ok {
					x.NextLprn()
					cur := &TmesFibsLeq{Trm: fibsLeqTrm, I0: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &TmesMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &TmesMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				mulsLssTrm, ok := x.MulsLss()
				if ok {
					x.NextLprn()
					cur := &TmesMulsLss{Trm: mulsLssTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				mulsLeqTrm, ok := x.MulsLeq()
				if ok {
					x.NextLprn()
					cur := &TmesMulsLeq{Trm: mulsLeqTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []TmeTmeXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(TmeTmeXpr)
						if !ok {
							x.Panicf("TmesPkgXpr: New: non TmeTmeXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &TmesNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 's':
				subsGtrTrm, ok := x.SubsGtr()
				if ok {
					x.NextLprn()
					cur := &TmesSubsGtr{Trm: subsGtrTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				subsGeqTrm, ok := x.SubsGeq()
				if ok {
					x.NextLprn()
					cur := &TmesSubsGeq{Trm: subsGeqTrm, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(TmeTmeXpr), I2: x.Xpr(scp).(TmeTmeXpr)}
					x.NextRprn()
					return x.TmesTmesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("TmesPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) TmesTmesXpr(scp *Scp, X TmesTmesXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tmes asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Tmes asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Tmes asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmesTmes)
				return x.TmesTmesXpr(scp, &TmesTmesAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &TmesTmesAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'b':
			bndTrm, ok := x.Bnd()
			if ok {
				x.NextLprn()
				cur := &TmesTmesBnd{Trm: bndTrm, X: X, I0: x.Xpr(scp).(TmeRngXpr)}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &TmesTmesCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &TmesTmesCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &TmesTmesClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &TmesTmesDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &TmesTmesDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tmes 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeTme)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &TmesTmesEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &TmesTmesFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &TmesTmesFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &TmesTmesFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gmaTrm, ok := x.Gma()
			if ok {
				x.NextLprn()
				cur := &TmesTmesGma{Trm: gmaTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hasTrm, ok := x.Has()
			if ok {
				x.NextLprn()
				cur := &TmesTmesHas{Trm: hasTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &TmesTmesIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &TmesTmesIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrAddTrm, ok := x.InrAdd()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrAdd{Trm: inrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSubTrm, ok := x.InrSub()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrSub{Trm: inrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMulTrm, ok := x.InrMul()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrMul{Trm: inrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrDivTrm, ok := x.InrDiv()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrDiv{Trm: inrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrRemTrm, ok := x.InrRem()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrRem{Trm: inrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrPowTrm, ok := x.InrPow()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrPow{Trm: inrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMinTrm, ok := x.InrMin()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrMin{Trm: inrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMaxTrm, ok := x.InrMax()
			if ok {
				x.NextLprn()
				cur := &TmesTmesInrMax{Trm: inrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &TmesTmesLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &TmesTmesLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []TmesTmesXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmesTmesXpr)
					if !ok {
						x.Panicf("TmesTmesXpr: Mrg: non TmesTmesXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &TmesTmesMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &TmesTmesMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &TmesTmesMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &TmesTmesMin{Trm: minTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &TmesTmesMax{Trm: maxTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &TmesTmesMid{Trm: midTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdnTrm, ok := x.Mdn()
			if ok {
				x.NextLprn()
				cur := &TmesTmesMdn{Trm: mdnTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Tmes 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.TmeTme)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &TmesTmesPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []TmeTmeXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeTmeXpr)
					if !ok {
						x.Panicf("TmesTmesXpr: Push: non TmeTmeXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &TmesTmesPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &TmesTmesPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			prdTrm, ok := x.Prd()
			if ok {
				x.NextLprn()
				cur := &TmesTmesPrd{Trm: prdTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proLstTrm, ok := x.ProLst()
			if ok {
				x.NextLprn()
				cur := &TmesTmesProLst{Trm: proLstTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proSmaTrm, ok := x.ProSma()
			if ok {
				x.NextLprn()
				cur := &TmesTmesProSma{Trm: proSmaTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []TmeTmeXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeTmeXpr)
					if !ok {
						x.Panicf("TmesTmesXpr: Que: non TmeTmeXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &TmesTmesQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &TmesTmesRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &TmesTmesRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngFulTrm, ok := x.RngFul()
			if ok {
				x.NextLprn()
				cur := &TmesTmesRngFul{Trm: rngFulTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngLstTrm, ok := x.RngLst()
			if ok {
				x.NextLprn()
				cur := &TmesTmesRngLst{Trm: rngLstTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			srchIdxEqlTrm, ok := x.SrchIdxEql()
			if ok {
				x.NextLprn()
				cur := &TmesTmesSrchIdxEql{Trm: srchIdxEqlTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srchIdxTrm, ok := x.SrchIdx()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(TmeTmeXpr)
				var i1 []BolBolXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BolBolXpr)
					if !ok {
						x.Panicf("TmesTmesXpr: SrchIdx: non BolBolXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &TmesTmesSrchIdx{Trm: srchIdxTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtAscTrm, ok := x.SrtAsc()
			if ok {
				x.NextLprn()
				cur := &TmesTmesSrtAsc{Trm: srtAscTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			srtDscTrm, ok := x.SrtDsc()
			if ok {
				x.NextLprn()
				cur := &TmesTmesSrtDsc{Trm: srtDscTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sumTrm, ok := x.Sum()
			if ok {
				x.NextLprn()
				cur := &TmesTmesSum{Trm: sumTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			smaTrm, ok := x.Sma()
			if ok {
				x.NextLprn()
				cur := &TmesTmesSma{Trm: smaTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stdTrm, ok := x.Std()
			if ok {
				x.NextLprn()
				cur := &TmesTmesStd{Trm: stdTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &TmesTmesTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &TmesTmesUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrncTrm, ok := x.Vrnc()
			if ok {
				x.NextLprn()
				cur := &TmesTmesVrnc{Trm: vrncTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			weekdayCntTrm, ok := x.WeekdayCnt()
			if ok {
				x.NextLprn()
				cur := &TmesTmesWeekdayCnt{Trm: weekdayCntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			wmaTrm, ok := x.Wma()
			if ok {
				x.NextLprn()
				cur := &TmesTmesWma{Trm: wmaTrm, X: X}
				x.NextRprn()
				return x.TmeTmeXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'z':
			zscrTrm, ok := x.Zscr()
			if ok {
				x.NextLprn()
				cur := &TmesTmesZscr{Trm: zscrTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			zscrInplaceTrm, ok := x.ZscrInplace()
			if ok {
				x.NextLprn()
				cur := &TmesTmesZscrInplace{Trm: zscrInplaceTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("TmesTmesXpr: no expression found")
	}
	return X
}
func (x *Xprr) BndsPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Bnds()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makeTrm, ok := x.Make()
				if ok {
					x.NextLprn()
					cur := &BndsMake{Trm: makeTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.BndsBndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrm, ok := x.MakeEmp()
				if ok {
					x.NextLprn()
					cur := &BndsMakeEmp{Trm: makeEmpTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.BndsBndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					var i0 []BndBndXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(BndBndXpr)
						if !ok {
							x.Panicf("BndsPkgXpr: New: non BndBndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &BndsNew{Trm: newTrm, I0: i0}
					x.NextRprn()
					return x.BndsBndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("BndsPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) BndsBndsXpr(scp *Scp, X BndsBndsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bnds asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Bnds asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Bnds asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BndsBnds)
				return x.BndsBndsXpr(scp, &BndsBndsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &BndsBndsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &BndsBndsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &BndsBndsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &BndsBndsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &BndsBndsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &BndsBndsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bnds 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BndBnd)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &BndsBndsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &BndsBndsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &BndsBndsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &BndsBndsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &BndsBndsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &BndsBndsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &BndsBndsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &BndsBndsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &BndsBndsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []BndsBndsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BndsBndsXpr)
					if !ok {
						x.Panicf("BndsBndsXpr: Mrg: non BndsBndsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &BndsBndsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &BndsBndsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &BndsBndsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Bnds 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.BndBnd)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &BndsBndsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []BndBndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BndBndXpr)
					if !ok {
						x.Panicf("BndsBndsXpr: Push: non BndBndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &BndsBndsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &BndsBndsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.BndBndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []BndBndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(BndBndXpr)
					if !ok {
						x.Panicf("BndsBndsXpr: Que: non BndBndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &BndsBndsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &BndsBndsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &BndsBndsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &BndsBndsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &BndsBndsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.BndsBndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("BndsBndsXpr: no expression found")
	}
	return X
}
func (x *Xprr) AnaPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Ana()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makeTrdsTrm, ok := x.MakeTrds()
				if ok {
					x.NextLprn()
					cur := &AnaMakeTrds{Trm: makeTrdsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.AnaTrdsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpTrdsTrm, ok := x.MakeEmpTrds()
				if ok {
					x.NextLprn()
					cur := &AnaMakeEmpTrds{Trm: makeEmpTrdsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.AnaTrdsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makePrfmsTrm, ok := x.MakePrfms()
				if ok {
					x.NextLprn()
					cur := &AnaMakePrfms{Trm: makePrfmsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.AnaPrfmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpPrfmsTrm, ok := x.MakeEmpPrfms()
				if ok {
					x.NextLprn()
					cur := &AnaMakeEmpPrfms{Trm: makeEmpPrfmsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.AnaPrfmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrdsTrm, ok := x.NewTrds()
				if ok {
					x.NextLprn()
					var i0 []AnaTrdXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(AnaTrdXpr)
						if !ok {
							x.Panicf("AnaPkgXpr: NewTrds: non AnaTrdXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &AnaNewTrds{Trm: newTrdsTrm, I0: i0}
					x.NextRprn()
					return x.AnaTrdsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newPrfmsTrm, ok := x.NewPrfms()
				if ok {
					x.NextLprn()
					var i0 []AnaPrfmXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(AnaPrfmXpr)
						if !ok {
							x.Panicf("AnaPkgXpr: NewPrfms: non AnaPrfmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &AnaNewPrfms{Trm: newPrfmsTrm, I0: i0}
					x.NextRprn()
					return x.AnaPrfmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("AnaPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) AnaTrdXpr(scp *Scp, X AnaTrdXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ana asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ana asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaTrd)
				return x.AnaTrdXpr(scp, &AnaTrdAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'c':
			clsMidTrm, ok := x.ClsMid()
			if ok {
				x.NextLprn()
				cur := &AnaTrdClsMid{Trm: clsMidTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			opnMidTrm, ok := x.OpnMid()
			if ok {
				x.NextLprn()
				cur := &AnaTrdOpnMid{Trm: opnMidTrm, X: X}
				x.NextRprn()
				return x.FltFltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("AnaTrdXpr: no expression found")
	}
	return X
}
func (x *Xprr) AnaTrdsXpr(scp *Scp, X AnaTrdsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ana asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ana asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaTrds)
				return x.AnaTrdsXpr(scp, &AnaTrdsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsTmesTrm, ok := x.ClsTmes()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsTmes{Trm: clsTmesTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsBidsTrm, ok := x.ClsBids()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsBids{Trm: clsBidsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsAsksTrm, ok := x.ClsAsks()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsAsks{Trm: clsAsksTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsSpdsTrm, ok := x.ClsSpds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsSpds{Trm: clsSpdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsRsnsTrm, ok := x.ClsRsns()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsRsns{Trm: clsRsnsTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cstComUsdsTrm, ok := x.CstComUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsCstComUsds{Trm: cstComUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cstClsSpdUsdsTrm, ok := x.CstClsSpdUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsCstClsSpdUsds{Trm: cstClsSpdUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cstOpnSpdUsdsTrm, ok := x.CstOpnSpdUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsCstOpnSpdUsds{Trm: cstOpnSpdUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsBalUsdsTrm, ok := x.ClsBalUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsBalUsds{Trm: clsBalUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsBalUsdActsTrm, ok := x.ClsBalUsdActs()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsBalUsdActs{Trm: clsBalUsdActsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsReqsTrm, ok := x.ClsReqs()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsReqs{Trm: clsReqsTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clsRessTrm, ok := x.ClsRess()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsClsRess{Trm: clsRessTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
			dursTrm, ok := x.Durs()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsDurs{Trm: dursTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaTrd)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &AnaTrdsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(AnaTrdXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			isLongsTrm, ok := x.IsLongs()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsIsLongs{Trm: isLongsTrm, X: X}
				x.NextRprn()
				return x.BolsBolsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			instrsTrm, ok := x.Instrs()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsInstrs{Trm: instrsTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []AnaTrdsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(AnaTrdsXpr)
					if !ok {
						x.Panicf("AnaTrdsXpr: Mrg: non AnaTrdsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &AnaTrdsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mrgnRtiosTrm, ok := x.MrgnRtios()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsMrgnRtios{Trm: mrgnRtiosTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			opnTmesTrm, ok := x.OpnTmes()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnTmes{Trm: opnTmesTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			opnBidsTrm, ok := x.OpnBids()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnBids{Trm: opnBidsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			opnAsksTrm, ok := x.OpnAsks()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnAsks{Trm: opnAsksTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			opnSpdsTrm, ok := x.OpnSpds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnSpds{Trm: opnSpdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			opnBalUsdsTrm, ok := x.OpnBalUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnBalUsds{Trm: opnBalUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			opnReqsTrm, ok := x.OpnReqs()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnReqs{Trm: opnReqsTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			opnRessTrm, ok := x.OpnRess()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsOpnRess{Trm: opnRessTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaTrd)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &AnaTrdsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []AnaTrdXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(AnaTrdXpr)
					if !ok {
						x.Panicf("AnaTrdsXpr: Push: non AnaTrdXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &AnaTrdsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.AnaTrdXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipsTrm, ok := x.Pips()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsPips{Trm: pipsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pnlPctsTrm, ok := x.PnlPcts()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsPnlPcts{Trm: pnlPctsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pnlPctPredictsTrm, ok := x.PnlPctPredicts()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsPnlPctPredicts{Trm: pnlPctPredictsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pnlUsdsTrm, ok := x.PnlUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsPnlUsds{Trm: pnlUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pnlGrsUsdsTrm, ok := x.PnlGrsUsds()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsPnlGrsUsds{Trm: pnlGrsUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []AnaTrdXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(AnaTrdXpr)
					if !ok {
						x.Panicf("AnaTrdsXpr: Que: non AnaTrdXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &AnaTrdsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			selClsResEqlTrm, ok := x.SelClsResEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsResEql{Trm: selClsResEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsResNeqTrm, ok := x.SelClsResNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsResNeq{Trm: selClsResNeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsResLssTrm, ok := x.SelClsResLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsResLss{Trm: selClsResLssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsResGtrTrm, ok := x.SelClsResGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsResGtr{Trm: selClsResGtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsResLeqTrm, ok := x.SelClsResLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsResLeq{Trm: selClsResLeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsResGeqTrm, ok := x.SelClsResGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsResGeq{Trm: selClsResGeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsReqEqlTrm, ok := x.SelClsReqEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsReqEql{Trm: selClsReqEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsReqNeqTrm, ok := x.SelClsReqNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsReqNeq{Trm: selClsReqNeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsReqLssTrm, ok := x.SelClsReqLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsReqLss{Trm: selClsReqLssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsReqGtrTrm, ok := x.SelClsReqGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsReqGtr{Trm: selClsReqGtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsReqLeqTrm, ok := x.SelClsReqLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsReqLeq{Trm: selClsReqLeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsReqGeqTrm, ok := x.SelClsReqGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsReqGeq{Trm: selClsReqGeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnResEqlTrm, ok := x.SelOpnResEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnResEql{Trm: selOpnResEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnResNeqTrm, ok := x.SelOpnResNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnResNeq{Trm: selOpnResNeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnResLssTrm, ok := x.SelOpnResLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnResLss{Trm: selOpnResLssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnResGtrTrm, ok := x.SelOpnResGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnResGtr{Trm: selOpnResGtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnResLeqTrm, ok := x.SelOpnResLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnResLeq{Trm: selOpnResLeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnResGeqTrm, ok := x.SelOpnResGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnResGeq{Trm: selOpnResGeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnReqEqlTrm, ok := x.SelOpnReqEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnReqEql{Trm: selOpnReqEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnReqNeqTrm, ok := x.SelOpnReqNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnReqNeq{Trm: selOpnReqNeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnReqLssTrm, ok := x.SelOpnReqLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnReqLss{Trm: selOpnReqLssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnReqGtrTrm, ok := x.SelOpnReqGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnReqGtr{Trm: selOpnReqGtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnReqLeqTrm, ok := x.SelOpnReqLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnReqLeq{Trm: selOpnReqLeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnReqGeqTrm, ok := x.SelOpnReqGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnReqGeq{Trm: selOpnReqGeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selInstrEqlTrm, ok := x.SelInstrEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelInstrEql{Trm: selInstrEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selInstrNeqTrm, ok := x.SelInstrNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelInstrNeq{Trm: selInstrNeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selInstrLssTrm, ok := x.SelInstrLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelInstrLss{Trm: selInstrLssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selInstrGtrTrm, ok := x.SelInstrGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelInstrGtr{Trm: selInstrGtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selInstrLeqTrm, ok := x.SelInstrLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelInstrLeq{Trm: selInstrLeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selInstrGeqTrm, ok := x.SelInstrGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelInstrGeq{Trm: selInstrGeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selUnitsEqlTrm, ok := x.SelUnitsEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelUnitsEql{Trm: selUnitsEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selUnitsNeqTrm, ok := x.SelUnitsNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelUnitsNeq{Trm: selUnitsNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selUnitsLssTrm, ok := x.SelUnitsLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelUnitsLss{Trm: selUnitsLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selUnitsGtrTrm, ok := x.SelUnitsGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelUnitsGtr{Trm: selUnitsGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selUnitsLeqTrm, ok := x.SelUnitsLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelUnitsLeq{Trm: selUnitsLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selUnitsGeqTrm, ok := x.SelUnitsGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelUnitsGeq{Trm: selUnitsGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selMrgnRtioEqlTrm, ok := x.SelMrgnRtioEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelMrgnRtioEql{Trm: selMrgnRtioEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selMrgnRtioNeqTrm, ok := x.SelMrgnRtioNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelMrgnRtioNeq{Trm: selMrgnRtioNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selMrgnRtioLssTrm, ok := x.SelMrgnRtioLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelMrgnRtioLss{Trm: selMrgnRtioLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selMrgnRtioGtrTrm, ok := x.SelMrgnRtioGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelMrgnRtioGtr{Trm: selMrgnRtioGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selMrgnRtioLeqTrm, ok := x.SelMrgnRtioLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelMrgnRtioLeq{Trm: selMrgnRtioLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selMrgnRtioGeqTrm, ok := x.SelMrgnRtioGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelMrgnRtioGeq{Trm: selMrgnRtioGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selTrdPctEqlTrm, ok := x.SelTrdPctEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelTrdPctEql{Trm: selTrdPctEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selTrdPctNeqTrm, ok := x.SelTrdPctNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelTrdPctNeq{Trm: selTrdPctNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selTrdPctLssTrm, ok := x.SelTrdPctLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelTrdPctLss{Trm: selTrdPctLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selTrdPctGtrTrm, ok := x.SelTrdPctGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelTrdPctGtr{Trm: selTrdPctGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selTrdPctLeqTrm, ok := x.SelTrdPctLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelTrdPctLeq{Trm: selTrdPctLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selTrdPctGeqTrm, ok := x.SelTrdPctGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelTrdPctGeq{Trm: selTrdPctGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdActEqlTrm, ok := x.SelClsBalUsdActEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdActEql{Trm: selClsBalUsdActEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdActNeqTrm, ok := x.SelClsBalUsdActNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdActNeq{Trm: selClsBalUsdActNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdActLssTrm, ok := x.SelClsBalUsdActLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdActLss{Trm: selClsBalUsdActLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdActGtrTrm, ok := x.SelClsBalUsdActGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdActGtr{Trm: selClsBalUsdActGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdActLeqTrm, ok := x.SelClsBalUsdActLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdActLeq{Trm: selClsBalUsdActLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdActGeqTrm, ok := x.SelClsBalUsdActGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdActGeq{Trm: selClsBalUsdActGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdEqlTrm, ok := x.SelClsBalUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdEql{Trm: selClsBalUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdNeqTrm, ok := x.SelClsBalUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdNeq{Trm: selClsBalUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdLssTrm, ok := x.SelClsBalUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdLss{Trm: selClsBalUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdGtrTrm, ok := x.SelClsBalUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdGtr{Trm: selClsBalUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdLeqTrm, ok := x.SelClsBalUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdLeq{Trm: selClsBalUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBalUsdGeqTrm, ok := x.SelClsBalUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBalUsdGeq{Trm: selClsBalUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBalUsdEqlTrm, ok := x.SelOpnBalUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBalUsdEql{Trm: selOpnBalUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBalUsdNeqTrm, ok := x.SelOpnBalUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBalUsdNeq{Trm: selOpnBalUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBalUsdLssTrm, ok := x.SelOpnBalUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBalUsdLss{Trm: selOpnBalUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBalUsdGtrTrm, ok := x.SelOpnBalUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBalUsdGtr{Trm: selOpnBalUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBalUsdLeqTrm, ok := x.SelOpnBalUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBalUsdLeq{Trm: selOpnBalUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBalUsdGeqTrm, ok := x.SelOpnBalUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBalUsdGeq{Trm: selOpnBalUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstOpnSpdUsdEqlTrm, ok := x.SelCstOpnSpdUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstOpnSpdUsdEql{Trm: selCstOpnSpdUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstOpnSpdUsdNeqTrm, ok := x.SelCstOpnSpdUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstOpnSpdUsdNeq{Trm: selCstOpnSpdUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstOpnSpdUsdLssTrm, ok := x.SelCstOpnSpdUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstOpnSpdUsdLss{Trm: selCstOpnSpdUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstOpnSpdUsdGtrTrm, ok := x.SelCstOpnSpdUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstOpnSpdUsdGtr{Trm: selCstOpnSpdUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstOpnSpdUsdLeqTrm, ok := x.SelCstOpnSpdUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstOpnSpdUsdLeq{Trm: selCstOpnSpdUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstOpnSpdUsdGeqTrm, ok := x.SelCstOpnSpdUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstOpnSpdUsdGeq{Trm: selCstOpnSpdUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstClsSpdUsdEqlTrm, ok := x.SelCstClsSpdUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstClsSpdUsdEql{Trm: selCstClsSpdUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstClsSpdUsdNeqTrm, ok := x.SelCstClsSpdUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstClsSpdUsdNeq{Trm: selCstClsSpdUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstClsSpdUsdLssTrm, ok := x.SelCstClsSpdUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstClsSpdUsdLss{Trm: selCstClsSpdUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstClsSpdUsdGtrTrm, ok := x.SelCstClsSpdUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstClsSpdUsdGtr{Trm: selCstClsSpdUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstClsSpdUsdLeqTrm, ok := x.SelCstClsSpdUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstClsSpdUsdLeq{Trm: selCstClsSpdUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstClsSpdUsdGeqTrm, ok := x.SelCstClsSpdUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstClsSpdUsdGeq{Trm: selCstClsSpdUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstComUsdEqlTrm, ok := x.SelCstComUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstComUsdEql{Trm: selCstComUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstComUsdNeqTrm, ok := x.SelCstComUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstComUsdNeq{Trm: selCstComUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstComUsdLssTrm, ok := x.SelCstComUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstComUsdLss{Trm: selCstComUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstComUsdGtrTrm, ok := x.SelCstComUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstComUsdGtr{Trm: selCstComUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstComUsdLeqTrm, ok := x.SelCstComUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstComUsdLeq{Trm: selCstComUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selCstComUsdGeqTrm, ok := x.SelCstComUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelCstComUsdGeq{Trm: selCstComUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlGrsUsdEqlTrm, ok := x.SelPnlGrsUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlGrsUsdEql{Trm: selPnlGrsUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlGrsUsdNeqTrm, ok := x.SelPnlGrsUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlGrsUsdNeq{Trm: selPnlGrsUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlGrsUsdLssTrm, ok := x.SelPnlGrsUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlGrsUsdLss{Trm: selPnlGrsUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlGrsUsdGtrTrm, ok := x.SelPnlGrsUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlGrsUsdGtr{Trm: selPnlGrsUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlGrsUsdLeqTrm, ok := x.SelPnlGrsUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlGrsUsdLeq{Trm: selPnlGrsUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlGrsUsdGeqTrm, ok := x.SelPnlGrsUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlGrsUsdGeq{Trm: selPnlGrsUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlUsdEqlTrm, ok := x.SelPnlUsdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlUsdEql{Trm: selPnlUsdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlUsdNeqTrm, ok := x.SelPnlUsdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlUsdNeq{Trm: selPnlUsdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlUsdLssTrm, ok := x.SelPnlUsdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlUsdLss{Trm: selPnlUsdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlUsdGtrTrm, ok := x.SelPnlUsdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlUsdGtr{Trm: selPnlUsdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlUsdLeqTrm, ok := x.SelPnlUsdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlUsdLeq{Trm: selPnlUsdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlUsdGeqTrm, ok := x.SelPnlUsdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlUsdGeq{Trm: selPnlUsdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctPredictEqlTrm, ok := x.SelPnlPctPredictEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctPredictEql{Trm: selPnlPctPredictEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctPredictNeqTrm, ok := x.SelPnlPctPredictNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctPredictNeq{Trm: selPnlPctPredictNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctPredictLssTrm, ok := x.SelPnlPctPredictLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctPredictLss{Trm: selPnlPctPredictLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctPredictGtrTrm, ok := x.SelPnlPctPredictGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctPredictGtr{Trm: selPnlPctPredictGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctPredictLeqTrm, ok := x.SelPnlPctPredictLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctPredictLeq{Trm: selPnlPctPredictLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctPredictGeqTrm, ok := x.SelPnlPctPredictGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctPredictGeq{Trm: selPnlPctPredictGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctEqlTrm, ok := x.SelPnlPctEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctEql{Trm: selPnlPctEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctNeqTrm, ok := x.SelPnlPctNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctNeq{Trm: selPnlPctNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctLssTrm, ok := x.SelPnlPctLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctLss{Trm: selPnlPctLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctGtrTrm, ok := x.SelPnlPctGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctGtr{Trm: selPnlPctGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctLeqTrm, ok := x.SelPnlPctLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctLeq{Trm: selPnlPctLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPnlPctGeqTrm, ok := x.SelPnlPctGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPnlPctGeq{Trm: selPnlPctGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selIsLongEqlTrm, ok := x.SelIsLongEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelIsLongEql{Trm: selIsLongEqlTrm, X: X, I0: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selIsLongNeqTrm, ok := x.SelIsLongNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelIsLongNeq{Trm: selIsLongNeqTrm, X: X, I0: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selDurEqlTrm, ok := x.SelDurEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelDurEql{Trm: selDurEqlTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selDurNeqTrm, ok := x.SelDurNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelDurNeq{Trm: selDurNeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selDurLssTrm, ok := x.SelDurLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelDurLss{Trm: selDurLssTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selDurGtrTrm, ok := x.SelDurGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelDurGtr{Trm: selDurGtrTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selDurLeqTrm, ok := x.SelDurLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelDurLeq{Trm: selDurLeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selDurGeqTrm, ok := x.SelDurGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelDurGeq{Trm: selDurGeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPipEqlTrm, ok := x.SelPipEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPipEql{Trm: selPipEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPipNeqTrm, ok := x.SelPipNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPipNeq{Trm: selPipNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPipLssTrm, ok := x.SelPipLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPipLss{Trm: selPipLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPipGtrTrm, ok := x.SelPipGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPipGtr{Trm: selPipGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPipLeqTrm, ok := x.SelPipLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPipLeq{Trm: selPipLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selPipGeqTrm, ok := x.SelPipGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelPipGeq{Trm: selPipGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsRsnEqlTrm, ok := x.SelClsRsnEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsRsnEql{Trm: selClsRsnEqlTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsRsnNeqTrm, ok := x.SelClsRsnNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsRsnNeq{Trm: selClsRsnNeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsRsnLssTrm, ok := x.SelClsRsnLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsRsnLss{Trm: selClsRsnLssTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsRsnGtrTrm, ok := x.SelClsRsnGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsRsnGtr{Trm: selClsRsnGtrTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsRsnLeqTrm, ok := x.SelClsRsnLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsRsnLeq{Trm: selClsRsnLeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsRsnGeqTrm, ok := x.SelClsRsnGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsRsnGeq{Trm: selClsRsnGeqTrm, X: X, I0: x.Xpr(scp).(StrStrXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsSpdEqlTrm, ok := x.SelClsSpdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsSpdEql{Trm: selClsSpdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsSpdNeqTrm, ok := x.SelClsSpdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsSpdNeq{Trm: selClsSpdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsSpdLssTrm, ok := x.SelClsSpdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsSpdLss{Trm: selClsSpdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsSpdGtrTrm, ok := x.SelClsSpdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsSpdGtr{Trm: selClsSpdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsSpdLeqTrm, ok := x.SelClsSpdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsSpdLeq{Trm: selClsSpdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsSpdGeqTrm, ok := x.SelClsSpdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsSpdGeq{Trm: selClsSpdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnSpdEqlTrm, ok := x.SelOpnSpdEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnSpdEql{Trm: selOpnSpdEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnSpdNeqTrm, ok := x.SelOpnSpdNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnSpdNeq{Trm: selOpnSpdNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnSpdLssTrm, ok := x.SelOpnSpdLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnSpdLss{Trm: selOpnSpdLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnSpdGtrTrm, ok := x.SelOpnSpdGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnSpdGtr{Trm: selOpnSpdGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnSpdLeqTrm, ok := x.SelOpnSpdLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnSpdLeq{Trm: selOpnSpdLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnSpdGeqTrm, ok := x.SelOpnSpdGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnSpdGeq{Trm: selOpnSpdGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsAskEqlTrm, ok := x.SelClsAskEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsAskEql{Trm: selClsAskEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsAskNeqTrm, ok := x.SelClsAskNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsAskNeq{Trm: selClsAskNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsAskLssTrm, ok := x.SelClsAskLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsAskLss{Trm: selClsAskLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsAskGtrTrm, ok := x.SelClsAskGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsAskGtr{Trm: selClsAskGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsAskLeqTrm, ok := x.SelClsAskLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsAskLeq{Trm: selClsAskLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsAskGeqTrm, ok := x.SelClsAskGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsAskGeq{Trm: selClsAskGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnAskEqlTrm, ok := x.SelOpnAskEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnAskEql{Trm: selOpnAskEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnAskNeqTrm, ok := x.SelOpnAskNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnAskNeq{Trm: selOpnAskNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnAskLssTrm, ok := x.SelOpnAskLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnAskLss{Trm: selOpnAskLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnAskGtrTrm, ok := x.SelOpnAskGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnAskGtr{Trm: selOpnAskGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnAskLeqTrm, ok := x.SelOpnAskLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnAskLeq{Trm: selOpnAskLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnAskGeqTrm, ok := x.SelOpnAskGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnAskGeq{Trm: selOpnAskGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBidEqlTrm, ok := x.SelClsBidEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBidEql{Trm: selClsBidEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBidNeqTrm, ok := x.SelClsBidNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBidNeq{Trm: selClsBidNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBidLssTrm, ok := x.SelClsBidLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBidLss{Trm: selClsBidLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBidGtrTrm, ok := x.SelClsBidGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBidGtr{Trm: selClsBidGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBidLeqTrm, ok := x.SelClsBidLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBidLeq{Trm: selClsBidLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsBidGeqTrm, ok := x.SelClsBidGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsBidGeq{Trm: selClsBidGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBidEqlTrm, ok := x.SelOpnBidEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBidEql{Trm: selOpnBidEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBidNeqTrm, ok := x.SelOpnBidNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBidNeq{Trm: selOpnBidNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBidLssTrm, ok := x.SelOpnBidLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBidLss{Trm: selOpnBidLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBidGtrTrm, ok := x.SelOpnBidGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBidGtr{Trm: selOpnBidGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBidLeqTrm, ok := x.SelOpnBidLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBidLeq{Trm: selOpnBidLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnBidGeqTrm, ok := x.SelOpnBidGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnBidGeq{Trm: selOpnBidGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsTmeEqlTrm, ok := x.SelClsTmeEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsTmeEql{Trm: selClsTmeEqlTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsTmeNeqTrm, ok := x.SelClsTmeNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsTmeNeq{Trm: selClsTmeNeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsTmeLssTrm, ok := x.SelClsTmeLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsTmeLss{Trm: selClsTmeLssTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsTmeGtrTrm, ok := x.SelClsTmeGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsTmeGtr{Trm: selClsTmeGtrTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsTmeLeqTrm, ok := x.SelClsTmeLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsTmeLeq{Trm: selClsTmeLeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selClsTmeGeqTrm, ok := x.SelClsTmeGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelClsTmeGeq{Trm: selClsTmeGeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnTmeEqlTrm, ok := x.SelOpnTmeEql()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnTmeEql{Trm: selOpnTmeEqlTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnTmeNeqTrm, ok := x.SelOpnTmeNeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnTmeNeq{Trm: selOpnTmeNeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnTmeLssTrm, ok := x.SelOpnTmeLss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnTmeLss{Trm: selOpnTmeLssTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnTmeGtrTrm, ok := x.SelOpnTmeGtr()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnTmeGtr{Trm: selOpnTmeGtrTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnTmeLeqTrm, ok := x.SelOpnTmeLeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnTmeLeq{Trm: selOpnTmeLeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selOpnTmeGeqTrm, ok := x.SelOpnTmeGeq()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsSelOpnTmeGeq{Trm: selOpnTmeGeqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			trdPctsTrm, ok := x.TrdPcts()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsTrdPcts{Trm: trdPctsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(AnaTrdXpr)}
				x.NextRprn()
				return x.AnaTrdsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unitssTrm, ok := x.Unitss()
			if ok {
				x.NextLprn()
				cur := &AnaTrdsUnitss{Trm: unitssTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("AnaTrdsXpr: no expression found")
	}
	return X
}
func (x *Xprr) AnaPrfmXpr(scp *Scp, X AnaPrfmXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ana asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ana asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaPrfm)
				return x.AnaPrfmXpr(scp, &AnaPrfmAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'c':
			cstTotUsdTrm, ok := x.CstTotUsd()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmCstTotUsdGet{Trm: cstTotUsdTrm, X: X})
			}
			x.Scn = scn // rewind
			cstSpdUsdTrm, ok := x.CstSpdUsd()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmCstSpdUsdGet{Trm: cstSpdUsdTrm, X: X})
			}
			x.Scn = scn // rewind
			cstComUsdTrm, ok := x.CstComUsd()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmCstComUsdGet{Trm: cstComUsdTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'd':
			dltTrm, ok := x.Dlt()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmDlt{Trm: dltTrm, X: X, I0: x.Xpr(scp).(AnaPrfmXpr)}
				x.NextRprn()
				return x.AnaPrfmDltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			durAvgTrm, ok := x.DurAvg()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDurAvgGet{Trm: durAvgTrm, X: X})
			}
			x.Scn = scn // rewind
			durMdnTrm, ok := x.DurMdn()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDurMdnGet{Trm: durMdnTrm, X: X})
			}
			x.Scn = scn // rewind
			durMinTrm, ok := x.DurMin()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDurMinGet{Trm: durMinTrm, X: X})
			}
			x.Scn = scn // rewind
			durMaxTrm, ok := x.DurMax()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDurMaxGet{Trm: durMaxTrm, X: X})
			}
			x.Scn = scn // rewind
			durLimMaxTrm, ok := x.DurLimMax()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDurLimMaxGet{Trm: durLimMaxTrm, X: X})
			}
			x.Scn = scn // rewind
			dayCntTrm, ok := x.DayCnt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.UntUntXpr(scp, &AnaPrfmDayCntGet{Trm: dayCntTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'l':
			losLimMaxTrm, ok := x.LosLimMax()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmLosLimMaxGet{Trm: losLimMaxTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'o':
			opnPerDayTrm, ok := x.OpnPerDay()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmOpnPerDayGet{Trm: opnPerDayTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'p':
			pnlPctTrm, ok := x.PnlPct()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPnlPctGet{Trm: pnlPctTrm, X: X})
			}
			x.Scn = scn // rewind
			pipPerDayTrm, ok := x.PipPerDay()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPipPerDayGet{Trm: pipPerDayTrm, X: X})
			}
			x.Scn = scn // rewind
			pnlUsdTrm, ok := x.PnlUsd()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPnlUsdGet{Trm: pnlUsdTrm, X: X})
			}
			x.Scn = scn // rewind
			pipAvgTrm, ok := x.PipAvg()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPipAvgGet{Trm: pipAvgTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMdnTrm, ok := x.PipMdn()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPipMdnGet{Trm: pipMdnTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMinTrm, ok := x.PipMin()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPipMinGet{Trm: pipMinTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMaxTrm, ok := x.PipMax()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPipMaxGet{Trm: pipMaxTrm, X: X})
			}
			x.Scn = scn // rewind
			pipSumTrm, ok := x.PipSum()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmPipSumGet{Trm: pipSumTrm, X: X})
			}
			x.Scn = scn // rewind
		case 's':
			scsPctTrm, ok := x.ScsPct()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmScsPctGet{Trm: scsPctTrm, X: X})
			}
			x.Scn = scn // rewind
			scsPerDayTrm, ok := x.ScsPerDay()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmScsPerDayGet{Trm: scsPerDayTrm, X: X})
			}
			x.Scn = scn // rewind
		case 't':
			trdCntTrm, ok := x.TrdCnt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.UntUntXpr(scp, &AnaPrfmTrdCntGet{Trm: trdCntTrm, X: X})
			}
			x.Scn = scn // rewind
			trdPctTrm, ok := x.TrdPct()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmTrdPctGet{Trm: trdPctTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'u':
			usdPerDayTrm, ok := x.UsdPerDay()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmUsdPerDayGet{Trm: usdPerDayTrm, X: X})
			}
			x.Scn = scn // rewind
		}
		x.Panicf("AnaPrfmXpr: no expression found")
	}
	return X
}
func (x *Xprr) AnaPrfmsXpr(scp *Scp, X AnaPrfmsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ana asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ana asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaPrfms)
				return x.AnaPrfmsXpr(scp, &AnaPrfmsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cstTotUsdsTrm, ok := x.CstTotUsds()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsCstTotUsds{Trm: cstTotUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cstSpdUsdsTrm, ok := x.CstSpdUsds()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsCstSpdUsds{Trm: cstSpdUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cstComUsdsTrm, ok := x.CstComUsds()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsCstComUsds{Trm: cstComUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			durAvgsTrm, ok := x.DurAvgs()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDurAvgs{Trm: durAvgsTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			durMdnsTrm, ok := x.DurMdns()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDurMdns{Trm: durMdnsTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			durMinsTrm, ok := x.DurMins()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDurMins{Trm: durMinsTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			durMaxsTrm, ok := x.DurMaxs()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDurMaxs{Trm: durMaxsTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			durLimMaxsTrm, ok := x.DurLimMaxs()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDurLimMaxs{Trm: durLimMaxsTrm, X: X}
				x.NextRprn()
				return x.TmesTmesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			dayCntsTrm, ok := x.DayCnts()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsDayCnts{Trm: dayCntsTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaPrfm)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &AnaPrfmsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(AnaPrfmXpr)}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			losLimMaxsTrm, ok := x.LosLimMaxs()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsLosLimMaxs{Trm: losLimMaxsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []AnaPrfmsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(AnaPrfmsXpr)
					if !ok {
						x.Panicf("AnaPrfmsXpr: Mrg: non AnaPrfmsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &AnaPrfmsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			opnPerDaysTrm, ok := x.OpnPerDays()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsOpnPerDays{Trm: opnPerDaysTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaPrfm)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &AnaPrfmsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []AnaPrfmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(AnaPrfmXpr)
					if !ok {
						x.Panicf("AnaPrfmsXpr: Push: non AnaPrfmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &AnaPrfmsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pnlPctsTrm, ok := x.PnlPcts()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPnlPcts{Trm: pnlPctsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipPerDaysTrm, ok := x.PipPerDays()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPipPerDays{Trm: pipPerDaysTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pnlUsdsTrm, ok := x.PnlUsds()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPnlUsds{Trm: pnlUsdsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipAvgsTrm, ok := x.PipAvgs()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPipAvgs{Trm: pipAvgsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipMdnsTrm, ok := x.PipMdns()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPipMdns{Trm: pipMdnsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipMinsTrm, ok := x.PipMins()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPipMins{Trm: pipMinsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipMaxsTrm, ok := x.PipMaxs()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPipMaxs{Trm: pipMaxsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pipSumsTrm, ok := x.PipSums()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPipSums{Trm: pipSumsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pthsTrm, ok := x.Pths()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsPths{Trm: pthsTrm, X: X}
				x.NextRprn()
				return x.StrsStrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []AnaPrfmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(AnaPrfmXpr)
					if !ok {
						x.Panicf("AnaPrfmsXpr: Que: non AnaPrfmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &AnaPrfmsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			scsPctsTrm, ok := x.ScsPcts()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsScsPcts{Trm: scsPctsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			scsPerDaysTrm, ok := x.ScsPerDays()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsScsPerDays{Trm: scsPerDaysTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			trdCntsTrm, ok := x.TrdCnts()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsTrdCnts{Trm: trdCntsTrm, X: X}
				x.NextRprn()
				return x.UntsUntsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			trdPctsTrm, ok := x.TrdPcts()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsTrdPcts{Trm: trdPctsTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(AnaPrfmXpr)}
				x.NextRprn()
				return x.AnaPrfmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			usdPerDaysTrm, ok := x.UsdPerDays()
			if ok {
				x.NextLprn()
				cur := &AnaPrfmsUsdPerDays{Trm: usdPerDaysTrm, X: X}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("AnaPrfmsXpr: no expression found")
	}
	return X
}
func (x *Xprr) AnaPrfmDltXpr(scp *Scp, X AnaPrfmDltXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ana asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ana asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaPrfmDlt)
				return x.AnaPrfmDltXpr(scp, &AnaPrfmDltAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'd':
			durAvgATrm, ok := x.DurAvgA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurAvgAGet{Trm: durAvgATrm, X: X})
			}
			x.Scn = scn // rewind
			durAvgBTrm, ok := x.DurAvgB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurAvgBGet{Trm: durAvgBTrm, X: X})
			}
			x.Scn = scn // rewind
			durAvgDltTrm, ok := x.DurAvgDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltDurAvgDltGet{Trm: durAvgDltTrm, X: X})
			}
			x.Scn = scn // rewind
			durMdnATrm, ok := x.DurMdnA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurMdnAGet{Trm: durMdnATrm, X: X})
			}
			x.Scn = scn // rewind
			durMdnBTrm, ok := x.DurMdnB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurMdnBGet{Trm: durMdnBTrm, X: X})
			}
			x.Scn = scn // rewind
			durMdnDltTrm, ok := x.DurMdnDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltDurMdnDltGet{Trm: durMdnDltTrm, X: X})
			}
			x.Scn = scn // rewind
			durMinATrm, ok := x.DurMinA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurMinAGet{Trm: durMinATrm, X: X})
			}
			x.Scn = scn // rewind
			durMinBTrm, ok := x.DurMinB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurMinBGet{Trm: durMinBTrm, X: X})
			}
			x.Scn = scn // rewind
			durMinDltTrm, ok := x.DurMinDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltDurMinDltGet{Trm: durMinDltTrm, X: X})
			}
			x.Scn = scn // rewind
			durMaxATrm, ok := x.DurMaxA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurMaxAGet{Trm: durMaxATrm, X: X})
			}
			x.Scn = scn // rewind
			durMaxBTrm, ok := x.DurMaxB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.TmeTmeXpr(scp, &AnaPrfmDltDurMaxBGet{Trm: durMaxBTrm, X: X})
			}
			x.Scn = scn // rewind
			durMaxDltTrm, ok := x.DurMaxDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltDurMaxDltGet{Trm: durMaxDltTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'o':
			opnPerDayATrm, ok := x.OpnPerDayA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltOpnPerDayAGet{Trm: opnPerDayATrm, X: X})
			}
			x.Scn = scn // rewind
			opnPerDayBTrm, ok := x.OpnPerDayB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltOpnPerDayBGet{Trm: opnPerDayBTrm, X: X})
			}
			x.Scn = scn // rewind
			opnPerDayDltTrm, ok := x.OpnPerDayDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltOpnPerDayDltGet{Trm: opnPerDayDltTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'p':
			pnlPctATrm, ok := x.PnlPctA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPnlPctAGet{Trm: pnlPctATrm, X: X})
			}
			x.Scn = scn // rewind
			pnlPctBTrm, ok := x.PnlPctB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPnlPctBGet{Trm: pnlPctBTrm, X: X})
			}
			x.Scn = scn // rewind
			pnlPctDltTrm, ok := x.PnlPctDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPnlPctDltGet{Trm: pnlPctDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pipPerDayATrm, ok := x.PipPerDayA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipPerDayAGet{Trm: pipPerDayATrm, X: X})
			}
			x.Scn = scn // rewind
			pipPerDayBTrm, ok := x.PipPerDayB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipPerDayBGet{Trm: pipPerDayBTrm, X: X})
			}
			x.Scn = scn // rewind
			pipPerDayDltTrm, ok := x.PipPerDayDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipPerDayDltGet{Trm: pipPerDayDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pnlUsdATrm, ok := x.PnlUsdA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPnlUsdAGet{Trm: pnlUsdATrm, X: X})
			}
			x.Scn = scn // rewind
			pnlUsdBTrm, ok := x.PnlUsdB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPnlUsdBGet{Trm: pnlUsdBTrm, X: X})
			}
			x.Scn = scn // rewind
			pnlUsdDltTrm, ok := x.PnlUsdDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPnlUsdDltGet{Trm: pnlUsdDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pipAvgATrm, ok := x.PipAvgA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipAvgAGet{Trm: pipAvgATrm, X: X})
			}
			x.Scn = scn // rewind
			pipAvgBTrm, ok := x.PipAvgB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipAvgBGet{Trm: pipAvgBTrm, X: X})
			}
			x.Scn = scn // rewind
			pipAvgDltTrm, ok := x.PipAvgDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipAvgDltGet{Trm: pipAvgDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMdnATrm, ok := x.PipMdnA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMdnAGet{Trm: pipMdnATrm, X: X})
			}
			x.Scn = scn // rewind
			pipMdnBTrm, ok := x.PipMdnB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMdnBGet{Trm: pipMdnBTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMdnDltTrm, ok := x.PipMdnDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMdnDltGet{Trm: pipMdnDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMinATrm, ok := x.PipMinA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMinAGet{Trm: pipMinATrm, X: X})
			}
			x.Scn = scn // rewind
			pipMinBTrm, ok := x.PipMinB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMinBGet{Trm: pipMinBTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMinDltTrm, ok := x.PipMinDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMinDltGet{Trm: pipMinDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMaxATrm, ok := x.PipMaxA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMaxAGet{Trm: pipMaxATrm, X: X})
			}
			x.Scn = scn // rewind
			pipMaxBTrm, ok := x.PipMaxB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMaxBGet{Trm: pipMaxBTrm, X: X})
			}
			x.Scn = scn // rewind
			pipMaxDltTrm, ok := x.PipMaxDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipMaxDltGet{Trm: pipMaxDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pipSumATrm, ok := x.PipSumA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipSumAGet{Trm: pipSumATrm, X: X})
			}
			x.Scn = scn // rewind
			pipSumBTrm, ok := x.PipSumB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipSumBGet{Trm: pipSumBTrm, X: X})
			}
			x.Scn = scn // rewind
			pipSumDltTrm, ok := x.PipSumDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltPipSumDltGet{Trm: pipSumDltTrm, X: X})
			}
			x.Scn = scn // rewind
			pthBTrm, ok := x.PthB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.StrStrXpr(scp, &AnaPrfmDltPthBGet{Trm: pthBTrm, X: X})
			}
			x.Scn = scn // rewind
		case 's':
			scsPctATrm, ok := x.ScsPctA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltScsPctAGet{Trm: scsPctATrm, X: X})
			}
			x.Scn = scn // rewind
			scsPctBTrm, ok := x.ScsPctB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltScsPctBGet{Trm: scsPctBTrm, X: X})
			}
			x.Scn = scn // rewind
			scsPctDltTrm, ok := x.ScsPctDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltScsPctDltGet{Trm: scsPctDltTrm, X: X})
			}
			x.Scn = scn // rewind
			scsPerDayATrm, ok := x.ScsPerDayA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltScsPerDayAGet{Trm: scsPerDayATrm, X: X})
			}
			x.Scn = scn // rewind
			scsPerDayBTrm, ok := x.ScsPerDayB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltScsPerDayBGet{Trm: scsPerDayBTrm, X: X})
			}
			x.Scn = scn // rewind
			scsPerDayDltTrm, ok := x.ScsPerDayDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltScsPerDayDltGet{Trm: scsPerDayDltTrm, X: X})
			}
			x.Scn = scn // rewind
		case 't':
			trdCntATrm, ok := x.TrdCntA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.UntUntXpr(scp, &AnaPrfmDltTrdCntAGet{Trm: trdCntATrm, X: X})
			}
			x.Scn = scn // rewind
			trdCntBTrm, ok := x.TrdCntB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.UntUntXpr(scp, &AnaPrfmDltTrdCntBGet{Trm: trdCntBTrm, X: X})
			}
			x.Scn = scn // rewind
			trdCntDltTrm, ok := x.TrdCntDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltTrdCntDltGet{Trm: trdCntDltTrm, X: X})
			}
			x.Scn = scn // rewind
			trdPctATrm, ok := x.TrdPctA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltTrdPctAGet{Trm: trdPctATrm, X: X})
			}
			x.Scn = scn // rewind
			trdPctBTrm, ok := x.TrdPctB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltTrdPctBGet{Trm: trdPctBTrm, X: X})
			}
			x.Scn = scn // rewind
			trdPctDltTrm, ok := x.TrdPctDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltTrdPctDltGet{Trm: trdPctDltTrm, X: X})
			}
			x.Scn = scn // rewind
		case 'u':
			usdPerDayATrm, ok := x.UsdPerDayA()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltUsdPerDayAGet{Trm: usdPerDayATrm, X: X})
			}
			x.Scn = scn // rewind
			usdPerDayBTrm, ok := x.UsdPerDayB()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltUsdPerDayBGet{Trm: usdPerDayBTrm, X: X})
			}
			x.Scn = scn // rewind
			usdPerDayDltTrm, ok := x.UsdPerDayDlt()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &AnaPrfmDltUsdPerDayDltGet{Trm: usdPerDayDltTrm, X: X})
			}
			x.Scn = scn // rewind
		}
		x.Panicf("AnaPrfmDltXpr: no expression found")
	}
	return X
}
func (x *Xprr) AnaPortXpr(scp *Scp, X AnaPortXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Ana asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Ana asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Ana asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.AnaPort)
				return x.AnaPortXpr(scp, &AnaPortAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		}
		x.Panicf("AnaPortXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Hst()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makePrvsTrm, ok := x.MakePrvs()
				if ok {
					x.NextLprn()
					cur := &HstMakePrvs{Trm: makePrvsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstPrvsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpPrvsTrm, ok := x.MakeEmpPrvs()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpPrvs{Trm: makeEmpPrvsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstPrvsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeInstrsTrm, ok := x.MakeInstrs()
				if ok {
					x.NextLprn()
					cur := &HstMakeInstrs{Trm: makeInstrsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstInstrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpInstrsTrm, ok := x.MakeEmpInstrs()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpInstrs{Trm: makeEmpInstrsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstInstrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeInrvlsTrm, ok := x.MakeInrvls()
				if ok {
					x.NextLprn()
					cur := &HstMakeInrvls{Trm: makeInrvlsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstInrvlsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpInrvlsTrm, ok := x.MakeEmpInrvls()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpInrvls{Trm: makeEmpInrvlsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstInrvlsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeSidesTrm, ok := x.MakeSides()
				if ok {
					x.NextLprn()
					cur := &HstMakeSides{Trm: makeSidesTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstSidesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpSidesTrm, ok := x.MakeEmpSides()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpSides{Trm: makeEmpSidesTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstSidesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeStmsTrm, ok := x.MakeStms()
				if ok {
					x.NextLprn()
					cur := &HstMakeStms{Trm: makeStmsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstStmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpStmsTrm, ok := x.MakeEmpStms()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpStms{Trm: makeEmpStmsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstStmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeCndsTrm, ok := x.MakeCnds()
				if ok {
					x.NextLprn()
					cur := &HstMakeCnds{Trm: makeCndsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstCndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpCndsTrm, ok := x.MakeEmpCnds()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpCnds{Trm: makeEmpCndsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstCndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeStgysTrm, ok := x.MakeStgys()
				if ok {
					x.NextLprn()
					cur := &HstMakeStgys{Trm: makeStgysTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstStgysXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpStgysTrm, ok := x.MakeEmpStgys()
				if ok {
					x.NextLprn()
					cur := &HstMakeEmpStgys{Trm: makeEmpStgysTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.HstStgysXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newPrvsTrm, ok := x.NewPrvs()
				if ok {
					x.NextLprn()
					var i0 []HstPrvXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstPrvXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewPrvs: non HstPrvXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewPrvs{Trm: newPrvsTrm, I0: i0}
					x.NextRprn()
					return x.HstPrvsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newInstrsTrm, ok := x.NewInstrs()
				if ok {
					x.NextLprn()
					var i0 []HstInstrXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstInstrXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewInstrs: non HstInstrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewInstrs{Trm: newInstrsTrm, I0: i0}
					x.NextRprn()
					return x.HstInstrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newInrvlsTrm, ok := x.NewInrvls()
				if ok {
					x.NextLprn()
					var i0 []HstInrvlXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstInrvlXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewInrvls: non HstInrvlXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewInrvls{Trm: newInrvlsTrm, I0: i0}
					x.NextRprn()
					return x.HstInrvlsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newSidesTrm, ok := x.NewSides()
				if ok {
					x.NextLprn()
					var i0 []HstSideXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstSideXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewSides: non HstSideXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewSides{Trm: newSidesTrm, I0: i0}
					x.NextRprn()
					return x.HstSidesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newStmsTrm, ok := x.NewStms()
				if ok {
					x.NextLprn()
					var i0 []HstStmXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstStmXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewStms: non HstStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewStms{Trm: newStmsTrm, I0: i0}
					x.NextRprn()
					return x.HstStmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newCndsTrm, ok := x.NewCnds()
				if ok {
					x.NextLprn()
					var i0 []HstCndXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstCndXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewCnds: non HstCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewCnds{Trm: newCndsTrm, I0: i0}
					x.NextRprn()
					return x.HstCndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newStgysTrm, ok := x.NewStgys()
				if ok {
					x.NextLprn()
					var i0 []HstStgyXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(HstStgyXpr)
						if !ok {
							x.Panicf("HstPkgXpr: NewStgys: non HstStgyXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &HstNewStgys{Trm: newStgysTrm, I0: i0}
					x.NextRprn()
					return x.HstStgysXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'o':
				oanTrm, ok := x.Oan()
				if ok {
					x.NextLprn()
					cur := &HstOan{Trm: oanTrm}
					x.NextRprn()
					return x.HstPrvXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("HstPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) HstPrvXpr(scp *Scp, X HstPrvXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstPrv)
				return x.HstPrvXpr(scp, &HstPrvAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			audUsdTrm, ok := x.AudUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("HstPrvXpr: AudUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvAudUsd{Trm: audUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eurUsdTrm, ok := x.EurUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("HstPrvXpr: EurUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvEurUsd{Trm: eurUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gbpUsdTrm, ok := x.GbpUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("HstPrvXpr: GbpUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvGbpUsd{Trm: gbpUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstPrvName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			nzdUsdTrm, ok := x.NzdUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("HstPrvXpr: NzdUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvNzdUsd{Trm: nzdUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstPrvXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstInstrXpr(scp *Scp, X HstInstrXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInstr)
				return x.HstInstrXpr(scp, &HstInstrAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'i':
			iTrm, ok := x.I()
			if ok {
				x.NextLprn()
				cur := &HstInstrI{Trm: iTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstInstrName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstInstrXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstInrvlXpr(scp *Scp, X HstInrvlXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInrvl)
				return x.HstInrvlXpr(scp, &HstInrvlAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			askTrm, ok := x.Ask()
			if ok {
				x.NextLprn()
				cur := &HstInrvlAsk{Trm: askTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'b':
			bidTrm, ok := x.Bid()
			if ok {
				x.NextLprn()
				cur := &HstInrvlBid{Trm: bidTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstInrvlName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstInrvlXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstSideXpr(scp *Scp, X HstSideXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstSide)
				return x.HstSideXpr(scp, &HstSideAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			almaTrm, ok := x.Alma()
			if ok {
				x.NextLprn()
				cur := &HstSideAlma{Trm: almaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			emaTrm, ok := x.Ema()
			if ok {
				x.NextLprn()
				cur := &HstSideEma{Trm: emaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'f':
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstSideFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gmaTrm, ok := x.Gma()
			if ok {
				x.NextLprn()
				cur := &HstSideGma{Trm: gmaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstSideLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &HstSideMin{Trm: minTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &HstSideMax{Trm: maxTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &HstSideMid{Trm: midTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdnTrm, ok := x.Mdn()
			if ok {
				x.NextLprn()
				cur := &HstSideMdn{Trm: mdnTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstSideName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			prdTrm, ok := x.Prd()
			if ok {
				x.NextLprn()
				cur := &HstSidePrd{Trm: prdTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proLstTrm, ok := x.ProLst()
			if ok {
				x.NextLprn()
				cur := &HstSideProLst{Trm: proLstTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proSmaTrm, ok := x.ProSma()
			if ok {
				x.NextLprn()
				cur := &HstSideProSma{Trm: proSmaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proAlmaTrm, ok := x.ProAlma()
			if ok {
				x.NextLprn()
				cur := &HstSideProAlma{Trm: proAlmaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			rsiTrm, ok := x.Rsi()
			if ok {
				x.NextLprn()
				cur := &HstSideRsi{Trm: rsiTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngFulTrm, ok := x.RngFul()
			if ok {
				x.NextLprn()
				cur := &HstSideRngFul{Trm: rngFulTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngLstTrm, ok := x.RngLst()
			if ok {
				x.NextLprn()
				cur := &HstSideRngLst{Trm: rngLstTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			sumTrm, ok := x.Sum()
			if ok {
				x.NextLprn()
				cur := &HstSideSum{Trm: sumTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			smaTrm, ok := x.Sma()
			if ok {
				x.NextLprn()
				cur := &HstSideSma{Trm: smaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stdTrm, ok := x.Std()
			if ok {
				x.NextLprn()
				cur := &HstSideStd{Trm: stdTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sarTrm, ok := x.Sar()
			if ok {
				x.NextLprn()
				cur := &HstSideSar{Trm: sarTrm, X: X, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrncTrm, ok := x.Vrnc()
			if ok {
				x.NextLprn()
				cur := &HstSideVrnc{Trm: vrncTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			wmaTrm, ok := x.Wma()
			if ok {
				x.NextLprn()
				cur := &HstSideWma{Trm: wmaTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			wrsiTrm, ok := x.Wrsi()
			if ok {
				x.NextLprn()
				cur := &HstSideWrsi{Trm: wrsiTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstSideXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstStmXpr(scp *Scp, X HstStmXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStm)
				return x.HstStmXpr(scp, &HstStmAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstStmAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(TmesTmesXpr)}
				x.NextRprn()
				return x.FltsFltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggFstTrm, ok := x.AggFst()
			if ok {
				x.NextLprn()
				cur := &HstStmAggFst{Trm: aggFstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggLstTrm, ok := x.AggLst()
			if ok {
				x.NextLprn()
				cur := &HstStmAggLst{Trm: aggLstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggSumTrm, ok := x.AggSum()
			if ok {
				x.NextLprn()
				cur := &HstStmAggSum{Trm: aggSumTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggPrdTrm, ok := x.AggPrd()
			if ok {
				x.NextLprn()
				cur := &HstStmAggPrd{Trm: aggPrdTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMinTrm, ok := x.AggMin()
			if ok {
				x.NextLprn()
				cur := &HstStmAggMin{Trm: aggMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMaxTrm, ok := x.AggMax()
			if ok {
				x.NextLprn()
				cur := &HstStmAggMax{Trm: aggMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMidTrm, ok := x.AggMid()
			if ok {
				x.NextLprn()
				cur := &HstStmAggMid{Trm: aggMidTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMdnTrm, ok := x.AggMdn()
			if ok {
				x.NextLprn()
				cur := &HstStmAggMdn{Trm: aggMdnTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggSmaTrm, ok := x.AggSma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggSma{Trm: aggSmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggGmaTrm, ok := x.AggGma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggGma{Trm: aggGmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggWmaTrm, ok := x.AggWma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggWma{Trm: aggWmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggRsiTrm, ok := x.AggRsi()
			if ok {
				x.NextLprn()
				cur := &HstStmAggRsi{Trm: aggRsiTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggWrsiTrm, ok := x.AggWrsi()
			if ok {
				x.NextLprn()
				cur := &HstStmAggWrsi{Trm: aggWrsiTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggAlmaTrm, ok := x.AggAlma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggAlma{Trm: aggAlmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggVrncTrm, ok := x.AggVrnc()
			if ok {
				x.NextLprn()
				cur := &HstStmAggVrnc{Trm: aggVrncTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggStdTrm, ok := x.AggStd()
			if ok {
				x.NextLprn()
				cur := &HstStmAggStd{Trm: aggStdTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggRngFulTrm, ok := x.AggRngFul()
			if ok {
				x.NextLprn()
				cur := &HstStmAggRngFul{Trm: aggRngFulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggRngLstTrm, ok := x.AggRngLst()
			if ok {
				x.NextLprn()
				cur := &HstStmAggRngLst{Trm: aggRngLstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggProLstTrm, ok := x.AggProLst()
			if ok {
				x.NextLprn()
				cur := &HstStmAggProLst{Trm: aggProLstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggProSmaTrm, ok := x.AggProSma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggProSma{Trm: aggProSmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggProAlmaTrm, ok := x.AggProAlma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggProAlma{Trm: aggProAlmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggEmaTrm, ok := x.AggEma()
			if ok {
				x.NextLprn()
				cur := &HstStmAggEma{Trm: aggEmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			inrAddTrm, ok := x.InrAdd()
			if ok {
				x.NextLprn()
				cur := &HstStmInrAdd{Trm: inrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSubTrm, ok := x.InrSub()
			if ok {
				x.NextLprn()
				cur := &HstStmInrSub{Trm: inrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMulTrm, ok := x.InrMul()
			if ok {
				x.NextLprn()
				cur := &HstStmInrMul{Trm: inrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrDivTrm, ok := x.InrDiv()
			if ok {
				x.NextLprn()
				cur := &HstStmInrDiv{Trm: inrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrRemTrm, ok := x.InrRem()
			if ok {
				x.NextLprn()
				cur := &HstStmInrRem{Trm: inrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrPowTrm, ok := x.InrPow()
			if ok {
				x.NextLprn()
				cur := &HstStmInrPow{Trm: inrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMinTrm, ok := x.InrMin()
			if ok {
				x.NextLprn()
				cur := &HstStmInrMin{Trm: inrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMaxTrm, ok := x.InrMax()
			if ok {
				x.NextLprn()
				cur := &HstStmInrMax{Trm: inrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSlpTrm, ok := x.InrSlp()
			if ok {
				x.NextLprn()
				cur := &HstStmInrSlp{Trm: inrSlpTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrEqlTrm, ok := x.InrEql()
			if ok {
				x.NextLprn()
				cur := &HstStmInrEql{Trm: inrEqlTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrNeqTrm, ok := x.InrNeq()
			if ok {
				x.NextLprn()
				cur := &HstStmInrNeq{Trm: inrNeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrLssTrm, ok := x.InrLss()
			if ok {
				x.NextLprn()
				cur := &HstStmInrLss{Trm: inrLssTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrGtrTrm, ok := x.InrGtr()
			if ok {
				x.NextLprn()
				cur := &HstStmInrGtr{Trm: inrGtrTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrLeqTrm, ok := x.InrLeq()
			if ok {
				x.NextLprn()
				cur := &HstStmInrLeq{Trm: inrLeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrGeqTrm, ok := x.InrGeq()
			if ok {
				x.NextLprn()
				cur := &HstStmInrGeq{Trm: inrGeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstStmName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			otrAddTrm, ok := x.OtrAdd()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrAdd{Trm: otrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrSubTrm, ok := x.OtrSub()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrSub{Trm: otrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrMulTrm, ok := x.OtrMul()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrMul{Trm: otrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrDivTrm, ok := x.OtrDiv()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrDiv{Trm: otrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrRemTrm, ok := x.OtrRem()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrRem{Trm: otrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrPowTrm, ok := x.OtrPow()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrPow{Trm: otrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrMinTrm, ok := x.OtrMin()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrMin{Trm: otrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrMaxTrm, ok := x.OtrMax()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrMax{Trm: otrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrEqlTrm, ok := x.OtrEql()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrEql{Trm: otrEqlTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrNeqTrm, ok := x.OtrNeq()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrNeq{Trm: otrNeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrLssTrm, ok := x.OtrLss()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrLss{Trm: otrLssTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrGtrTrm, ok := x.OtrGtr()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrGtr{Trm: otrGtrTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrLeqTrm, ok := x.OtrLeq()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrLeq{Trm: otrLeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrGeqTrm, ok := x.OtrGeq()
			if ok {
				x.NextLprn()
				cur := &HstStmOtrGeq{Trm: otrGeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			sclAddTrm, ok := x.SclAdd()
			if ok {
				x.NextLprn()
				cur := &HstStmSclAdd{Trm: sclAddTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclSubTrm, ok := x.SclSub()
			if ok {
				x.NextLprn()
				cur := &HstStmSclSub{Trm: sclSubTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMulTrm, ok := x.SclMul()
			if ok {
				x.NextLprn()
				cur := &HstStmSclMul{Trm: sclMulTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclDivTrm, ok := x.SclDiv()
			if ok {
				x.NextLprn()
				cur := &HstStmSclDiv{Trm: sclDivTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclRemTrm, ok := x.SclRem()
			if ok {
				x.NextLprn()
				cur := &HstStmSclRem{Trm: sclRemTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclPowTrm, ok := x.SclPow()
			if ok {
				x.NextLprn()
				cur := &HstStmSclPow{Trm: sclPowTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMinTrm, ok := x.SclMin()
			if ok {
				x.NextLprn()
				cur := &HstStmSclMin{Trm: sclMinTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMaxTrm, ok := x.SclMax()
			if ok {
				x.NextLprn()
				cur := &HstStmSclMax{Trm: sclMaxTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selEqlTrm, ok := x.SelEql()
			if ok {
				x.NextLprn()
				cur := &HstStmSelEql{Trm: selEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selNeqTrm, ok := x.SelNeq()
			if ok {
				x.NextLprn()
				cur := &HstStmSelNeq{Trm: selNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLssTrm, ok := x.SelLss()
			if ok {
				x.NextLprn()
				cur := &HstStmSelLss{Trm: selLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGtrTrm, ok := x.SelGtr()
			if ok {
				x.NextLprn()
				cur := &HstStmSelGtr{Trm: selGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLeqTrm, ok := x.SelLeq()
			if ok {
				x.NextLprn()
				cur := &HstStmSelLeq{Trm: selLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGeqTrm, ok := x.SelGeq()
			if ok {
				x.NextLprn()
				cur := &HstStmSelGeq{Trm: selGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclEqlTrm, ok := x.SclEql()
			if ok {
				x.NextLprn()
				cur := &HstStmSclEql{Trm: sclEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclNeqTrm, ok := x.SclNeq()
			if ok {
				x.NextLprn()
				cur := &HstStmSclNeq{Trm: sclNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclLssTrm, ok := x.SclLss()
			if ok {
				x.NextLprn()
				cur := &HstStmSclLss{Trm: sclLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclGtrTrm, ok := x.SclGtr()
			if ok {
				x.NextLprn()
				cur := &HstStmSclGtr{Trm: sclGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclLeqTrm, ok := x.SclLeq()
			if ok {
				x.NextLprn()
				cur := &HstStmSclLeq{Trm: sclLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclGeqTrm, ok := x.SclGeq()
			if ok {
				x.NextLprn()
				cur := &HstStmSclGeq{Trm: sclGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			unaPosTrm, ok := x.UnaPos()
			if ok {
				x.NextLprn()
				cur := &HstStmUnaPos{Trm: unaPosTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaNegTrm, ok := x.UnaNeg()
			if ok {
				x.NextLprn()
				cur := &HstStmUnaNeg{Trm: unaNegTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaInvTrm, ok := x.UnaInv()
			if ok {
				x.NextLprn()
				cur := &HstStmUnaInv{Trm: unaInvTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaSqrTrm, ok := x.UnaSqr()
			if ok {
				x.NextLprn()
				cur := &HstStmUnaSqr{Trm: unaSqrTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaSqrtTrm, ok := x.UnaSqrt()
			if ok {
				x.NextLprn()
				cur := &HstStmUnaSqrt{Trm: unaSqrtTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstStmXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstCndXpr(scp *Scp, X HstCndXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstCnd)
				return x.HstCndXpr(scp, &HstCndAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			andTrm, ok := x.And()
			if ok {
				x.NextLprn()
				cur := &HstCndAnd{Trm: andTrm, X: X, I0: x.Xpr(scp).(HstCndXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstCndName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			seqTrm, ok := x.Seq()
			if ok {
				x.NextLprn()
				cur := &HstCndSeq{Trm: seqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(HstCndXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stgyTrm, ok := x.Stgy()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(BolBolXpr)
				i1 := x.Xpr(scp).(FltFltXpr)
				i2 := x.Xpr(scp).(FltFltXpr)
				i3 := x.Xpr(scp).(TmeTmeXpr)
				i4 := x.Xpr(scp).(FltFltXpr)
				i5 := x.Xpr(scp).(HstInstrXpr)
				i6 := x.Xpr(scp).(HstStmsXpr)
				var i7 []HstCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstCndXpr)
					if !ok {
						x.Panicf("HstCndXpr: Stgy: non HstCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i7 = append(i7, v)
				}
				cur := &HstCndStgy{Trm: stgyTrm, X: X, I0: i0, I1: i1, I2: i2, I3: i3, I4: i4, I5: i5, I6: i6, I7: i7}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstCndXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstStgyXpr(scp *Scp, X HstStgyXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStgy)
				return x.HstStgyXpr(scp, &HstStgyAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'n':
			nameTrm, ok := x.Name()
			if ok {
				x.NextLprn()
				cur := &HstStgyName{Trm: nameTrm, X: X}
				x.NextRprn()
				return x.StrStrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstStgyXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstPrvsXpr(scp *Scp, X HstPrvsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstPrvs)
				return x.HstPrvsXpr(scp, &HstPrvsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstPrvsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstPrvsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstPrvsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstPrvsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstPrvsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstPrvsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstPrv)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstPrvsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstPrvsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstPrvsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstPrvsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstPrvsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstPrvXpr)}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstPrvsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstPrvsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstPrvsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstPrvsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstPrvsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstPrvsXpr)
					if !ok {
						x.Panicf("HstPrvsXpr: Mrg: non HstPrvsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstPrvsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstPrvsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstPrv)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstPrvsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstPrvXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstPrvXpr)
					if !ok {
						x.Panicf("HstPrvsXpr: Push: non HstPrvXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstPrvsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstPrvXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstPrvXpr)
					if !ok {
						x.Panicf("HstPrvsXpr: Que: non HstPrvXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstPrvsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstPrvsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstPrvsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstPrvsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstPrvsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstPrvXpr)}
				x.NextRprn()
				return x.HstPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstPrvsXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstInstrsXpr(scp *Scp, X HstInstrsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInstrs)
				return x.HstInstrsXpr(scp, &HstInstrsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstInstrsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstInstrsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstInstrsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstInstrsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstInstrsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstInstrsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInstr)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstInstrsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstInstrsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstInstrsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstInstrsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstInstrsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstInstrXpr)}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstInstrsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstInstrsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstInstrsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstInstrsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstInstrsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstInstrsXpr)
					if !ok {
						x.Panicf("HstInstrsXpr: Mrg: non HstInstrsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstInstrsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstInstrsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstInstrsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInstr)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstInstrsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstInstrXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstInstrXpr)
					if !ok {
						x.Panicf("HstInstrsXpr: Push: non HstInstrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstInstrsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstInstrsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstInstrXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstInstrXpr)
					if !ok {
						x.Panicf("HstInstrsXpr: Que: non HstInstrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstInstrsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstInstrsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstInstrsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstInstrsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstInstrsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstInstrXpr)}
				x.NextRprn()
				return x.HstInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstInstrsXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstInrvlsXpr(scp *Scp, X HstInrvlsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInrvls)
				return x.HstInrvlsXpr(scp, &HstInrvlsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInrvl)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstInrvlsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstInrvlXpr)}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstInrvlsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstInrvlsXpr)
					if !ok {
						x.Panicf("HstInrvlsXpr: Mrg: non HstInrvlsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstInrvlsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstInrvl)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstInrvlsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstInrvlXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstInrvlXpr)
					if !ok {
						x.Panicf("HstInrvlsXpr: Push: non HstInrvlXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstInrvlsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstInrvlXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstInrvlXpr)
					if !ok {
						x.Panicf("HstInrvlsXpr: Que: non HstInrvlXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstInrvlsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstInrvlsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstInrvlXpr)}
				x.NextRprn()
				return x.HstInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstInrvlsXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstSidesXpr(scp *Scp, X HstSidesXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstSides)
				return x.HstSidesXpr(scp, &HstSidesAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstSidesAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstSidesCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstSidesCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstSidesClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstSidesDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstSidesDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstSide)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstSidesEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstSidesFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstSidesFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstSidesFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstSidesIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstSideXpr)}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstSidesIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstSidesInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstSidesLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstSidesLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstSidesXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstSidesXpr)
					if !ok {
						x.Panicf("HstSidesXpr: Mrg: non HstSidesXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstSidesMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstSidesMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstSidesMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstSide)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstSidesPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstSideXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstSideXpr)
					if !ok {
						x.Panicf("HstSidesXpr: Push: non HstSideXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstSidesPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstSidesPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstSideXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstSideXpr)
					if !ok {
						x.Panicf("HstSidesXpr: Que: non HstSideXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstSidesQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstSidesRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstSidesRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstSidesTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstSidesUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstSideXpr)}
				x.NextRprn()
				return x.HstSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstSidesXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstStmsXpr(scp *Scp, X HstStmsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStms)
				return x.HstStmsXpr(scp, &HstStmsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstStmsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstStmsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstStmsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstStmsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstStmsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstStmsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStm)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstStmsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstStmsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstStmsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstStmsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstStmsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstStmsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstStmsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstStmsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstStmsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstStmsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStmsXpr)
					if !ok {
						x.Panicf("HstStmsXpr: Mrg: non HstStmsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstStmsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstStmsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstStmsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStm)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstStmsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstStmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStmXpr)
					if !ok {
						x.Panicf("HstStmsXpr: Push: non HstStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstStmsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstStmsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstStmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStmXpr)
					if !ok {
						x.Panicf("HstStmsXpr: Que: non HstStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstStmsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstStmsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstStmsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstStmsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstStmsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.HstStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstStmsXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstCndsXpr(scp *Scp, X HstCndsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstCnds)
				return x.HstCndsXpr(scp, &HstCndsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstCndsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstCndsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstCndsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstCndsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstCndsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstCndsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstCnd)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstCndsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstCndsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstCndsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstCndsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstCndsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstCndXpr)}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstCndsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstCndsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstCndsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstCndsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstCndsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstCndsXpr)
					if !ok {
						x.Panicf("HstCndsXpr: Mrg: non HstCndsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstCndsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstCndsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstCndsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstCnd)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstCndsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstCndXpr)
					if !ok {
						x.Panicf("HstCndsXpr: Push: non HstCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstCndsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstCndsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstCndXpr)
					if !ok {
						x.Panicf("HstCndsXpr: Que: non HstCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstCndsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstCndsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstCndsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstCndsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstCndsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstCndXpr)}
				x.NextRprn()
				return x.HstCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstCndsXpr: no expression found")
	}
	return X
}
func (x *Xprr) HstStgysXpr(scp *Scp, X HstStgysXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Hst asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Hst asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStgys)
				return x.HstStgysXpr(scp, &HstStgysAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &HstStgysAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &HstStgysCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &HstStgysCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &HstStgysClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &HstStgysDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &HstStgysDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStgy)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstStgysEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &HstStgysFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &HstStgysFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &HstStgysFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &HstStgysIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStgyXpr)}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &HstStgysIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &HstStgysInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &HstStgysLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &HstStgysLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []HstStgysXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStgysXpr)
					if !ok {
						x.Panicf("HstStgysXpr: Mrg: non HstStgysXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstStgysMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &HstStgysMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &HstStgysMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Hst 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.HstStgy)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &HstStgysPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []HstStgyXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStgyXpr)
					if !ok {
						x.Panicf("HstStgysXpr: Push: non HstStgyXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstStgysPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &HstStgysPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.HstStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []HstStgyXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStgyXpr)
					if !ok {
						x.Panicf("HstStgysXpr: Que: non HstStgyXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &HstStgysQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &HstStgysRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &HstStgysRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &HstStgysTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &HstStgysUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(HstStgyXpr)}
				x.NextRprn()
				return x.HstStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("HstStgysXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Rlt()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'm':
				makePrvsTrm, ok := x.MakePrvs()
				if ok {
					x.NextLprn()
					cur := &RltMakePrvs{Trm: makePrvsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltPrvsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpPrvsTrm, ok := x.MakeEmpPrvs()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpPrvs{Trm: makeEmpPrvsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltPrvsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeInstrsTrm, ok := x.MakeInstrs()
				if ok {
					x.NextLprn()
					cur := &RltMakeInstrs{Trm: makeInstrsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltInstrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpInstrsTrm, ok := x.MakeEmpInstrs()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpInstrs{Trm: makeEmpInstrsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltInstrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeInrvlsTrm, ok := x.MakeInrvls()
				if ok {
					x.NextLprn()
					cur := &RltMakeInrvls{Trm: makeInrvlsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltInrvlsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpInrvlsTrm, ok := x.MakeEmpInrvls()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpInrvls{Trm: makeEmpInrvlsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltInrvlsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeSidesTrm, ok := x.MakeSides()
				if ok {
					x.NextLprn()
					cur := &RltMakeSides{Trm: makeSidesTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltSidesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpSidesTrm, ok := x.MakeEmpSides()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpSides{Trm: makeEmpSidesTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltSidesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeStmsTrm, ok := x.MakeStms()
				if ok {
					x.NextLprn()
					cur := &RltMakeStms{Trm: makeStmsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltStmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpStmsTrm, ok := x.MakeEmpStms()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpStms{Trm: makeEmpStmsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltStmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeCndsTrm, ok := x.MakeCnds()
				if ok {
					x.NextLprn()
					cur := &RltMakeCnds{Trm: makeCndsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltCndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpCndsTrm, ok := x.MakeEmpCnds()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpCnds{Trm: makeEmpCndsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltCndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeStgysTrm, ok := x.MakeStgys()
				if ok {
					x.NextLprn()
					cur := &RltMakeStgys{Trm: makeStgysTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltStgysXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpStgysTrm, ok := x.MakeEmpStgys()
				if ok {
					x.NextLprn()
					cur := &RltMakeEmpStgys{Trm: makeEmpStgysTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.RltStgysXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newPrvsTrm, ok := x.NewPrvs()
				if ok {
					x.NextLprn()
					var i0 []RltPrvXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltPrvXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewPrvs: non RltPrvXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewPrvs{Trm: newPrvsTrm, I0: i0}
					x.NextRprn()
					return x.RltPrvsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newInstrsTrm, ok := x.NewInstrs()
				if ok {
					x.NextLprn()
					var i0 []RltInstrXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltInstrXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewInstrs: non RltInstrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewInstrs{Trm: newInstrsTrm, I0: i0}
					x.NextRprn()
					return x.RltInstrsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newInrvlsTrm, ok := x.NewInrvls()
				if ok {
					x.NextLprn()
					var i0 []RltInrvlXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltInrvlXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewInrvls: non RltInrvlXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewInrvls{Trm: newInrvlsTrm, I0: i0}
					x.NextRprn()
					return x.RltInrvlsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newSidesTrm, ok := x.NewSides()
				if ok {
					x.NextLprn()
					var i0 []RltSideXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltSideXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewSides: non RltSideXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewSides{Trm: newSidesTrm, I0: i0}
					x.NextRprn()
					return x.RltSidesXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newStmsTrm, ok := x.NewStms()
				if ok {
					x.NextLprn()
					var i0 []RltStmXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltStmXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewStms: non RltStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewStms{Trm: newStmsTrm, I0: i0}
					x.NextRprn()
					return x.RltStmsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newCndsTrm, ok := x.NewCnds()
				if ok {
					x.NextLprn()
					var i0 []RltCndXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltCndXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewCnds: non RltCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewCnds{Trm: newCndsTrm, I0: i0}
					x.NextRprn()
					return x.RltCndsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newStgysTrm, ok := x.NewStgys()
				if ok {
					x.NextLprn()
					var i0 []RltStgyXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(RltStgyXpr)
						if !ok {
							x.Panicf("RltPkgXpr: NewStgys: non RltStgyXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &RltNewStgys{Trm: newStgysTrm, I0: i0}
					x.NextRprn()
					return x.RltStgysXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'o':
				oanTrm, ok := x.Oan()
				if ok {
					x.NextLprn()
					cur := &RltOan{Trm: oanTrm}
					x.NextRprn()
					return x.RltPrvXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("RltPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) RltPrvXpr(scp *Scp, X RltPrvXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltPrv)
				return x.RltPrvXpr(scp, &RltPrvAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			audUsdTrm, ok := x.AudUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("RltPrvXpr: AudUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvAudUsd{Trm: audUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eurUsdTrm, ok := x.EurUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("RltPrvXpr: EurUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvEurUsd{Trm: eurUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gbpUsdTrm, ok := x.GbpUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("RltPrvXpr: GbpUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvGbpUsd{Trm: gbpUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mayTrdTrm, ok := x.MayTrd()
			if ok {
				x.NextLprn()
				cur := &RltPrvMayTrd{Trm: mayTrdTrm, X: X}
				x.NextRprn()
				return x.BolBolXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'n':
			nzdUsdTrm, ok := x.NzdUsd()
			if ok {
				x.NextLprn()
				var i0 []TmeRngXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeRngXpr)
					if !ok {
						x.Panicf("RltPrvXpr: NzdUsd: non TmeRngXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvNzdUsd{Trm: nzdUsdTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltPrvXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltInstrXpr(scp *Scp, X RltInstrXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInstr)
				return x.RltInstrXpr(scp, &RltInstrAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'i':
			iTrm, ok := x.I()
			if ok {
				x.NextLprn()
				cur := &RltInstrI{Trm: iTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltInstrXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltInrvlXpr(scp *Scp, X RltInrvlXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInrvl)
				return x.RltInrvlXpr(scp, &RltInrvlAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			askTrm, ok := x.Ask()
			if ok {
				x.NextLprn()
				cur := &RltInrvlAsk{Trm: askTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'b':
			bidTrm, ok := x.Bid()
			if ok {
				x.NextLprn()
				cur := &RltInrvlBid{Trm: bidTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltInrvlXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltSideXpr(scp *Scp, X RltSideXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltSide)
				return x.RltSideXpr(scp, &RltSideAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			almaTrm, ok := x.Alma()
			if ok {
				x.NextLprn()
				cur := &RltSideAlma{Trm: almaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			emaTrm, ok := x.Ema()
			if ok {
				x.NextLprn()
				cur := &RltSideEma{Trm: emaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'f':
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltSideFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'g':
			gmaTrm, ok := x.Gma()
			if ok {
				x.NextLprn()
				cur := &RltSideGma{Trm: gmaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltSideLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				cur := &RltSideMin{Trm: minTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				cur := &RltSideMax{Trm: maxTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			midTrm, ok := x.Mid()
			if ok {
				x.NextLprn()
				cur := &RltSideMid{Trm: midTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdnTrm, ok := x.Mdn()
			if ok {
				x.NextLprn()
				cur := &RltSideMdn{Trm: mdnTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			prdTrm, ok := x.Prd()
			if ok {
				x.NextLprn()
				cur := &RltSidePrd{Trm: prdTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proLstTrm, ok := x.ProLst()
			if ok {
				x.NextLprn()
				cur := &RltSideProLst{Trm: proLstTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proSmaTrm, ok := x.ProSma()
			if ok {
				x.NextLprn()
				cur := &RltSideProSma{Trm: proSmaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			proAlmaTrm, ok := x.ProAlma()
			if ok {
				x.NextLprn()
				cur := &RltSideProAlma{Trm: proAlmaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			rsiTrm, ok := x.Rsi()
			if ok {
				x.NextLprn()
				cur := &RltSideRsi{Trm: rsiTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngFulTrm, ok := x.RngFul()
			if ok {
				x.NextLprn()
				cur := &RltSideRngFul{Trm: rngFulTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			rngLstTrm, ok := x.RngLst()
			if ok {
				x.NextLprn()
				cur := &RltSideRngLst{Trm: rngLstTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			sumTrm, ok := x.Sum()
			if ok {
				x.NextLprn()
				cur := &RltSideSum{Trm: sumTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			smaTrm, ok := x.Sma()
			if ok {
				x.NextLprn()
				cur := &RltSideSma{Trm: smaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stdTrm, ok := x.Std()
			if ok {
				x.NextLprn()
				cur := &RltSideStd{Trm: stdTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sarTrm, ok := x.Sar()
			if ok {
				x.NextLprn()
				cur := &RltSideSar{Trm: sarTrm, X: X, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrncTrm, ok := x.Vrnc()
			if ok {
				x.NextLprn()
				cur := &RltSideVrnc{Trm: vrncTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			wmaTrm, ok := x.Wma()
			if ok {
				x.NextLprn()
				cur := &RltSideWma{Trm: wmaTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			wrsiTrm, ok := x.Wrsi()
			if ok {
				x.NextLprn()
				cur := &RltSideWrsi{Trm: wrsiTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltSideXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltStmXpr(scp *Scp, X RltStmXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStm)
				return x.RltStmXpr(scp, &RltStmAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			aggFstTrm, ok := x.AggFst()
			if ok {
				x.NextLprn()
				cur := &RltStmAggFst{Trm: aggFstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggLstTrm, ok := x.AggLst()
			if ok {
				x.NextLprn()
				cur := &RltStmAggLst{Trm: aggLstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggSumTrm, ok := x.AggSum()
			if ok {
				x.NextLprn()
				cur := &RltStmAggSum{Trm: aggSumTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggPrdTrm, ok := x.AggPrd()
			if ok {
				x.NextLprn()
				cur := &RltStmAggPrd{Trm: aggPrdTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMinTrm, ok := x.AggMin()
			if ok {
				x.NextLprn()
				cur := &RltStmAggMin{Trm: aggMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMaxTrm, ok := x.AggMax()
			if ok {
				x.NextLprn()
				cur := &RltStmAggMax{Trm: aggMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMidTrm, ok := x.AggMid()
			if ok {
				x.NextLprn()
				cur := &RltStmAggMid{Trm: aggMidTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggMdnTrm, ok := x.AggMdn()
			if ok {
				x.NextLprn()
				cur := &RltStmAggMdn{Trm: aggMdnTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggSmaTrm, ok := x.AggSma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggSma{Trm: aggSmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggGmaTrm, ok := x.AggGma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggGma{Trm: aggGmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggWmaTrm, ok := x.AggWma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggWma{Trm: aggWmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggRsiTrm, ok := x.AggRsi()
			if ok {
				x.NextLprn()
				cur := &RltStmAggRsi{Trm: aggRsiTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggWrsiTrm, ok := x.AggWrsi()
			if ok {
				x.NextLprn()
				cur := &RltStmAggWrsi{Trm: aggWrsiTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggAlmaTrm, ok := x.AggAlma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggAlma{Trm: aggAlmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggVrncTrm, ok := x.AggVrnc()
			if ok {
				x.NextLprn()
				cur := &RltStmAggVrnc{Trm: aggVrncTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggStdTrm, ok := x.AggStd()
			if ok {
				x.NextLprn()
				cur := &RltStmAggStd{Trm: aggStdTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggRngFulTrm, ok := x.AggRngFul()
			if ok {
				x.NextLprn()
				cur := &RltStmAggRngFul{Trm: aggRngFulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggRngLstTrm, ok := x.AggRngLst()
			if ok {
				x.NextLprn()
				cur := &RltStmAggRngLst{Trm: aggRngLstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggProLstTrm, ok := x.AggProLst()
			if ok {
				x.NextLprn()
				cur := &RltStmAggProLst{Trm: aggProLstTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggProSmaTrm, ok := x.AggProSma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggProSma{Trm: aggProSmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggProAlmaTrm, ok := x.AggProAlma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggProAlma{Trm: aggProAlmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			aggEmaTrm, ok := x.AggEma()
			if ok {
				x.NextLprn()
				cur := &RltStmAggEma{Trm: aggEmaTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			inrAddTrm, ok := x.InrAdd()
			if ok {
				x.NextLprn()
				cur := &RltStmInrAdd{Trm: inrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSubTrm, ok := x.InrSub()
			if ok {
				x.NextLprn()
				cur := &RltStmInrSub{Trm: inrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMulTrm, ok := x.InrMul()
			if ok {
				x.NextLprn()
				cur := &RltStmInrMul{Trm: inrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrDivTrm, ok := x.InrDiv()
			if ok {
				x.NextLprn()
				cur := &RltStmInrDiv{Trm: inrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrRemTrm, ok := x.InrRem()
			if ok {
				x.NextLprn()
				cur := &RltStmInrRem{Trm: inrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrPowTrm, ok := x.InrPow()
			if ok {
				x.NextLprn()
				cur := &RltStmInrPow{Trm: inrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMinTrm, ok := x.InrMin()
			if ok {
				x.NextLprn()
				cur := &RltStmInrMin{Trm: inrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrMaxTrm, ok := x.InrMax()
			if ok {
				x.NextLprn()
				cur := &RltStmInrMax{Trm: inrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrSlpTrm, ok := x.InrSlp()
			if ok {
				x.NextLprn()
				cur := &RltStmInrSlp{Trm: inrSlpTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrEqlTrm, ok := x.InrEql()
			if ok {
				x.NextLprn()
				cur := &RltStmInrEql{Trm: inrEqlTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrNeqTrm, ok := x.InrNeq()
			if ok {
				x.NextLprn()
				cur := &RltStmInrNeq{Trm: inrNeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrLssTrm, ok := x.InrLss()
			if ok {
				x.NextLprn()
				cur := &RltStmInrLss{Trm: inrLssTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrGtrTrm, ok := x.InrGtr()
			if ok {
				x.NextLprn()
				cur := &RltStmInrGtr{Trm: inrGtrTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrLeqTrm, ok := x.InrLeq()
			if ok {
				x.NextLprn()
				cur := &RltStmInrLeq{Trm: inrLeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inrGeqTrm, ok := x.InrGeq()
			if ok {
				x.NextLprn()
				cur := &RltStmInrGeq{Trm: inrGeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			otrAddTrm, ok := x.OtrAdd()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrAdd{Trm: otrAddTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrSubTrm, ok := x.OtrSub()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrSub{Trm: otrSubTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrMulTrm, ok := x.OtrMul()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrMul{Trm: otrMulTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrDivTrm, ok := x.OtrDiv()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrDiv{Trm: otrDivTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrRemTrm, ok := x.OtrRem()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrRem{Trm: otrRemTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrPowTrm, ok := x.OtrPow()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrPow{Trm: otrPowTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrMinTrm, ok := x.OtrMin()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrMin{Trm: otrMinTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrMaxTrm, ok := x.OtrMax()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrMax{Trm: otrMaxTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrEqlTrm, ok := x.OtrEql()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrEql{Trm: otrEqlTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrNeqTrm, ok := x.OtrNeq()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrNeq{Trm: otrNeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrLssTrm, ok := x.OtrLss()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrLss{Trm: otrLssTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrGtrTrm, ok := x.OtrGtr()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrGtr{Trm: otrGtrTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrLeqTrm, ok := x.OtrLeq()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrLeq{Trm: otrLeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			otrGeqTrm, ok := x.OtrGeq()
			if ok {
				x.NextLprn()
				cur := &RltStmOtrGeq{Trm: otrGeqTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			sclAddTrm, ok := x.SclAdd()
			if ok {
				x.NextLprn()
				cur := &RltStmSclAdd{Trm: sclAddTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclSubTrm, ok := x.SclSub()
			if ok {
				x.NextLprn()
				cur := &RltStmSclSub{Trm: sclSubTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMulTrm, ok := x.SclMul()
			if ok {
				x.NextLprn()
				cur := &RltStmSclMul{Trm: sclMulTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclDivTrm, ok := x.SclDiv()
			if ok {
				x.NextLprn()
				cur := &RltStmSclDiv{Trm: sclDivTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclRemTrm, ok := x.SclRem()
			if ok {
				x.NextLprn()
				cur := &RltStmSclRem{Trm: sclRemTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclPowTrm, ok := x.SclPow()
			if ok {
				x.NextLprn()
				cur := &RltStmSclPow{Trm: sclPowTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMinTrm, ok := x.SclMin()
			if ok {
				x.NextLprn()
				cur := &RltStmSclMin{Trm: sclMinTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclMaxTrm, ok := x.SclMax()
			if ok {
				x.NextLprn()
				cur := &RltStmSclMax{Trm: sclMaxTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selEqlTrm, ok := x.SelEql()
			if ok {
				x.NextLprn()
				cur := &RltStmSelEql{Trm: selEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selNeqTrm, ok := x.SelNeq()
			if ok {
				x.NextLprn()
				cur := &RltStmSelNeq{Trm: selNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLssTrm, ok := x.SelLss()
			if ok {
				x.NextLprn()
				cur := &RltStmSelLss{Trm: selLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGtrTrm, ok := x.SelGtr()
			if ok {
				x.NextLprn()
				cur := &RltStmSelGtr{Trm: selGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selLeqTrm, ok := x.SelLeq()
			if ok {
				x.NextLprn()
				cur := &RltStmSelLeq{Trm: selLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			selGeqTrm, ok := x.SelGeq()
			if ok {
				x.NextLprn()
				cur := &RltStmSelGeq{Trm: selGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclEqlTrm, ok := x.SclEql()
			if ok {
				x.NextLprn()
				cur := &RltStmSclEql{Trm: sclEqlTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclNeqTrm, ok := x.SclNeq()
			if ok {
				x.NextLprn()
				cur := &RltStmSclNeq{Trm: sclNeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclLssTrm, ok := x.SclLss()
			if ok {
				x.NextLprn()
				cur := &RltStmSclLss{Trm: sclLssTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclGtrTrm, ok := x.SclGtr()
			if ok {
				x.NextLprn()
				cur := &RltStmSclGtr{Trm: sclGtrTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclLeqTrm, ok := x.SclLeq()
			if ok {
				x.NextLprn()
				cur := &RltStmSclLeq{Trm: sclLeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclGeqTrm, ok := x.SclGeq()
			if ok {
				x.NextLprn()
				cur := &RltStmSclGeq{Trm: sclGeqTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			unaPosTrm, ok := x.UnaPos()
			if ok {
				x.NextLprn()
				cur := &RltStmUnaPos{Trm: unaPosTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaNegTrm, ok := x.UnaNeg()
			if ok {
				x.NextLprn()
				cur := &RltStmUnaNeg{Trm: unaNegTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaInvTrm, ok := x.UnaInv()
			if ok {
				x.NextLprn()
				cur := &RltStmUnaInv{Trm: unaInvTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaSqrTrm, ok := x.UnaSqr()
			if ok {
				x.NextLprn()
				cur := &RltStmUnaSqr{Trm: unaSqrTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			unaSqrtTrm, ok := x.UnaSqrt()
			if ok {
				x.NextLprn()
				cur := &RltStmUnaSqrt{Trm: unaSqrtTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltStmXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltCndXpr(scp *Scp, X RltCndXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltCnd)
				return x.RltCndXpr(scp, &RltCndAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			andTrm, ok := x.And()
			if ok {
				x.NextLprn()
				cur := &RltCndAnd{Trm: andTrm, X: X, I0: x.Xpr(scp).(RltCndXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			seqTrm, ok := x.Seq()
			if ok {
				x.NextLprn()
				cur := &RltCndSeq{Trm: seqTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr), I1: x.Xpr(scp).(RltCndXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stgyTrm, ok := x.Stgy()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(BolBolXpr)
				i1 := x.Xpr(scp).(FltFltXpr)
				i2 := x.Xpr(scp).(FltFltXpr)
				i3 := x.Xpr(scp).(TmeTmeXpr)
				i4 := x.Xpr(scp).(FltFltXpr)
				i5 := x.Xpr(scp).(RltInstrXpr)
				i6 := x.Xpr(scp).(RltStmsXpr)
				var i7 []RltCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltCndXpr)
					if !ok {
						x.Panicf("RltCndXpr: Stgy: non RltCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i7 = append(i7, v)
				}
				cur := &RltCndStgy{Trm: stgyTrm, X: X, I0: i0, I1: i1, I2: i2, I3: i3, I4: i4, I5: i5, I6: i6, I7: i7}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltCndXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltStgyXpr(scp *Scp, X RltStgyXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStgy)
				return x.RltStgyXpr(scp, &RltStgyAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		}
		x.Panicf("RltStgyXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltPrvsXpr(scp *Scp, X RltPrvsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltPrvs)
				return x.RltPrvsXpr(scp, &RltPrvsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltPrvsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltPrvsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltPrvsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltPrvsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltPrvsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltPrvsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltPrv)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltPrvsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltPrvsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltPrvsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltPrvsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltPrvsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltPrvXpr)}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltPrvsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltPrvsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltPrvsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltPrvsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltPrvsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltPrvsXpr)
					if !ok {
						x.Panicf("RltPrvsXpr: Mrg: non RltPrvsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltPrvsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltPrvsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltPrv)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltPrvsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltPrvXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltPrvXpr)
					if !ok {
						x.Panicf("RltPrvsXpr: Push: non RltPrvXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltPrvsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltPrvXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltPrvXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltPrvXpr)
					if !ok {
						x.Panicf("RltPrvsXpr: Que: non RltPrvXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltPrvsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltPrvsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltPrvsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltPrvsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltPrvsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltPrvXpr)}
				x.NextRprn()
				return x.RltPrvsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltPrvsXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltInstrsXpr(scp *Scp, X RltInstrsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInstrs)
				return x.RltInstrsXpr(scp, &RltInstrsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltInstrsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltInstrsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltInstrsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltInstrsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltInstrsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltInstrsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInstr)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltInstrsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltInstrsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltInstrsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltInstrsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltInstrsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltInstrXpr)}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltInstrsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltInstrsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltInstrsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltInstrsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltInstrsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltInstrsXpr)
					if !ok {
						x.Panicf("RltInstrsXpr: Mrg: non RltInstrsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltInstrsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltInstrsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltInstrsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInstr)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltInstrsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltInstrXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltInstrXpr)
					if !ok {
						x.Panicf("RltInstrsXpr: Push: non RltInstrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltInstrsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltInstrsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltInstrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltInstrXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltInstrXpr)
					if !ok {
						x.Panicf("RltInstrsXpr: Que: non RltInstrXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltInstrsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltInstrsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltInstrsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltInstrsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltInstrsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltInstrXpr)}
				x.NextRprn()
				return x.RltInstrsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltInstrsXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltInrvlsXpr(scp *Scp, X RltInrvlsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInrvls)
				return x.RltInrvlsXpr(scp, &RltInrvlsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInrvl)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltInrvlsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltInrvlXpr)}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltInrvlsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltInrvlsXpr)
					if !ok {
						x.Panicf("RltInrvlsXpr: Mrg: non RltInrvlsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltInrvlsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltInrvl)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltInrvlsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltInrvlXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltInrvlXpr)
					if !ok {
						x.Panicf("RltInrvlsXpr: Push: non RltInrvlXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltInrvlsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltInrvlXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltInrvlXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltInrvlXpr)
					if !ok {
						x.Panicf("RltInrvlsXpr: Que: non RltInrvlXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltInrvlsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltInrvlsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltInrvlXpr)}
				x.NextRprn()
				return x.RltInrvlsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltInrvlsXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltSidesXpr(scp *Scp, X RltSidesXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltSides)
				return x.RltSidesXpr(scp, &RltSidesAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltSidesAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltSidesCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltSidesCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltSidesClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltSidesDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltSidesDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltSide)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltSidesEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltSidesFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltSidesFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltSidesFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltSidesIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltSideXpr)}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltSidesIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltSidesInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltSidesLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltSidesLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltSidesXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltSidesXpr)
					if !ok {
						x.Panicf("RltSidesXpr: Mrg: non RltSidesXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltSidesMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltSidesMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltSidesMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltSide)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltSidesPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltSideXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltSideXpr)
					if !ok {
						x.Panicf("RltSidesXpr: Push: non RltSideXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltSidesPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltSidesPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltSideXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltSideXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltSideXpr)
					if !ok {
						x.Panicf("RltSidesXpr: Que: non RltSideXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltSidesQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltSidesRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltSidesRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltSidesTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltSidesUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltSideXpr)}
				x.NextRprn()
				return x.RltSidesXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltSidesXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltStmsXpr(scp *Scp, X RltStmsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStms)
				return x.RltStmsXpr(scp, &RltStmsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltStmsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltStmsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltStmsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltStmsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltStmsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltStmsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStm)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltStmsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltStmsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltStmsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltStmsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltStmsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltStmsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltStmsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltStmsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltStmsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltStmsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltStmsXpr)
					if !ok {
						x.Panicf("RltStmsXpr: Mrg: non RltStmsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltStmsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltStmsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltStmsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStm)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltStmsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltStmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltStmXpr)
					if !ok {
						x.Panicf("RltStmsXpr: Push: non RltStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltStmsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltStmsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltStmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltStmXpr)
					if !ok {
						x.Panicf("RltStmsXpr: Que: non RltStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltStmsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltStmsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltStmsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltStmsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltStmsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStmXpr)}
				x.NextRprn()
				return x.RltStmsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltStmsXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltCndsXpr(scp *Scp, X RltCndsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltCnds)
				return x.RltCndsXpr(scp, &RltCndsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltCndsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltCndsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltCndsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltCndsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltCndsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltCndsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltCnd)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltCndsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltCndsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltCndsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltCndsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltCndsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltCndXpr)}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltCndsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltCndsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltCndsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltCndsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltCndsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltCndsXpr)
					if !ok {
						x.Panicf("RltCndsXpr: Mrg: non RltCndsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltCndsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltCndsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltCndsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltCnd)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltCndsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltCndXpr)
					if !ok {
						x.Panicf("RltCndsXpr: Push: non RltCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltCndsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltCndsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltCndXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltCndXpr)
					if !ok {
						x.Panicf("RltCndsXpr: Que: non RltCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltCndsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltCndsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltCndsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltCndsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltCndsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltCndXpr)}
				x.NextRprn()
				return x.RltCndsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltCndsXpr: no expression found")
	}
	return X
}
func (x *Xprr) RltStgysXpr(scp *Scp, X RltStgysXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Rlt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Rlt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStgys)
				return x.RltStgysXpr(scp, &RltStgysAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &RltStgysAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &RltStgysCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &RltStgysCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &RltStgysClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &RltStgysDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &RltStgysDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStgy)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltStgysEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &RltStgysFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &RltStgysFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &RltStgysFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &RltStgysIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStgyXpr)}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &RltStgysIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &RltStgysInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &RltStgysLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &RltStgysLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []RltStgysXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltStgysXpr)
					if !ok {
						x.Panicf("RltStgysXpr: Mrg: non RltStgysXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltStgysMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &RltStgysMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &RltStgysMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Rlt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.RltStgy)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &RltStgysPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []RltStgyXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltStgyXpr)
					if !ok {
						x.Panicf("RltStgysXpr: Push: non RltStgyXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltStgysPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &RltStgysPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.RltStgyXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []RltStgyXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(RltStgyXpr)
					if !ok {
						x.Panicf("RltStgysXpr: Que: non RltStgyXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &RltStgysQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &RltStgysRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &RltStgysRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &RltStgysTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &RltStgysUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(RltStgyXpr)}
				x.NextRprn()
				return x.RltStgysXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("RltStgysXpr: no expression found")
	}
	return X
}
func (x *Xprr) FntPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Fnt()
	if ok {
		x.Panicf("FntPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) FntFntXpr(scp *Scp, X FntFntXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Fnt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Fnt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Fnt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.FntFnt)
				return x.FntFntXpr(scp, &FntFntAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		}
		x.Panicf("FntFntXpr: no expression found")
	}
	return X
}
func (x *Xprr) ClrPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Clr()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'a':
				amber50Trm, ok := x.Amber50()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber50{Trm: amber50Trm}), true
				}
				x.Scn = scn // rewind
				amber100Trm, ok := x.Amber100()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber100{Trm: amber100Trm}), true
				}
				x.Scn = scn // rewind
				amber200Trm, ok := x.Amber200()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber200{Trm: amber200Trm}), true
				}
				x.Scn = scn // rewind
				amber300Trm, ok := x.Amber300()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber300{Trm: amber300Trm}), true
				}
				x.Scn = scn // rewind
				amber400Trm, ok := x.Amber400()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber400{Trm: amber400Trm}), true
				}
				x.Scn = scn // rewind
				amber500Trm, ok := x.Amber500()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber500{Trm: amber500Trm}), true
				}
				x.Scn = scn // rewind
				amber600Trm, ok := x.Amber600()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber600{Trm: amber600Trm}), true
				}
				x.Scn = scn // rewind
				amber700Trm, ok := x.Amber700()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber700{Trm: amber700Trm}), true
				}
				x.Scn = scn // rewind
				amber800Trm, ok := x.Amber800()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber800{Trm: amber800Trm}), true
				}
				x.Scn = scn // rewind
				amber900Trm, ok := x.Amber900()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmber900{Trm: amber900Trm}), true
				}
				x.Scn = scn // rewind
				amberA100Trm, ok := x.AmberA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmberA100{Trm: amberA100Trm}), true
				}
				x.Scn = scn // rewind
				amberA200Trm, ok := x.AmberA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmberA200{Trm: amberA200Trm}), true
				}
				x.Scn = scn // rewind
				amberA400Trm, ok := x.AmberA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmberA400{Trm: amberA400Trm}), true
				}
				x.Scn = scn // rewind
				amberA700Trm, ok := x.AmberA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrAmberA700{Trm: amberA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'b':
				blackTrm, ok := x.Black()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlack{Trm: blackTrm}), true
				}
				x.Scn = scn // rewind
				blue50Trm, ok := x.Blue50()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue50{Trm: blue50Trm}), true
				}
				x.Scn = scn // rewind
				blue100Trm, ok := x.Blue100()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue100{Trm: blue100Trm}), true
				}
				x.Scn = scn // rewind
				blue200Trm, ok := x.Blue200()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue200{Trm: blue200Trm}), true
				}
				x.Scn = scn // rewind
				blue300Trm, ok := x.Blue300()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue300{Trm: blue300Trm}), true
				}
				x.Scn = scn // rewind
				blue400Trm, ok := x.Blue400()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue400{Trm: blue400Trm}), true
				}
				x.Scn = scn // rewind
				blue500Trm, ok := x.Blue500()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue500{Trm: blue500Trm}), true
				}
				x.Scn = scn // rewind
				blue600Trm, ok := x.Blue600()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue600{Trm: blue600Trm}), true
				}
				x.Scn = scn // rewind
				blue700Trm, ok := x.Blue700()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue700{Trm: blue700Trm}), true
				}
				x.Scn = scn // rewind
				blue800Trm, ok := x.Blue800()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue800{Trm: blue800Trm}), true
				}
				x.Scn = scn // rewind
				blue900Trm, ok := x.Blue900()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlue900{Trm: blue900Trm}), true
				}
				x.Scn = scn // rewind
				blueA100Trm, ok := x.BlueA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueA100{Trm: blueA100Trm}), true
				}
				x.Scn = scn // rewind
				blueA200Trm, ok := x.BlueA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueA200{Trm: blueA200Trm}), true
				}
				x.Scn = scn // rewind
				blueA400Trm, ok := x.BlueA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueA400{Trm: blueA400Trm}), true
				}
				x.Scn = scn // rewind
				blueA700Trm, ok := x.BlueA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueA700{Trm: blueA700Trm}), true
				}
				x.Scn = scn // rewind
				brown50Trm, ok := x.Brown50()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown50{Trm: brown50Trm}), true
				}
				x.Scn = scn // rewind
				brown100Trm, ok := x.Brown100()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown100{Trm: brown100Trm}), true
				}
				x.Scn = scn // rewind
				brown200Trm, ok := x.Brown200()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown200{Trm: brown200Trm}), true
				}
				x.Scn = scn // rewind
				brown300Trm, ok := x.Brown300()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown300{Trm: brown300Trm}), true
				}
				x.Scn = scn // rewind
				brown400Trm, ok := x.Brown400()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown400{Trm: brown400Trm}), true
				}
				x.Scn = scn // rewind
				brown500Trm, ok := x.Brown500()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown500{Trm: brown500Trm}), true
				}
				x.Scn = scn // rewind
				brown600Trm, ok := x.Brown600()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown600{Trm: brown600Trm}), true
				}
				x.Scn = scn // rewind
				brown700Trm, ok := x.Brown700()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown700{Trm: brown700Trm}), true
				}
				x.Scn = scn // rewind
				brown800Trm, ok := x.Brown800()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown800{Trm: brown800Trm}), true
				}
				x.Scn = scn // rewind
				brown900Trm, ok := x.Brown900()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrown900{Trm: brown900Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey50Trm, ok := x.BlueGrey50()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey50{Trm: blueGrey50Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey100Trm, ok := x.BlueGrey100()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey100{Trm: blueGrey100Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey200Trm, ok := x.BlueGrey200()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey200{Trm: blueGrey200Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey300Trm, ok := x.BlueGrey300()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey300{Trm: blueGrey300Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey400Trm, ok := x.BlueGrey400()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey400{Trm: blueGrey400Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey500Trm, ok := x.BlueGrey500()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey500{Trm: blueGrey500Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey600Trm, ok := x.BlueGrey600()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey600{Trm: blueGrey600Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey700Trm, ok := x.BlueGrey700()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey700{Trm: blueGrey700Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey800Trm, ok := x.BlueGrey800()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey800{Trm: blueGrey800Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey900Trm, ok := x.BlueGrey900()
				if ok {
					return x.ClrClrXpr(scp, &ClrBlueGrey900{Trm: blueGrey900Trm}), true
				}
				x.Scn = scn // rewind
			case 'c':
				cyan50Trm, ok := x.Cyan50()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan50{Trm: cyan50Trm}), true
				}
				x.Scn = scn // rewind
				cyan100Trm, ok := x.Cyan100()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan100{Trm: cyan100Trm}), true
				}
				x.Scn = scn // rewind
				cyan200Trm, ok := x.Cyan200()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan200{Trm: cyan200Trm}), true
				}
				x.Scn = scn // rewind
				cyan300Trm, ok := x.Cyan300()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan300{Trm: cyan300Trm}), true
				}
				x.Scn = scn // rewind
				cyan400Trm, ok := x.Cyan400()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan400{Trm: cyan400Trm}), true
				}
				x.Scn = scn // rewind
				cyan500Trm, ok := x.Cyan500()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan500{Trm: cyan500Trm}), true
				}
				x.Scn = scn // rewind
				cyan600Trm, ok := x.Cyan600()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan600{Trm: cyan600Trm}), true
				}
				x.Scn = scn // rewind
				cyan700Trm, ok := x.Cyan700()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan700{Trm: cyan700Trm}), true
				}
				x.Scn = scn // rewind
				cyan800Trm, ok := x.Cyan800()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan800{Trm: cyan800Trm}), true
				}
				x.Scn = scn // rewind
				cyan900Trm, ok := x.Cyan900()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyan900{Trm: cyan900Trm}), true
				}
				x.Scn = scn // rewind
				cyanA100Trm, ok := x.CyanA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyanA100{Trm: cyanA100Trm}), true
				}
				x.Scn = scn // rewind
				cyanA200Trm, ok := x.CyanA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyanA200{Trm: cyanA200Trm}), true
				}
				x.Scn = scn // rewind
				cyanA400Trm, ok := x.CyanA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyanA400{Trm: cyanA400Trm}), true
				}
				x.Scn = scn // rewind
				cyanA700Trm, ok := x.CyanA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrCyanA700{Trm: cyanA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'd':
				deepPurple50Trm, ok := x.DeepPurple50()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple50{Trm: deepPurple50Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple100Trm, ok := x.DeepPurple100()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple100{Trm: deepPurple100Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple200Trm, ok := x.DeepPurple200()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple200{Trm: deepPurple200Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple300Trm, ok := x.DeepPurple300()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple300{Trm: deepPurple300Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple400Trm, ok := x.DeepPurple400()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple400{Trm: deepPurple400Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple500Trm, ok := x.DeepPurple500()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple500{Trm: deepPurple500Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple600Trm, ok := x.DeepPurple600()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple600{Trm: deepPurple600Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple700Trm, ok := x.DeepPurple700()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple700{Trm: deepPurple700Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple800Trm, ok := x.DeepPurple800()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple800{Trm: deepPurple800Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple900Trm, ok := x.DeepPurple900()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurple900{Trm: deepPurple900Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA100Trm, ok := x.DeepPurpleA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurpleA100{Trm: deepPurpleA100Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA200Trm, ok := x.DeepPurpleA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurpleA200{Trm: deepPurpleA200Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA400Trm, ok := x.DeepPurpleA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurpleA400{Trm: deepPurpleA400Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA700Trm, ok := x.DeepPurpleA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepPurpleA700{Trm: deepPurpleA700Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange50Trm, ok := x.DeepOrange50()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange50{Trm: deepOrange50Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange100Trm, ok := x.DeepOrange100()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange100{Trm: deepOrange100Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange200Trm, ok := x.DeepOrange200()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange200{Trm: deepOrange200Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange300Trm, ok := x.DeepOrange300()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange300{Trm: deepOrange300Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange400Trm, ok := x.DeepOrange400()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange400{Trm: deepOrange400Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange500Trm, ok := x.DeepOrange500()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange500{Trm: deepOrange500Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange600Trm, ok := x.DeepOrange600()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange600{Trm: deepOrange600Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange700Trm, ok := x.DeepOrange700()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange700{Trm: deepOrange700Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange800Trm, ok := x.DeepOrange800()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange800{Trm: deepOrange800Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange900Trm, ok := x.DeepOrange900()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrange900{Trm: deepOrange900Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA100Trm, ok := x.DeepOrangeA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrangeA100{Trm: deepOrangeA100Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA200Trm, ok := x.DeepOrangeA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrangeA200{Trm: deepOrangeA200Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA400Trm, ok := x.DeepOrangeA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrangeA400{Trm: deepOrangeA400Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA700Trm, ok := x.DeepOrangeA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrDeepOrangeA700{Trm: deepOrangeA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'g':
				green50Trm, ok := x.Green50()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen50{Trm: green50Trm}), true
				}
				x.Scn = scn // rewind
				green100Trm, ok := x.Green100()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen100{Trm: green100Trm}), true
				}
				x.Scn = scn // rewind
				green200Trm, ok := x.Green200()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen200{Trm: green200Trm}), true
				}
				x.Scn = scn // rewind
				green300Trm, ok := x.Green300()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen300{Trm: green300Trm}), true
				}
				x.Scn = scn // rewind
				green400Trm, ok := x.Green400()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen400{Trm: green400Trm}), true
				}
				x.Scn = scn // rewind
				green500Trm, ok := x.Green500()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen500{Trm: green500Trm}), true
				}
				x.Scn = scn // rewind
				green600Trm, ok := x.Green600()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen600{Trm: green600Trm}), true
				}
				x.Scn = scn // rewind
				green700Trm, ok := x.Green700()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen700{Trm: green700Trm}), true
				}
				x.Scn = scn // rewind
				green800Trm, ok := x.Green800()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen800{Trm: green800Trm}), true
				}
				x.Scn = scn // rewind
				green900Trm, ok := x.Green900()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreen900{Trm: green900Trm}), true
				}
				x.Scn = scn // rewind
				greenA100Trm, ok := x.GreenA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreenA100{Trm: greenA100Trm}), true
				}
				x.Scn = scn // rewind
				greenA200Trm, ok := x.GreenA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreenA200{Trm: greenA200Trm}), true
				}
				x.Scn = scn // rewind
				greenA400Trm, ok := x.GreenA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreenA400{Trm: greenA400Trm}), true
				}
				x.Scn = scn // rewind
				greenA700Trm, ok := x.GreenA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrGreenA700{Trm: greenA700Trm}), true
				}
				x.Scn = scn // rewind
				grey50Trm, ok := x.Grey50()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey50{Trm: grey50Trm}), true
				}
				x.Scn = scn // rewind
				grey100Trm, ok := x.Grey100()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey100{Trm: grey100Trm}), true
				}
				x.Scn = scn // rewind
				grey200Trm, ok := x.Grey200()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey200{Trm: grey200Trm}), true
				}
				x.Scn = scn // rewind
				grey300Trm, ok := x.Grey300()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey300{Trm: grey300Trm}), true
				}
				x.Scn = scn // rewind
				grey400Trm, ok := x.Grey400()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey400{Trm: grey400Trm}), true
				}
				x.Scn = scn // rewind
				grey500Trm, ok := x.Grey500()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey500{Trm: grey500Trm}), true
				}
				x.Scn = scn // rewind
				grey600Trm, ok := x.Grey600()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey600{Trm: grey600Trm}), true
				}
				x.Scn = scn // rewind
				grey700Trm, ok := x.Grey700()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey700{Trm: grey700Trm}), true
				}
				x.Scn = scn // rewind
				grey800Trm, ok := x.Grey800()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey800{Trm: grey800Trm}), true
				}
				x.Scn = scn // rewind
				grey900Trm, ok := x.Grey900()
				if ok {
					return x.ClrClrXpr(scp, &ClrGrey900{Trm: grey900Trm}), true
				}
				x.Scn = scn // rewind
			case 'h':
				hexTrm, ok := x.Hex()
				if ok {
					x.NextLprn()
					cur := &ClrHex{Trm: hexTrm, I0: x.Xpr(scp).(StrStrXpr)}
					x.NextRprn()
					return x.ClrClrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'i':
				indigo50Trm, ok := x.Indigo50()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo50{Trm: indigo50Trm}), true
				}
				x.Scn = scn // rewind
				indigo100Trm, ok := x.Indigo100()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo100{Trm: indigo100Trm}), true
				}
				x.Scn = scn // rewind
				indigo200Trm, ok := x.Indigo200()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo200{Trm: indigo200Trm}), true
				}
				x.Scn = scn // rewind
				indigo300Trm, ok := x.Indigo300()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo300{Trm: indigo300Trm}), true
				}
				x.Scn = scn // rewind
				indigo400Trm, ok := x.Indigo400()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo400{Trm: indigo400Trm}), true
				}
				x.Scn = scn // rewind
				indigo500Trm, ok := x.Indigo500()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo500{Trm: indigo500Trm}), true
				}
				x.Scn = scn // rewind
				indigo600Trm, ok := x.Indigo600()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo600{Trm: indigo600Trm}), true
				}
				x.Scn = scn // rewind
				indigo700Trm, ok := x.Indigo700()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo700{Trm: indigo700Trm}), true
				}
				x.Scn = scn // rewind
				indigo800Trm, ok := x.Indigo800()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo800{Trm: indigo800Trm}), true
				}
				x.Scn = scn // rewind
				indigo900Trm, ok := x.Indigo900()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigo900{Trm: indigo900Trm}), true
				}
				x.Scn = scn // rewind
				indigoA100Trm, ok := x.IndigoA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigoA100{Trm: indigoA100Trm}), true
				}
				x.Scn = scn // rewind
				indigoA200Trm, ok := x.IndigoA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigoA200{Trm: indigoA200Trm}), true
				}
				x.Scn = scn // rewind
				indigoA400Trm, ok := x.IndigoA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigoA400{Trm: indigoA400Trm}), true
				}
				x.Scn = scn // rewind
				indigoA700Trm, ok := x.IndigoA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrIndigoA700{Trm: indigoA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'l':
				lightBlue50Trm, ok := x.LightBlue50()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue50{Trm: lightBlue50Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue100Trm, ok := x.LightBlue100()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue100{Trm: lightBlue100Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue200Trm, ok := x.LightBlue200()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue200{Trm: lightBlue200Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue300Trm, ok := x.LightBlue300()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue300{Trm: lightBlue300Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue400Trm, ok := x.LightBlue400()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue400{Trm: lightBlue400Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue500Trm, ok := x.LightBlue500()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue500{Trm: lightBlue500Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue600Trm, ok := x.LightBlue600()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue600{Trm: lightBlue600Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue700Trm, ok := x.LightBlue700()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue700{Trm: lightBlue700Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue800Trm, ok := x.LightBlue800()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue800{Trm: lightBlue800Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue900Trm, ok := x.LightBlue900()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlue900{Trm: lightBlue900Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA100Trm, ok := x.LightBlueA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlueA100{Trm: lightBlueA100Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA200Trm, ok := x.LightBlueA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlueA200{Trm: lightBlueA200Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA400Trm, ok := x.LightBlueA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlueA400{Trm: lightBlueA400Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA700Trm, ok := x.LightBlueA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightBlueA700{Trm: lightBlueA700Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen50Trm, ok := x.LightGreen50()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen50{Trm: lightGreen50Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen100Trm, ok := x.LightGreen100()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen100{Trm: lightGreen100Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen200Trm, ok := x.LightGreen200()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen200{Trm: lightGreen200Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen300Trm, ok := x.LightGreen300()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen300{Trm: lightGreen300Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen400Trm, ok := x.LightGreen400()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen400{Trm: lightGreen400Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen500Trm, ok := x.LightGreen500()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen500{Trm: lightGreen500Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen600Trm, ok := x.LightGreen600()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen600{Trm: lightGreen600Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen700Trm, ok := x.LightGreen700()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen700{Trm: lightGreen700Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen800Trm, ok := x.LightGreen800()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen800{Trm: lightGreen800Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen900Trm, ok := x.LightGreen900()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreen900{Trm: lightGreen900Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA100Trm, ok := x.LightGreenA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreenA100{Trm: lightGreenA100Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA200Trm, ok := x.LightGreenA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreenA200{Trm: lightGreenA200Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA400Trm, ok := x.LightGreenA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreenA400{Trm: lightGreenA400Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA700Trm, ok := x.LightGreenA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrLightGreenA700{Trm: lightGreenA700Trm}), true
				}
				x.Scn = scn // rewind
				lime50Trm, ok := x.Lime50()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime50{Trm: lime50Trm}), true
				}
				x.Scn = scn // rewind
				lime100Trm, ok := x.Lime100()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime100{Trm: lime100Trm}), true
				}
				x.Scn = scn // rewind
				lime200Trm, ok := x.Lime200()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime200{Trm: lime200Trm}), true
				}
				x.Scn = scn // rewind
				lime300Trm, ok := x.Lime300()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime300{Trm: lime300Trm}), true
				}
				x.Scn = scn // rewind
				lime400Trm, ok := x.Lime400()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime400{Trm: lime400Trm}), true
				}
				x.Scn = scn // rewind
				lime500Trm, ok := x.Lime500()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime500{Trm: lime500Trm}), true
				}
				x.Scn = scn // rewind
				lime600Trm, ok := x.Lime600()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime600{Trm: lime600Trm}), true
				}
				x.Scn = scn // rewind
				lime700Trm, ok := x.Lime700()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime700{Trm: lime700Trm}), true
				}
				x.Scn = scn // rewind
				lime800Trm, ok := x.Lime800()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime800{Trm: lime800Trm}), true
				}
				x.Scn = scn // rewind
				lime900Trm, ok := x.Lime900()
				if ok {
					return x.ClrClrXpr(scp, &ClrLime900{Trm: lime900Trm}), true
				}
				x.Scn = scn // rewind
				limeA100Trm, ok := x.LimeA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrLimeA100{Trm: limeA100Trm}), true
				}
				x.Scn = scn // rewind
				limeA200Trm, ok := x.LimeA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrLimeA200{Trm: limeA200Trm}), true
				}
				x.Scn = scn // rewind
				limeA400Trm, ok := x.LimeA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrLimeA400{Trm: limeA400Trm}), true
				}
				x.Scn = scn // rewind
				limeA700Trm, ok := x.LimeA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrLimeA700{Trm: limeA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'o':
				orange50Trm, ok := x.Orange50()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange50{Trm: orange50Trm}), true
				}
				x.Scn = scn // rewind
				orange100Trm, ok := x.Orange100()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange100{Trm: orange100Trm}), true
				}
				x.Scn = scn // rewind
				orange200Trm, ok := x.Orange200()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange200{Trm: orange200Trm}), true
				}
				x.Scn = scn // rewind
				orange300Trm, ok := x.Orange300()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange300{Trm: orange300Trm}), true
				}
				x.Scn = scn // rewind
				orange400Trm, ok := x.Orange400()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange400{Trm: orange400Trm}), true
				}
				x.Scn = scn // rewind
				orange500Trm, ok := x.Orange500()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange500{Trm: orange500Trm}), true
				}
				x.Scn = scn // rewind
				orange600Trm, ok := x.Orange600()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange600{Trm: orange600Trm}), true
				}
				x.Scn = scn // rewind
				orange700Trm, ok := x.Orange700()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange700{Trm: orange700Trm}), true
				}
				x.Scn = scn // rewind
				orange800Trm, ok := x.Orange800()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange800{Trm: orange800Trm}), true
				}
				x.Scn = scn // rewind
				orange900Trm, ok := x.Orange900()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrange900{Trm: orange900Trm}), true
				}
				x.Scn = scn // rewind
				orangeA100Trm, ok := x.OrangeA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrangeA100{Trm: orangeA100Trm}), true
				}
				x.Scn = scn // rewind
				orangeA200Trm, ok := x.OrangeA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrangeA200{Trm: orangeA200Trm}), true
				}
				x.Scn = scn // rewind
				orangeA400Trm, ok := x.OrangeA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrangeA400{Trm: orangeA400Trm}), true
				}
				x.Scn = scn // rewind
				orangeA700Trm, ok := x.OrangeA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrOrangeA700{Trm: orangeA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'p':
				pink50Trm, ok := x.Pink50()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink50{Trm: pink50Trm}), true
				}
				x.Scn = scn // rewind
				pink100Trm, ok := x.Pink100()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink100{Trm: pink100Trm}), true
				}
				x.Scn = scn // rewind
				pink200Trm, ok := x.Pink200()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink200{Trm: pink200Trm}), true
				}
				x.Scn = scn // rewind
				pink300Trm, ok := x.Pink300()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink300{Trm: pink300Trm}), true
				}
				x.Scn = scn // rewind
				pink400Trm, ok := x.Pink400()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink400{Trm: pink400Trm}), true
				}
				x.Scn = scn // rewind
				pink500Trm, ok := x.Pink500()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink500{Trm: pink500Trm}), true
				}
				x.Scn = scn // rewind
				pink600Trm, ok := x.Pink600()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink600{Trm: pink600Trm}), true
				}
				x.Scn = scn // rewind
				pink700Trm, ok := x.Pink700()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink700{Trm: pink700Trm}), true
				}
				x.Scn = scn // rewind
				pink800Trm, ok := x.Pink800()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink800{Trm: pink800Trm}), true
				}
				x.Scn = scn // rewind
				pink900Trm, ok := x.Pink900()
				if ok {
					return x.ClrClrXpr(scp, &ClrPink900{Trm: pink900Trm}), true
				}
				x.Scn = scn // rewind
				pinkA100Trm, ok := x.PinkA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrPinkA100{Trm: pinkA100Trm}), true
				}
				x.Scn = scn // rewind
				pinkA200Trm, ok := x.PinkA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrPinkA200{Trm: pinkA200Trm}), true
				}
				x.Scn = scn // rewind
				pinkA400Trm, ok := x.PinkA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrPinkA400{Trm: pinkA400Trm}), true
				}
				x.Scn = scn // rewind
				pinkA700Trm, ok := x.PinkA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrPinkA700{Trm: pinkA700Trm}), true
				}
				x.Scn = scn // rewind
				purple50Trm, ok := x.Purple50()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple50{Trm: purple50Trm}), true
				}
				x.Scn = scn // rewind
				purple100Trm, ok := x.Purple100()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple100{Trm: purple100Trm}), true
				}
				x.Scn = scn // rewind
				purple200Trm, ok := x.Purple200()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple200{Trm: purple200Trm}), true
				}
				x.Scn = scn // rewind
				purple300Trm, ok := x.Purple300()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple300{Trm: purple300Trm}), true
				}
				x.Scn = scn // rewind
				purple400Trm, ok := x.Purple400()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple400{Trm: purple400Trm}), true
				}
				x.Scn = scn // rewind
				purple500Trm, ok := x.Purple500()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple500{Trm: purple500Trm}), true
				}
				x.Scn = scn // rewind
				purple600Trm, ok := x.Purple600()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple600{Trm: purple600Trm}), true
				}
				x.Scn = scn // rewind
				purple700Trm, ok := x.Purple700()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple700{Trm: purple700Trm}), true
				}
				x.Scn = scn // rewind
				purple800Trm, ok := x.Purple800()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple800{Trm: purple800Trm}), true
				}
				x.Scn = scn // rewind
				purple900Trm, ok := x.Purple900()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurple900{Trm: purple900Trm}), true
				}
				x.Scn = scn // rewind
				purpleA100Trm, ok := x.PurpleA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurpleA100{Trm: purpleA100Trm}), true
				}
				x.Scn = scn // rewind
				purpleA200Trm, ok := x.PurpleA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurpleA200{Trm: purpleA200Trm}), true
				}
				x.Scn = scn // rewind
				purpleA400Trm, ok := x.PurpleA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurpleA400{Trm: purpleA400Trm}), true
				}
				x.Scn = scn // rewind
				purpleA700Trm, ok := x.PurpleA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrPurpleA700{Trm: purpleA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'r':
				red50Trm, ok := x.Red50()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed50{Trm: red50Trm}), true
				}
				x.Scn = scn // rewind
				red100Trm, ok := x.Red100()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed100{Trm: red100Trm}), true
				}
				x.Scn = scn // rewind
				red200Trm, ok := x.Red200()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed200{Trm: red200Trm}), true
				}
				x.Scn = scn // rewind
				red300Trm, ok := x.Red300()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed300{Trm: red300Trm}), true
				}
				x.Scn = scn // rewind
				red400Trm, ok := x.Red400()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed400{Trm: red400Trm}), true
				}
				x.Scn = scn // rewind
				red500Trm, ok := x.Red500()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed500{Trm: red500Trm}), true
				}
				x.Scn = scn // rewind
				red600Trm, ok := x.Red600()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed600{Trm: red600Trm}), true
				}
				x.Scn = scn // rewind
				red700Trm, ok := x.Red700()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed700{Trm: red700Trm}), true
				}
				x.Scn = scn // rewind
				red800Trm, ok := x.Red800()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed800{Trm: red800Trm}), true
				}
				x.Scn = scn // rewind
				red900Trm, ok := x.Red900()
				if ok {
					return x.ClrClrXpr(scp, &ClrRed900{Trm: red900Trm}), true
				}
				x.Scn = scn // rewind
				redA100Trm, ok := x.RedA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrRedA100{Trm: redA100Trm}), true
				}
				x.Scn = scn // rewind
				redA200Trm, ok := x.RedA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrRedA200{Trm: redA200Trm}), true
				}
				x.Scn = scn // rewind
				redA400Trm, ok := x.RedA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrRedA400{Trm: redA400Trm}), true
				}
				x.Scn = scn // rewind
				redA700Trm, ok := x.RedA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrRedA700{Trm: redA700Trm}), true
				}
				x.Scn = scn // rewind
				rgbaTrm, ok := x.Rgba()
				if ok {
					x.NextLprn()
					cur := &ClrRgba{Trm: rgbaTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr), I3: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.ClrClrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				rgbTrm, ok := x.Rgb()
				if ok {
					x.NextLprn()
					cur := &ClrRgb{Trm: rgbTrm, I0: x.Xpr(scp).(FltFltXpr), I1: x.Xpr(scp).(FltFltXpr), I2: x.Xpr(scp).(FltFltXpr)}
					x.NextRprn()
					return x.ClrClrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 't':
				teal50Trm, ok := x.Teal50()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal50{Trm: teal50Trm}), true
				}
				x.Scn = scn // rewind
				teal100Trm, ok := x.Teal100()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal100{Trm: teal100Trm}), true
				}
				x.Scn = scn // rewind
				teal200Trm, ok := x.Teal200()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal200{Trm: teal200Trm}), true
				}
				x.Scn = scn // rewind
				teal300Trm, ok := x.Teal300()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal300{Trm: teal300Trm}), true
				}
				x.Scn = scn // rewind
				teal400Trm, ok := x.Teal400()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal400{Trm: teal400Trm}), true
				}
				x.Scn = scn // rewind
				teal500Trm, ok := x.Teal500()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal500{Trm: teal500Trm}), true
				}
				x.Scn = scn // rewind
				teal600Trm, ok := x.Teal600()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal600{Trm: teal600Trm}), true
				}
				x.Scn = scn // rewind
				teal700Trm, ok := x.Teal700()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal700{Trm: teal700Trm}), true
				}
				x.Scn = scn // rewind
				teal800Trm, ok := x.Teal800()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal800{Trm: teal800Trm}), true
				}
				x.Scn = scn // rewind
				teal900Trm, ok := x.Teal900()
				if ok {
					return x.ClrClrXpr(scp, &ClrTeal900{Trm: teal900Trm}), true
				}
				x.Scn = scn // rewind
				tealA100Trm, ok := x.TealA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrTealA100{Trm: tealA100Trm}), true
				}
				x.Scn = scn // rewind
				tealA200Trm, ok := x.TealA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrTealA200{Trm: tealA200Trm}), true
				}
				x.Scn = scn // rewind
				tealA400Trm, ok := x.TealA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrTealA400{Trm: tealA400Trm}), true
				}
				x.Scn = scn // rewind
				tealA700Trm, ok := x.TealA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrTealA700{Trm: tealA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'w':
				whiteTrm, ok := x.White()
				if ok {
					return x.ClrClrXpr(scp, &ClrWhite{Trm: whiteTrm}), true
				}
				x.Scn = scn // rewind
			case 'y':
				yellow50Trm, ok := x.Yellow50()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow50{Trm: yellow50Trm}), true
				}
				x.Scn = scn // rewind
				yellow100Trm, ok := x.Yellow100()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow100{Trm: yellow100Trm}), true
				}
				x.Scn = scn // rewind
				yellow200Trm, ok := x.Yellow200()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow200{Trm: yellow200Trm}), true
				}
				x.Scn = scn // rewind
				yellow300Trm, ok := x.Yellow300()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow300{Trm: yellow300Trm}), true
				}
				x.Scn = scn // rewind
				yellow400Trm, ok := x.Yellow400()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow400{Trm: yellow400Trm}), true
				}
				x.Scn = scn // rewind
				yellow500Trm, ok := x.Yellow500()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow500{Trm: yellow500Trm}), true
				}
				x.Scn = scn // rewind
				yellow600Trm, ok := x.Yellow600()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow600{Trm: yellow600Trm}), true
				}
				x.Scn = scn // rewind
				yellow700Trm, ok := x.Yellow700()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow700{Trm: yellow700Trm}), true
				}
				x.Scn = scn // rewind
				yellow800Trm, ok := x.Yellow800()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow800{Trm: yellow800Trm}), true
				}
				x.Scn = scn // rewind
				yellow900Trm, ok := x.Yellow900()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellow900{Trm: yellow900Trm}), true
				}
				x.Scn = scn // rewind
				yellowA100Trm, ok := x.YellowA100()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellowA100{Trm: yellowA100Trm}), true
				}
				x.Scn = scn // rewind
				yellowA200Trm, ok := x.YellowA200()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellowA200{Trm: yellowA200Trm}), true
				}
				x.Scn = scn // rewind
				yellowA400Trm, ok := x.YellowA400()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellowA400{Trm: yellowA400Trm}), true
				}
				x.Scn = scn // rewind
				yellowA700Trm, ok := x.YellowA700()
				if ok {
					return x.ClrClrXpr(scp, &ClrYellowA700{Trm: yellowA700Trm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("ClrPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) ClrClrXpr(scp *Scp, X ClrClrXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Clr asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Clr asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Clr asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.ClrClr)
				return x.ClrClrXpr(scp, &ClrClrAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'i':
			invTrm, ok := x.Inv()
			if ok {
				x.NextLprn()
				cur := &ClrClrInv{Trm: invTrm, X: X}
				x.NextRprn()
				return x.ClrClrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			opaTrm, ok := x.Opa()
			if ok {
				x.NextLprn()
				cur := &ClrClrOpa{Trm: opaTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.ClrClrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("ClrClrXpr: no expression found")
	}
	return X
}
func (x *Xprr) PenPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Pen()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'a':
				amber50Trm, ok := x.Amber50()
				if ok {
					return x.PenPenXpr(scp, &PenAmber50{Trm: amber50Trm}), true
				}
				x.Scn = scn // rewind
				amber100Trm, ok := x.Amber100()
				if ok {
					return x.PenPenXpr(scp, &PenAmber100{Trm: amber100Trm}), true
				}
				x.Scn = scn // rewind
				amber200Trm, ok := x.Amber200()
				if ok {
					return x.PenPenXpr(scp, &PenAmber200{Trm: amber200Trm}), true
				}
				x.Scn = scn // rewind
				amber300Trm, ok := x.Amber300()
				if ok {
					return x.PenPenXpr(scp, &PenAmber300{Trm: amber300Trm}), true
				}
				x.Scn = scn // rewind
				amber400Trm, ok := x.Amber400()
				if ok {
					return x.PenPenXpr(scp, &PenAmber400{Trm: amber400Trm}), true
				}
				x.Scn = scn // rewind
				amber500Trm, ok := x.Amber500()
				if ok {
					return x.PenPenXpr(scp, &PenAmber500{Trm: amber500Trm}), true
				}
				x.Scn = scn // rewind
				amber600Trm, ok := x.Amber600()
				if ok {
					return x.PenPenXpr(scp, &PenAmber600{Trm: amber600Trm}), true
				}
				x.Scn = scn // rewind
				amber700Trm, ok := x.Amber700()
				if ok {
					return x.PenPenXpr(scp, &PenAmber700{Trm: amber700Trm}), true
				}
				x.Scn = scn // rewind
				amber800Trm, ok := x.Amber800()
				if ok {
					return x.PenPenXpr(scp, &PenAmber800{Trm: amber800Trm}), true
				}
				x.Scn = scn // rewind
				amber900Trm, ok := x.Amber900()
				if ok {
					return x.PenPenXpr(scp, &PenAmber900{Trm: amber900Trm}), true
				}
				x.Scn = scn // rewind
				amberA100Trm, ok := x.AmberA100()
				if ok {
					return x.PenPenXpr(scp, &PenAmberA100{Trm: amberA100Trm}), true
				}
				x.Scn = scn // rewind
				amberA200Trm, ok := x.AmberA200()
				if ok {
					return x.PenPenXpr(scp, &PenAmberA200{Trm: amberA200Trm}), true
				}
				x.Scn = scn // rewind
				amberA400Trm, ok := x.AmberA400()
				if ok {
					return x.PenPenXpr(scp, &PenAmberA400{Trm: amberA400Trm}), true
				}
				x.Scn = scn // rewind
				amberA700Trm, ok := x.AmberA700()
				if ok {
					return x.PenPenXpr(scp, &PenAmberA700{Trm: amberA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'b':
				blackTrm, ok := x.Black()
				if ok {
					return x.PenPenXpr(scp, &PenBlack{Trm: blackTrm}), true
				}
				x.Scn = scn // rewind
				blue50Trm, ok := x.Blue50()
				if ok {
					return x.PenPenXpr(scp, &PenBlue50{Trm: blue50Trm}), true
				}
				x.Scn = scn // rewind
				blue100Trm, ok := x.Blue100()
				if ok {
					return x.PenPenXpr(scp, &PenBlue100{Trm: blue100Trm}), true
				}
				x.Scn = scn // rewind
				blue200Trm, ok := x.Blue200()
				if ok {
					return x.PenPenXpr(scp, &PenBlue200{Trm: blue200Trm}), true
				}
				x.Scn = scn // rewind
				blue300Trm, ok := x.Blue300()
				if ok {
					return x.PenPenXpr(scp, &PenBlue300{Trm: blue300Trm}), true
				}
				x.Scn = scn // rewind
				blue400Trm, ok := x.Blue400()
				if ok {
					return x.PenPenXpr(scp, &PenBlue400{Trm: blue400Trm}), true
				}
				x.Scn = scn // rewind
				blue500Trm, ok := x.Blue500()
				if ok {
					return x.PenPenXpr(scp, &PenBlue500{Trm: blue500Trm}), true
				}
				x.Scn = scn // rewind
				blue600Trm, ok := x.Blue600()
				if ok {
					return x.PenPenXpr(scp, &PenBlue600{Trm: blue600Trm}), true
				}
				x.Scn = scn // rewind
				blue700Trm, ok := x.Blue700()
				if ok {
					return x.PenPenXpr(scp, &PenBlue700{Trm: blue700Trm}), true
				}
				x.Scn = scn // rewind
				blue800Trm, ok := x.Blue800()
				if ok {
					return x.PenPenXpr(scp, &PenBlue800{Trm: blue800Trm}), true
				}
				x.Scn = scn // rewind
				blue900Trm, ok := x.Blue900()
				if ok {
					return x.PenPenXpr(scp, &PenBlue900{Trm: blue900Trm}), true
				}
				x.Scn = scn // rewind
				blueA100Trm, ok := x.BlueA100()
				if ok {
					return x.PenPenXpr(scp, &PenBlueA100{Trm: blueA100Trm}), true
				}
				x.Scn = scn // rewind
				blueA200Trm, ok := x.BlueA200()
				if ok {
					return x.PenPenXpr(scp, &PenBlueA200{Trm: blueA200Trm}), true
				}
				x.Scn = scn // rewind
				blueA400Trm, ok := x.BlueA400()
				if ok {
					return x.PenPenXpr(scp, &PenBlueA400{Trm: blueA400Trm}), true
				}
				x.Scn = scn // rewind
				blueA700Trm, ok := x.BlueA700()
				if ok {
					return x.PenPenXpr(scp, &PenBlueA700{Trm: blueA700Trm}), true
				}
				x.Scn = scn // rewind
				brown50Trm, ok := x.Brown50()
				if ok {
					return x.PenPenXpr(scp, &PenBrown50{Trm: brown50Trm}), true
				}
				x.Scn = scn // rewind
				brown100Trm, ok := x.Brown100()
				if ok {
					return x.PenPenXpr(scp, &PenBrown100{Trm: brown100Trm}), true
				}
				x.Scn = scn // rewind
				brown200Trm, ok := x.Brown200()
				if ok {
					return x.PenPenXpr(scp, &PenBrown200{Trm: brown200Trm}), true
				}
				x.Scn = scn // rewind
				brown300Trm, ok := x.Brown300()
				if ok {
					return x.PenPenXpr(scp, &PenBrown300{Trm: brown300Trm}), true
				}
				x.Scn = scn // rewind
				brown400Trm, ok := x.Brown400()
				if ok {
					return x.PenPenXpr(scp, &PenBrown400{Trm: brown400Trm}), true
				}
				x.Scn = scn // rewind
				brown500Trm, ok := x.Brown500()
				if ok {
					return x.PenPenXpr(scp, &PenBrown500{Trm: brown500Trm}), true
				}
				x.Scn = scn // rewind
				brown600Trm, ok := x.Brown600()
				if ok {
					return x.PenPenXpr(scp, &PenBrown600{Trm: brown600Trm}), true
				}
				x.Scn = scn // rewind
				brown700Trm, ok := x.Brown700()
				if ok {
					return x.PenPenXpr(scp, &PenBrown700{Trm: brown700Trm}), true
				}
				x.Scn = scn // rewind
				brown800Trm, ok := x.Brown800()
				if ok {
					return x.PenPenXpr(scp, &PenBrown800{Trm: brown800Trm}), true
				}
				x.Scn = scn // rewind
				brown900Trm, ok := x.Brown900()
				if ok {
					return x.PenPenXpr(scp, &PenBrown900{Trm: brown900Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey50Trm, ok := x.BlueGrey50()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey50{Trm: blueGrey50Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey100Trm, ok := x.BlueGrey100()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey100{Trm: blueGrey100Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey200Trm, ok := x.BlueGrey200()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey200{Trm: blueGrey200Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey300Trm, ok := x.BlueGrey300()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey300{Trm: blueGrey300Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey400Trm, ok := x.BlueGrey400()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey400{Trm: blueGrey400Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey500Trm, ok := x.BlueGrey500()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey500{Trm: blueGrey500Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey600Trm, ok := x.BlueGrey600()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey600{Trm: blueGrey600Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey700Trm, ok := x.BlueGrey700()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey700{Trm: blueGrey700Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey800Trm, ok := x.BlueGrey800()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey800{Trm: blueGrey800Trm}), true
				}
				x.Scn = scn // rewind
				blueGrey900Trm, ok := x.BlueGrey900()
				if ok {
					return x.PenPenXpr(scp, &PenBlueGrey900{Trm: blueGrey900Trm}), true
				}
				x.Scn = scn // rewind
			case 'c':
				cyan50Trm, ok := x.Cyan50()
				if ok {
					return x.PenPenXpr(scp, &PenCyan50{Trm: cyan50Trm}), true
				}
				x.Scn = scn // rewind
				cyan100Trm, ok := x.Cyan100()
				if ok {
					return x.PenPenXpr(scp, &PenCyan100{Trm: cyan100Trm}), true
				}
				x.Scn = scn // rewind
				cyan200Trm, ok := x.Cyan200()
				if ok {
					return x.PenPenXpr(scp, &PenCyan200{Trm: cyan200Trm}), true
				}
				x.Scn = scn // rewind
				cyan300Trm, ok := x.Cyan300()
				if ok {
					return x.PenPenXpr(scp, &PenCyan300{Trm: cyan300Trm}), true
				}
				x.Scn = scn // rewind
				cyan400Trm, ok := x.Cyan400()
				if ok {
					return x.PenPenXpr(scp, &PenCyan400{Trm: cyan400Trm}), true
				}
				x.Scn = scn // rewind
				cyan500Trm, ok := x.Cyan500()
				if ok {
					return x.PenPenXpr(scp, &PenCyan500{Trm: cyan500Trm}), true
				}
				x.Scn = scn // rewind
				cyan600Trm, ok := x.Cyan600()
				if ok {
					return x.PenPenXpr(scp, &PenCyan600{Trm: cyan600Trm}), true
				}
				x.Scn = scn // rewind
				cyan700Trm, ok := x.Cyan700()
				if ok {
					return x.PenPenXpr(scp, &PenCyan700{Trm: cyan700Trm}), true
				}
				x.Scn = scn // rewind
				cyan800Trm, ok := x.Cyan800()
				if ok {
					return x.PenPenXpr(scp, &PenCyan800{Trm: cyan800Trm}), true
				}
				x.Scn = scn // rewind
				cyan900Trm, ok := x.Cyan900()
				if ok {
					return x.PenPenXpr(scp, &PenCyan900{Trm: cyan900Trm}), true
				}
				x.Scn = scn // rewind
				cyanA100Trm, ok := x.CyanA100()
				if ok {
					return x.PenPenXpr(scp, &PenCyanA100{Trm: cyanA100Trm}), true
				}
				x.Scn = scn // rewind
				cyanA200Trm, ok := x.CyanA200()
				if ok {
					return x.PenPenXpr(scp, &PenCyanA200{Trm: cyanA200Trm}), true
				}
				x.Scn = scn // rewind
				cyanA400Trm, ok := x.CyanA400()
				if ok {
					return x.PenPenXpr(scp, &PenCyanA400{Trm: cyanA400Trm}), true
				}
				x.Scn = scn // rewind
				cyanA700Trm, ok := x.CyanA700()
				if ok {
					return x.PenPenXpr(scp, &PenCyanA700{Trm: cyanA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'd':
				deepPurple50Trm, ok := x.DeepPurple50()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple50{Trm: deepPurple50Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple100Trm, ok := x.DeepPurple100()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple100{Trm: deepPurple100Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple200Trm, ok := x.DeepPurple200()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple200{Trm: deepPurple200Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple300Trm, ok := x.DeepPurple300()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple300{Trm: deepPurple300Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple400Trm, ok := x.DeepPurple400()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple400{Trm: deepPurple400Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple500Trm, ok := x.DeepPurple500()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple500{Trm: deepPurple500Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple600Trm, ok := x.DeepPurple600()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple600{Trm: deepPurple600Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple700Trm, ok := x.DeepPurple700()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple700{Trm: deepPurple700Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple800Trm, ok := x.DeepPurple800()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple800{Trm: deepPurple800Trm}), true
				}
				x.Scn = scn // rewind
				deepPurple900Trm, ok := x.DeepPurple900()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurple900{Trm: deepPurple900Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA100Trm, ok := x.DeepPurpleA100()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurpleA100{Trm: deepPurpleA100Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA200Trm, ok := x.DeepPurpleA200()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurpleA200{Trm: deepPurpleA200Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA400Trm, ok := x.DeepPurpleA400()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurpleA400{Trm: deepPurpleA400Trm}), true
				}
				x.Scn = scn // rewind
				deepPurpleA700Trm, ok := x.DeepPurpleA700()
				if ok {
					return x.PenPenXpr(scp, &PenDeepPurpleA700{Trm: deepPurpleA700Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange50Trm, ok := x.DeepOrange50()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange50{Trm: deepOrange50Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange100Trm, ok := x.DeepOrange100()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange100{Trm: deepOrange100Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange200Trm, ok := x.DeepOrange200()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange200{Trm: deepOrange200Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange300Trm, ok := x.DeepOrange300()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange300{Trm: deepOrange300Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange400Trm, ok := x.DeepOrange400()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange400{Trm: deepOrange400Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange500Trm, ok := x.DeepOrange500()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange500{Trm: deepOrange500Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange600Trm, ok := x.DeepOrange600()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange600{Trm: deepOrange600Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange700Trm, ok := x.DeepOrange700()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange700{Trm: deepOrange700Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange800Trm, ok := x.DeepOrange800()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange800{Trm: deepOrange800Trm}), true
				}
				x.Scn = scn // rewind
				deepOrange900Trm, ok := x.DeepOrange900()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrange900{Trm: deepOrange900Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA100Trm, ok := x.DeepOrangeA100()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrangeA100{Trm: deepOrangeA100Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA200Trm, ok := x.DeepOrangeA200()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrangeA200{Trm: deepOrangeA200Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA400Trm, ok := x.DeepOrangeA400()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrangeA400{Trm: deepOrangeA400Trm}), true
				}
				x.Scn = scn // rewind
				deepOrangeA700Trm, ok := x.DeepOrangeA700()
				if ok {
					return x.PenPenXpr(scp, &PenDeepOrangeA700{Trm: deepOrangeA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'g':
				green50Trm, ok := x.Green50()
				if ok {
					return x.PenPenXpr(scp, &PenGreen50{Trm: green50Trm}), true
				}
				x.Scn = scn // rewind
				green100Trm, ok := x.Green100()
				if ok {
					return x.PenPenXpr(scp, &PenGreen100{Trm: green100Trm}), true
				}
				x.Scn = scn // rewind
				green200Trm, ok := x.Green200()
				if ok {
					return x.PenPenXpr(scp, &PenGreen200{Trm: green200Trm}), true
				}
				x.Scn = scn // rewind
				green300Trm, ok := x.Green300()
				if ok {
					return x.PenPenXpr(scp, &PenGreen300{Trm: green300Trm}), true
				}
				x.Scn = scn // rewind
				green400Trm, ok := x.Green400()
				if ok {
					return x.PenPenXpr(scp, &PenGreen400{Trm: green400Trm}), true
				}
				x.Scn = scn // rewind
				green500Trm, ok := x.Green500()
				if ok {
					return x.PenPenXpr(scp, &PenGreen500{Trm: green500Trm}), true
				}
				x.Scn = scn // rewind
				green600Trm, ok := x.Green600()
				if ok {
					return x.PenPenXpr(scp, &PenGreen600{Trm: green600Trm}), true
				}
				x.Scn = scn // rewind
				green700Trm, ok := x.Green700()
				if ok {
					return x.PenPenXpr(scp, &PenGreen700{Trm: green700Trm}), true
				}
				x.Scn = scn // rewind
				green800Trm, ok := x.Green800()
				if ok {
					return x.PenPenXpr(scp, &PenGreen800{Trm: green800Trm}), true
				}
				x.Scn = scn // rewind
				green900Trm, ok := x.Green900()
				if ok {
					return x.PenPenXpr(scp, &PenGreen900{Trm: green900Trm}), true
				}
				x.Scn = scn // rewind
				greenA100Trm, ok := x.GreenA100()
				if ok {
					return x.PenPenXpr(scp, &PenGreenA100{Trm: greenA100Trm}), true
				}
				x.Scn = scn // rewind
				greenA200Trm, ok := x.GreenA200()
				if ok {
					return x.PenPenXpr(scp, &PenGreenA200{Trm: greenA200Trm}), true
				}
				x.Scn = scn // rewind
				greenA400Trm, ok := x.GreenA400()
				if ok {
					return x.PenPenXpr(scp, &PenGreenA400{Trm: greenA400Trm}), true
				}
				x.Scn = scn // rewind
				greenA700Trm, ok := x.GreenA700()
				if ok {
					return x.PenPenXpr(scp, &PenGreenA700{Trm: greenA700Trm}), true
				}
				x.Scn = scn // rewind
				grey50Trm, ok := x.Grey50()
				if ok {
					return x.PenPenXpr(scp, &PenGrey50{Trm: grey50Trm}), true
				}
				x.Scn = scn // rewind
				grey100Trm, ok := x.Grey100()
				if ok {
					return x.PenPenXpr(scp, &PenGrey100{Trm: grey100Trm}), true
				}
				x.Scn = scn // rewind
				grey200Trm, ok := x.Grey200()
				if ok {
					return x.PenPenXpr(scp, &PenGrey200{Trm: grey200Trm}), true
				}
				x.Scn = scn // rewind
				grey300Trm, ok := x.Grey300()
				if ok {
					return x.PenPenXpr(scp, &PenGrey300{Trm: grey300Trm}), true
				}
				x.Scn = scn // rewind
				grey400Trm, ok := x.Grey400()
				if ok {
					return x.PenPenXpr(scp, &PenGrey400{Trm: grey400Trm}), true
				}
				x.Scn = scn // rewind
				grey500Trm, ok := x.Grey500()
				if ok {
					return x.PenPenXpr(scp, &PenGrey500{Trm: grey500Trm}), true
				}
				x.Scn = scn // rewind
				grey600Trm, ok := x.Grey600()
				if ok {
					return x.PenPenXpr(scp, &PenGrey600{Trm: grey600Trm}), true
				}
				x.Scn = scn // rewind
				grey700Trm, ok := x.Grey700()
				if ok {
					return x.PenPenXpr(scp, &PenGrey700{Trm: grey700Trm}), true
				}
				x.Scn = scn // rewind
				grey800Trm, ok := x.Grey800()
				if ok {
					return x.PenPenXpr(scp, &PenGrey800{Trm: grey800Trm}), true
				}
				x.Scn = scn // rewind
				grey900Trm, ok := x.Grey900()
				if ok {
					return x.PenPenXpr(scp, &PenGrey900{Trm: grey900Trm}), true
				}
				x.Scn = scn // rewind
			case 'h':
				hexTrm, ok := x.Hex()
				if ok {
					x.NextLprn()
					i0 := x.Xpr(scp).(StrStrXpr)
					var i1 []UntUntXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(UntUntXpr)
						if !ok {
							x.Panicf("PenPkgXpr: Hex: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i1 = append(i1, v)
					}
					cur := &PenHex{Trm: hexTrm, I0: i0, I1: i1}
					x.NextRprn()
					return x.PenPenXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'i':
				indigo50Trm, ok := x.Indigo50()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo50{Trm: indigo50Trm}), true
				}
				x.Scn = scn // rewind
				indigo100Trm, ok := x.Indigo100()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo100{Trm: indigo100Trm}), true
				}
				x.Scn = scn // rewind
				indigo200Trm, ok := x.Indigo200()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo200{Trm: indigo200Trm}), true
				}
				x.Scn = scn // rewind
				indigo300Trm, ok := x.Indigo300()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo300{Trm: indigo300Trm}), true
				}
				x.Scn = scn // rewind
				indigo400Trm, ok := x.Indigo400()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo400{Trm: indigo400Trm}), true
				}
				x.Scn = scn // rewind
				indigo500Trm, ok := x.Indigo500()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo500{Trm: indigo500Trm}), true
				}
				x.Scn = scn // rewind
				indigo600Trm, ok := x.Indigo600()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo600{Trm: indigo600Trm}), true
				}
				x.Scn = scn // rewind
				indigo700Trm, ok := x.Indigo700()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo700{Trm: indigo700Trm}), true
				}
				x.Scn = scn // rewind
				indigo800Trm, ok := x.Indigo800()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo800{Trm: indigo800Trm}), true
				}
				x.Scn = scn // rewind
				indigo900Trm, ok := x.Indigo900()
				if ok {
					return x.PenPenXpr(scp, &PenIndigo900{Trm: indigo900Trm}), true
				}
				x.Scn = scn // rewind
				indigoA100Trm, ok := x.IndigoA100()
				if ok {
					return x.PenPenXpr(scp, &PenIndigoA100{Trm: indigoA100Trm}), true
				}
				x.Scn = scn // rewind
				indigoA200Trm, ok := x.IndigoA200()
				if ok {
					return x.PenPenXpr(scp, &PenIndigoA200{Trm: indigoA200Trm}), true
				}
				x.Scn = scn // rewind
				indigoA400Trm, ok := x.IndigoA400()
				if ok {
					return x.PenPenXpr(scp, &PenIndigoA400{Trm: indigoA400Trm}), true
				}
				x.Scn = scn // rewind
				indigoA700Trm, ok := x.IndigoA700()
				if ok {
					return x.PenPenXpr(scp, &PenIndigoA700{Trm: indigoA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'l':
				lightBlue50Trm, ok := x.LightBlue50()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue50{Trm: lightBlue50Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue100Trm, ok := x.LightBlue100()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue100{Trm: lightBlue100Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue200Trm, ok := x.LightBlue200()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue200{Trm: lightBlue200Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue300Trm, ok := x.LightBlue300()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue300{Trm: lightBlue300Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue400Trm, ok := x.LightBlue400()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue400{Trm: lightBlue400Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue500Trm, ok := x.LightBlue500()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue500{Trm: lightBlue500Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue600Trm, ok := x.LightBlue600()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue600{Trm: lightBlue600Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue700Trm, ok := x.LightBlue700()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue700{Trm: lightBlue700Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue800Trm, ok := x.LightBlue800()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue800{Trm: lightBlue800Trm}), true
				}
				x.Scn = scn // rewind
				lightBlue900Trm, ok := x.LightBlue900()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlue900{Trm: lightBlue900Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA100Trm, ok := x.LightBlueA100()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlueA100{Trm: lightBlueA100Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA200Trm, ok := x.LightBlueA200()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlueA200{Trm: lightBlueA200Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA400Trm, ok := x.LightBlueA400()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlueA400{Trm: lightBlueA400Trm}), true
				}
				x.Scn = scn // rewind
				lightBlueA700Trm, ok := x.LightBlueA700()
				if ok {
					return x.PenPenXpr(scp, &PenLightBlueA700{Trm: lightBlueA700Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen50Trm, ok := x.LightGreen50()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen50{Trm: lightGreen50Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen100Trm, ok := x.LightGreen100()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen100{Trm: lightGreen100Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen200Trm, ok := x.LightGreen200()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen200{Trm: lightGreen200Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen300Trm, ok := x.LightGreen300()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen300{Trm: lightGreen300Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen400Trm, ok := x.LightGreen400()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen400{Trm: lightGreen400Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen500Trm, ok := x.LightGreen500()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen500{Trm: lightGreen500Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen600Trm, ok := x.LightGreen600()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen600{Trm: lightGreen600Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen700Trm, ok := x.LightGreen700()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen700{Trm: lightGreen700Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen800Trm, ok := x.LightGreen800()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen800{Trm: lightGreen800Trm}), true
				}
				x.Scn = scn // rewind
				lightGreen900Trm, ok := x.LightGreen900()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreen900{Trm: lightGreen900Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA100Trm, ok := x.LightGreenA100()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreenA100{Trm: lightGreenA100Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA200Trm, ok := x.LightGreenA200()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreenA200{Trm: lightGreenA200Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA400Trm, ok := x.LightGreenA400()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreenA400{Trm: lightGreenA400Trm}), true
				}
				x.Scn = scn // rewind
				lightGreenA700Trm, ok := x.LightGreenA700()
				if ok {
					return x.PenPenXpr(scp, &PenLightGreenA700{Trm: lightGreenA700Trm}), true
				}
				x.Scn = scn // rewind
				lime50Trm, ok := x.Lime50()
				if ok {
					return x.PenPenXpr(scp, &PenLime50{Trm: lime50Trm}), true
				}
				x.Scn = scn // rewind
				lime100Trm, ok := x.Lime100()
				if ok {
					return x.PenPenXpr(scp, &PenLime100{Trm: lime100Trm}), true
				}
				x.Scn = scn // rewind
				lime200Trm, ok := x.Lime200()
				if ok {
					return x.PenPenXpr(scp, &PenLime200{Trm: lime200Trm}), true
				}
				x.Scn = scn // rewind
				lime300Trm, ok := x.Lime300()
				if ok {
					return x.PenPenXpr(scp, &PenLime300{Trm: lime300Trm}), true
				}
				x.Scn = scn // rewind
				lime400Trm, ok := x.Lime400()
				if ok {
					return x.PenPenXpr(scp, &PenLime400{Trm: lime400Trm}), true
				}
				x.Scn = scn // rewind
				lime500Trm, ok := x.Lime500()
				if ok {
					return x.PenPenXpr(scp, &PenLime500{Trm: lime500Trm}), true
				}
				x.Scn = scn // rewind
				lime600Trm, ok := x.Lime600()
				if ok {
					return x.PenPenXpr(scp, &PenLime600{Trm: lime600Trm}), true
				}
				x.Scn = scn // rewind
				lime700Trm, ok := x.Lime700()
				if ok {
					return x.PenPenXpr(scp, &PenLime700{Trm: lime700Trm}), true
				}
				x.Scn = scn // rewind
				lime800Trm, ok := x.Lime800()
				if ok {
					return x.PenPenXpr(scp, &PenLime800{Trm: lime800Trm}), true
				}
				x.Scn = scn // rewind
				lime900Trm, ok := x.Lime900()
				if ok {
					return x.PenPenXpr(scp, &PenLime900{Trm: lime900Trm}), true
				}
				x.Scn = scn // rewind
				limeA100Trm, ok := x.LimeA100()
				if ok {
					return x.PenPenXpr(scp, &PenLimeA100{Trm: limeA100Trm}), true
				}
				x.Scn = scn // rewind
				limeA200Trm, ok := x.LimeA200()
				if ok {
					return x.PenPenXpr(scp, &PenLimeA200{Trm: limeA200Trm}), true
				}
				x.Scn = scn // rewind
				limeA400Trm, ok := x.LimeA400()
				if ok {
					return x.PenPenXpr(scp, &PenLimeA400{Trm: limeA400Trm}), true
				}
				x.Scn = scn // rewind
				limeA700Trm, ok := x.LimeA700()
				if ok {
					return x.PenPenXpr(scp, &PenLimeA700{Trm: limeA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'm':
				makePensTrm, ok := x.MakePens()
				if ok {
					x.NextLprn()
					cur := &PenMakePens{Trm: makePensTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.PenPensXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpPensTrm, ok := x.MakeEmpPens()
				if ok {
					x.NextLprn()
					cur := &PenMakeEmpPens{Trm: makeEmpPensTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.PenPensXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newTrm, ok := x.New()
				if ok {
					x.NextLprn()
					i0 := x.Xpr(scp).(ClrClrXpr)
					var i1 []UntUntXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(UntUntXpr)
						if !ok {
							x.Panicf("PenPkgXpr: New: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i1 = append(i1, v)
					}
					cur := &PenNew{Trm: newTrm, I0: i0, I1: i1}
					x.NextRprn()
					return x.PenPenXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newPensTrm, ok := x.NewPens()
				if ok {
					x.NextLprn()
					var i0 []PenPenXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(PenPenXpr)
						if !ok {
							x.Panicf("PenPkgXpr: NewPens: non PenPenXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &PenNewPens{Trm: newPensTrm, I0: i0}
					x.NextRprn()
					return x.PenPensXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'o':
				orange50Trm, ok := x.Orange50()
				if ok {
					return x.PenPenXpr(scp, &PenOrange50{Trm: orange50Trm}), true
				}
				x.Scn = scn // rewind
				orange100Trm, ok := x.Orange100()
				if ok {
					return x.PenPenXpr(scp, &PenOrange100{Trm: orange100Trm}), true
				}
				x.Scn = scn // rewind
				orange200Trm, ok := x.Orange200()
				if ok {
					return x.PenPenXpr(scp, &PenOrange200{Trm: orange200Trm}), true
				}
				x.Scn = scn // rewind
				orange300Trm, ok := x.Orange300()
				if ok {
					return x.PenPenXpr(scp, &PenOrange300{Trm: orange300Trm}), true
				}
				x.Scn = scn // rewind
				orange400Trm, ok := x.Orange400()
				if ok {
					return x.PenPenXpr(scp, &PenOrange400{Trm: orange400Trm}), true
				}
				x.Scn = scn // rewind
				orange500Trm, ok := x.Orange500()
				if ok {
					return x.PenPenXpr(scp, &PenOrange500{Trm: orange500Trm}), true
				}
				x.Scn = scn // rewind
				orange600Trm, ok := x.Orange600()
				if ok {
					return x.PenPenXpr(scp, &PenOrange600{Trm: orange600Trm}), true
				}
				x.Scn = scn // rewind
				orange700Trm, ok := x.Orange700()
				if ok {
					return x.PenPenXpr(scp, &PenOrange700{Trm: orange700Trm}), true
				}
				x.Scn = scn // rewind
				orange800Trm, ok := x.Orange800()
				if ok {
					return x.PenPenXpr(scp, &PenOrange800{Trm: orange800Trm}), true
				}
				x.Scn = scn // rewind
				orange900Trm, ok := x.Orange900()
				if ok {
					return x.PenPenXpr(scp, &PenOrange900{Trm: orange900Trm}), true
				}
				x.Scn = scn // rewind
				orangeA100Trm, ok := x.OrangeA100()
				if ok {
					return x.PenPenXpr(scp, &PenOrangeA100{Trm: orangeA100Trm}), true
				}
				x.Scn = scn // rewind
				orangeA200Trm, ok := x.OrangeA200()
				if ok {
					return x.PenPenXpr(scp, &PenOrangeA200{Trm: orangeA200Trm}), true
				}
				x.Scn = scn // rewind
				orangeA400Trm, ok := x.OrangeA400()
				if ok {
					return x.PenPenXpr(scp, &PenOrangeA400{Trm: orangeA400Trm}), true
				}
				x.Scn = scn // rewind
				orangeA700Trm, ok := x.OrangeA700()
				if ok {
					return x.PenPenXpr(scp, &PenOrangeA700{Trm: orangeA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'p':
				pink50Trm, ok := x.Pink50()
				if ok {
					return x.PenPenXpr(scp, &PenPink50{Trm: pink50Trm}), true
				}
				x.Scn = scn // rewind
				pink100Trm, ok := x.Pink100()
				if ok {
					return x.PenPenXpr(scp, &PenPink100{Trm: pink100Trm}), true
				}
				x.Scn = scn // rewind
				pink200Trm, ok := x.Pink200()
				if ok {
					return x.PenPenXpr(scp, &PenPink200{Trm: pink200Trm}), true
				}
				x.Scn = scn // rewind
				pink300Trm, ok := x.Pink300()
				if ok {
					return x.PenPenXpr(scp, &PenPink300{Trm: pink300Trm}), true
				}
				x.Scn = scn // rewind
				pink400Trm, ok := x.Pink400()
				if ok {
					return x.PenPenXpr(scp, &PenPink400{Trm: pink400Trm}), true
				}
				x.Scn = scn // rewind
				pink500Trm, ok := x.Pink500()
				if ok {
					return x.PenPenXpr(scp, &PenPink500{Trm: pink500Trm}), true
				}
				x.Scn = scn // rewind
				pink600Trm, ok := x.Pink600()
				if ok {
					return x.PenPenXpr(scp, &PenPink600{Trm: pink600Trm}), true
				}
				x.Scn = scn // rewind
				pink700Trm, ok := x.Pink700()
				if ok {
					return x.PenPenXpr(scp, &PenPink700{Trm: pink700Trm}), true
				}
				x.Scn = scn // rewind
				pink800Trm, ok := x.Pink800()
				if ok {
					return x.PenPenXpr(scp, &PenPink800{Trm: pink800Trm}), true
				}
				x.Scn = scn // rewind
				pink900Trm, ok := x.Pink900()
				if ok {
					return x.PenPenXpr(scp, &PenPink900{Trm: pink900Trm}), true
				}
				x.Scn = scn // rewind
				pinkA100Trm, ok := x.PinkA100()
				if ok {
					return x.PenPenXpr(scp, &PenPinkA100{Trm: pinkA100Trm}), true
				}
				x.Scn = scn // rewind
				pinkA200Trm, ok := x.PinkA200()
				if ok {
					return x.PenPenXpr(scp, &PenPinkA200{Trm: pinkA200Trm}), true
				}
				x.Scn = scn // rewind
				pinkA400Trm, ok := x.PinkA400()
				if ok {
					return x.PenPenXpr(scp, &PenPinkA400{Trm: pinkA400Trm}), true
				}
				x.Scn = scn // rewind
				pinkA700Trm, ok := x.PinkA700()
				if ok {
					return x.PenPenXpr(scp, &PenPinkA700{Trm: pinkA700Trm}), true
				}
				x.Scn = scn // rewind
				purple50Trm, ok := x.Purple50()
				if ok {
					return x.PenPenXpr(scp, &PenPurple50{Trm: purple50Trm}), true
				}
				x.Scn = scn // rewind
				purple100Trm, ok := x.Purple100()
				if ok {
					return x.PenPenXpr(scp, &PenPurple100{Trm: purple100Trm}), true
				}
				x.Scn = scn // rewind
				purple200Trm, ok := x.Purple200()
				if ok {
					return x.PenPenXpr(scp, &PenPurple200{Trm: purple200Trm}), true
				}
				x.Scn = scn // rewind
				purple300Trm, ok := x.Purple300()
				if ok {
					return x.PenPenXpr(scp, &PenPurple300{Trm: purple300Trm}), true
				}
				x.Scn = scn // rewind
				purple400Trm, ok := x.Purple400()
				if ok {
					return x.PenPenXpr(scp, &PenPurple400{Trm: purple400Trm}), true
				}
				x.Scn = scn // rewind
				purple500Trm, ok := x.Purple500()
				if ok {
					return x.PenPenXpr(scp, &PenPurple500{Trm: purple500Trm}), true
				}
				x.Scn = scn // rewind
				purple600Trm, ok := x.Purple600()
				if ok {
					return x.PenPenXpr(scp, &PenPurple600{Trm: purple600Trm}), true
				}
				x.Scn = scn // rewind
				purple700Trm, ok := x.Purple700()
				if ok {
					return x.PenPenXpr(scp, &PenPurple700{Trm: purple700Trm}), true
				}
				x.Scn = scn // rewind
				purple800Trm, ok := x.Purple800()
				if ok {
					return x.PenPenXpr(scp, &PenPurple800{Trm: purple800Trm}), true
				}
				x.Scn = scn // rewind
				purple900Trm, ok := x.Purple900()
				if ok {
					return x.PenPenXpr(scp, &PenPurple900{Trm: purple900Trm}), true
				}
				x.Scn = scn // rewind
				purpleA100Trm, ok := x.PurpleA100()
				if ok {
					return x.PenPenXpr(scp, &PenPurpleA100{Trm: purpleA100Trm}), true
				}
				x.Scn = scn // rewind
				purpleA200Trm, ok := x.PurpleA200()
				if ok {
					return x.PenPenXpr(scp, &PenPurpleA200{Trm: purpleA200Trm}), true
				}
				x.Scn = scn // rewind
				purpleA400Trm, ok := x.PurpleA400()
				if ok {
					return x.PenPenXpr(scp, &PenPurpleA400{Trm: purpleA400Trm}), true
				}
				x.Scn = scn // rewind
				purpleA700Trm, ok := x.PurpleA700()
				if ok {
					return x.PenPenXpr(scp, &PenPurpleA700{Trm: purpleA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'r':
				red50Trm, ok := x.Red50()
				if ok {
					return x.PenPenXpr(scp, &PenRed50{Trm: red50Trm}), true
				}
				x.Scn = scn // rewind
				red100Trm, ok := x.Red100()
				if ok {
					return x.PenPenXpr(scp, &PenRed100{Trm: red100Trm}), true
				}
				x.Scn = scn // rewind
				red200Trm, ok := x.Red200()
				if ok {
					return x.PenPenXpr(scp, &PenRed200{Trm: red200Trm}), true
				}
				x.Scn = scn // rewind
				red300Trm, ok := x.Red300()
				if ok {
					return x.PenPenXpr(scp, &PenRed300{Trm: red300Trm}), true
				}
				x.Scn = scn // rewind
				red400Trm, ok := x.Red400()
				if ok {
					return x.PenPenXpr(scp, &PenRed400{Trm: red400Trm}), true
				}
				x.Scn = scn // rewind
				red500Trm, ok := x.Red500()
				if ok {
					return x.PenPenXpr(scp, &PenRed500{Trm: red500Trm}), true
				}
				x.Scn = scn // rewind
				red600Trm, ok := x.Red600()
				if ok {
					return x.PenPenXpr(scp, &PenRed600{Trm: red600Trm}), true
				}
				x.Scn = scn // rewind
				red700Trm, ok := x.Red700()
				if ok {
					return x.PenPenXpr(scp, &PenRed700{Trm: red700Trm}), true
				}
				x.Scn = scn // rewind
				red800Trm, ok := x.Red800()
				if ok {
					return x.PenPenXpr(scp, &PenRed800{Trm: red800Trm}), true
				}
				x.Scn = scn // rewind
				red900Trm, ok := x.Red900()
				if ok {
					return x.PenPenXpr(scp, &PenRed900{Trm: red900Trm}), true
				}
				x.Scn = scn // rewind
				redA100Trm, ok := x.RedA100()
				if ok {
					return x.PenPenXpr(scp, &PenRedA100{Trm: redA100Trm}), true
				}
				x.Scn = scn // rewind
				redA200Trm, ok := x.RedA200()
				if ok {
					return x.PenPenXpr(scp, &PenRedA200{Trm: redA200Trm}), true
				}
				x.Scn = scn // rewind
				redA400Trm, ok := x.RedA400()
				if ok {
					return x.PenPenXpr(scp, &PenRedA400{Trm: redA400Trm}), true
				}
				x.Scn = scn // rewind
				redA700Trm, ok := x.RedA700()
				if ok {
					return x.PenPenXpr(scp, &PenRedA700{Trm: redA700Trm}), true
				}
				x.Scn = scn // rewind
				rgbaTrm, ok := x.Rgba()
				if ok {
					x.NextLprn()
					i0 := x.Xpr(scp).(FltFltXpr)
					i1 := x.Xpr(scp).(FltFltXpr)
					i2 := x.Xpr(scp).(FltFltXpr)
					i3 := x.Xpr(scp).(FltFltXpr)
					var i4 []UntUntXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(UntUntXpr)
						if !ok {
							x.Panicf("PenPkgXpr: Rgba: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i4 = append(i4, v)
					}
					cur := &PenRgba{Trm: rgbaTrm, I0: i0, I1: i1, I2: i2, I3: i3, I4: i4}
					x.NextRprn()
					return x.PenPenXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				rgbTrm, ok := x.Rgb()
				if ok {
					x.NextLprn()
					i0 := x.Xpr(scp).(FltFltXpr)
					i1 := x.Xpr(scp).(FltFltXpr)
					i2 := x.Xpr(scp).(FltFltXpr)
					var i3 []UntUntXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(UntUntXpr)
						if !ok {
							x.Panicf("PenPkgXpr: Rgb: non UntUntXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i3 = append(i3, v)
					}
					cur := &PenRgb{Trm: rgbTrm, I0: i0, I1: i1, I2: i2, I3: i3}
					x.NextRprn()
					return x.PenPenXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 't':
				teal50Trm, ok := x.Teal50()
				if ok {
					return x.PenPenXpr(scp, &PenTeal50{Trm: teal50Trm}), true
				}
				x.Scn = scn // rewind
				teal100Trm, ok := x.Teal100()
				if ok {
					return x.PenPenXpr(scp, &PenTeal100{Trm: teal100Trm}), true
				}
				x.Scn = scn // rewind
				teal200Trm, ok := x.Teal200()
				if ok {
					return x.PenPenXpr(scp, &PenTeal200{Trm: teal200Trm}), true
				}
				x.Scn = scn // rewind
				teal300Trm, ok := x.Teal300()
				if ok {
					return x.PenPenXpr(scp, &PenTeal300{Trm: teal300Trm}), true
				}
				x.Scn = scn // rewind
				teal400Trm, ok := x.Teal400()
				if ok {
					return x.PenPenXpr(scp, &PenTeal400{Trm: teal400Trm}), true
				}
				x.Scn = scn // rewind
				teal500Trm, ok := x.Teal500()
				if ok {
					return x.PenPenXpr(scp, &PenTeal500{Trm: teal500Trm}), true
				}
				x.Scn = scn // rewind
				teal600Trm, ok := x.Teal600()
				if ok {
					return x.PenPenXpr(scp, &PenTeal600{Trm: teal600Trm}), true
				}
				x.Scn = scn // rewind
				teal700Trm, ok := x.Teal700()
				if ok {
					return x.PenPenXpr(scp, &PenTeal700{Trm: teal700Trm}), true
				}
				x.Scn = scn // rewind
				teal800Trm, ok := x.Teal800()
				if ok {
					return x.PenPenXpr(scp, &PenTeal800{Trm: teal800Trm}), true
				}
				x.Scn = scn // rewind
				teal900Trm, ok := x.Teal900()
				if ok {
					return x.PenPenXpr(scp, &PenTeal900{Trm: teal900Trm}), true
				}
				x.Scn = scn // rewind
				tealA100Trm, ok := x.TealA100()
				if ok {
					return x.PenPenXpr(scp, &PenTealA100{Trm: tealA100Trm}), true
				}
				x.Scn = scn // rewind
				tealA200Trm, ok := x.TealA200()
				if ok {
					return x.PenPenXpr(scp, &PenTealA200{Trm: tealA200Trm}), true
				}
				x.Scn = scn // rewind
				tealA400Trm, ok := x.TealA400()
				if ok {
					return x.PenPenXpr(scp, &PenTealA400{Trm: tealA400Trm}), true
				}
				x.Scn = scn // rewind
				tealA700Trm, ok := x.TealA700()
				if ok {
					return x.PenPenXpr(scp, &PenTealA700{Trm: tealA700Trm}), true
				}
				x.Scn = scn // rewind
			case 'w':
				whiteTrm, ok := x.White()
				if ok {
					return x.PenPenXpr(scp, &PenWhite{Trm: whiteTrm}), true
				}
				x.Scn = scn // rewind
			case 'y':
				yellow50Trm, ok := x.Yellow50()
				if ok {
					return x.PenPenXpr(scp, &PenYellow50{Trm: yellow50Trm}), true
				}
				x.Scn = scn // rewind
				yellow100Trm, ok := x.Yellow100()
				if ok {
					return x.PenPenXpr(scp, &PenYellow100{Trm: yellow100Trm}), true
				}
				x.Scn = scn // rewind
				yellow200Trm, ok := x.Yellow200()
				if ok {
					return x.PenPenXpr(scp, &PenYellow200{Trm: yellow200Trm}), true
				}
				x.Scn = scn // rewind
				yellow300Trm, ok := x.Yellow300()
				if ok {
					return x.PenPenXpr(scp, &PenYellow300{Trm: yellow300Trm}), true
				}
				x.Scn = scn // rewind
				yellow400Trm, ok := x.Yellow400()
				if ok {
					return x.PenPenXpr(scp, &PenYellow400{Trm: yellow400Trm}), true
				}
				x.Scn = scn // rewind
				yellow500Trm, ok := x.Yellow500()
				if ok {
					return x.PenPenXpr(scp, &PenYellow500{Trm: yellow500Trm}), true
				}
				x.Scn = scn // rewind
				yellow600Trm, ok := x.Yellow600()
				if ok {
					return x.PenPenXpr(scp, &PenYellow600{Trm: yellow600Trm}), true
				}
				x.Scn = scn // rewind
				yellow700Trm, ok := x.Yellow700()
				if ok {
					return x.PenPenXpr(scp, &PenYellow700{Trm: yellow700Trm}), true
				}
				x.Scn = scn // rewind
				yellow800Trm, ok := x.Yellow800()
				if ok {
					return x.PenPenXpr(scp, &PenYellow800{Trm: yellow800Trm}), true
				}
				x.Scn = scn // rewind
				yellow900Trm, ok := x.Yellow900()
				if ok {
					return x.PenPenXpr(scp, &PenYellow900{Trm: yellow900Trm}), true
				}
				x.Scn = scn // rewind
				yellowA100Trm, ok := x.YellowA100()
				if ok {
					return x.PenPenXpr(scp, &PenYellowA100{Trm: yellowA100Trm}), true
				}
				x.Scn = scn // rewind
				yellowA200Trm, ok := x.YellowA200()
				if ok {
					return x.PenPenXpr(scp, &PenYellowA200{Trm: yellowA200Trm}), true
				}
				x.Scn = scn // rewind
				yellowA400Trm, ok := x.YellowA400()
				if ok {
					return x.PenPenXpr(scp, &PenYellowA400{Trm: yellowA400Trm}), true
				}
				x.Scn = scn // rewind
				yellowA700Trm, ok := x.YellowA700()
				if ok {
					return x.PenPenXpr(scp, &PenYellowA700{Trm: yellowA700Trm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("PenPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) PenPenXpr(scp *Scp, X PenPenXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Pen asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Pen asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Pen asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PenPen)
				return x.PenPenXpr(scp, &PenPenAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'c':
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 ClrClrXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(ClrClrXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.ClrClrXpr(scp, &PenPenClrSetGet{Trm: clrTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		case 'i':
			invTrm, ok := x.Inv()
			if ok {
				x.NextLprn()
				cur := &PenPenInv{Trm: invTrm, X: X}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			opaTrm, ok := x.Opa()
			if ok {
				x.NextLprn()
				cur := &PenPenOpa{Trm: opaTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'w':
			widTrm, ok := x.Wid()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 UntUntXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(UntUntXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.UntUntXpr(scp, &PenPenWidSetGet{Trm: widTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PenPenXpr: no expression found")
	}
	return X
}
func (x *Xprr) PenPensXpr(scp *Scp, X PenPensXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Pen asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Pen asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Pen asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PenPens)
				return x.PenPensXpr(scp, &PenPensAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &PenPensAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &PenPensCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &PenPensCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &PenPensClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &PenPensDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &PenPensDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Pen 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PenPen)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &PenPensEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &PenPensFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &PenPensFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &PenPensFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &PenPensIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(PenPenXpr)}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &PenPensIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &PenPensInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &PenPensLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &PenPensLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []PenPensXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PenPensXpr)
					if !ok {
						x.Panicf("PenPensXpr: Mrg: non PenPensXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PenPensMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &PenPensMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &PenPensMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Pen 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PenPen)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &PenPensPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []PenPenXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PenPenXpr)
					if !ok {
						x.Panicf("PenPensXpr: Push: non PenPenXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PenPensPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &PenPensPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.PenPenXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []PenPenXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PenPenXpr)
					if !ok {
						x.Panicf("PenPensXpr: Que: non PenPenXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PenPensQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &PenPensRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &PenPensRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &PenPensTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &PenPensUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(PenPenXpr)}
				x.NextRprn()
				return x.PenPensXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PenPensXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltPkgXpr(scp *Scp) (r Xpr, ok bool) {
	_, ok = x.Plt()
	if ok {
		if x.HasMem() {
			scn := x.Scn
			switch x.Ch {
			case 'a':
				axisPadTrm, ok := x.AxisPad()
				if ok {
					return x.UntUntXpr(scp, &UntAxisPad{Trm: axisPadTrm}), true
				}
				x.Scn = scn // rewind
			case 'b':
				barPadTrm, ok := x.BarPad()
				if ok {
					return x.UntUntXpr(scp, &UntBarPad{Trm: barPadTrm}), true
				}
				x.Scn = scn // rewind
				bakClrTrm, ok := x.BakClr()
				if ok {
					return x.ClrClrXpr(scp, &ClrBakClr{Trm: bakClrTrm}), true
				}
				x.Scn = scn // rewind
				brdrClrTrm, ok := x.BrdrClr()
				if ok {
					return x.ClrClrXpr(scp, &ClrBrdrClr{Trm: brdrClrTrm}), true
				}
				x.Scn = scn // rewind
				brdrLenTrm, ok := x.BrdrLen()
				if ok {
					return x.UntUntXpr(scp, &UntBrdrLen{Trm: brdrLenTrm}), true
				}
				x.Scn = scn // rewind
			case 'i':
				inrvlTxtLenTrm, ok := x.InrvlTxtLen()
				if ok {
					return x.UntUntXpr(scp, &UntInrvlTxtLen{Trm: inrvlTxtLenTrm}), true
				}
				x.Scn = scn // rewind
				inrvlTxtClrXTrm, ok := x.InrvlTxtClrX()
				if ok {
					return x.ClrClrXpr(scp, &ClrInrvlTxtClrX{Trm: inrvlTxtClrXTrm}), true
				}
				x.Scn = scn // rewind
				inrvlTxtClrYTrm, ok := x.InrvlTxtClrY()
				if ok {
					return x.ClrClrXpr(scp, &ClrInrvlTxtClrY{Trm: inrvlTxtClrYTrm}), true
				}
				x.Scn = scn // rewind
			case 'l':
				lenTrm, ok := x.Len()
				if ok {
					return x.UntUntXpr(scp, &UntLen{Trm: lenTrm}), true
				}
				x.Scn = scn // rewind
				losClrTrm, ok := x.LosClr()
				if ok {
					return x.ClrClrXpr(scp, &ClrLosClr{Trm: losClrTrm}), true
				}
				x.Scn = scn // rewind
				losPenTrm, ok := x.LosPen()
				if ok {
					return x.PenPenXpr(scp, &PenLosPen{Trm: losPenTrm}), true
				}
				x.Scn = scn // rewind
			case 'm':
				msgClrTrm, ok := x.MsgClr()
				if ok {
					return x.ClrClrXpr(scp, &ClrMsgClr{Trm: msgClrTrm}), true
				}
				x.Scn = scn // rewind
				makePltsTrm, ok := x.MakePlts()
				if ok {
					x.NextLprn()
					cur := &PltMakePlts{Trm: makePltsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.PltPltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				makeEmpPltsTrm, ok := x.MakeEmpPlts()
				if ok {
					x.NextLprn()
					cur := &PltMakeEmpPlts{Trm: makeEmpPltsTrm, I0: x.Xpr(scp).(UntUntXpr)}
					x.NextRprn()
					return x.PltPltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'n':
				newPltsTrm, ok := x.NewPlts()
				if ok {
					x.NextLprn()
					var i0 []PltPltXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(PltPltXpr)
						if !ok {
							x.Panicf("PltPkgXpr: NewPlts: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &PltNewPlts{Trm: newPltsTrm, I0: i0}
					x.NextRprn()
					return x.PltPltsXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newStmTrm, ok := x.NewStm()
				if ok {
					x.NextLprn()
					cur := &PltNewStm{Trm: newStmTrm}
					x.NextRprn()
					return x.PltStmXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newFltsSctrTrm, ok := x.NewFltsSctr()
				if ok {
					x.NextLprn()
					cur := &PltNewFltsSctr{Trm: newFltsSctrTrm}
					x.NextRprn()
					return x.PltFltsSctrXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newFltsSctrDistTrm, ok := x.NewFltsSctrDist()
				if ok {
					x.NextLprn()
					cur := &PltNewFltsSctrDist{Trm: newFltsSctrDistTrm}
					x.NextRprn()
					return x.PltFltsSctrDistXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newHrzTrm, ok := x.NewHrz()
				if ok {
					x.NextLprn()
					var i0 []PltPltXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(PltPltXpr)
						if !ok {
							x.Panicf("PltPkgXpr: NewHrz: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &PltNewHrz{Trm: newHrzTrm, I0: i0}
					x.NextRprn()
					return x.PltHrzXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newVrtTrm, ok := x.NewVrt()
				if ok {
					x.NextLprn()
					var i0 []PltPltXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(PltPltXpr)
						if !ok {
							x.Panicf("PltPkgXpr: NewVrt: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &PltNewVrt{Trm: newVrtTrm, I0: i0}
					x.NextRprn()
					return x.PltVrtXpr(scp, cur), true
				}
				x.Scn = scn // rewind
				newDpthTrm, ok := x.NewDpth()
				if ok {
					x.NextLprn()
					var i0 []PltPltXpr
					for {
						cur := x.Xpr(scp, true)
						if cur == nil {
							break
						}
						v, ok := cur.(PltPltXpr)
						if !ok {
							x.Panicf("PltPkgXpr: NewDpth: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
						}
						i0 = append(i0, v)
					}
					cur := &PltNewDpth{Trm: newDpthTrm, I0: i0}
					x.NextRprn()
					return x.PltDpthXpr(scp, cur), true
				}
				x.Scn = scn // rewind
			case 'o':
				outlierLimTrm, ok := x.OutlierLim()
				if ok {
					return x.FltFltXpr(scp, &FltOutlierLim{Trm: outlierLimTrm}), true
				}
				x.Scn = scn // rewind
			case 'p':
				padTrm, ok := x.Pad()
				if ok {
					return x.UntUntXpr(scp, &UntPad{Trm: padTrm}), true
				}
				x.Scn = scn // rewind
				prfClrTrm, ok := x.PrfClr()
				if ok {
					return x.ClrClrXpr(scp, &ClrPrfClr{Trm: prfClrTrm}), true
				}
				x.Scn = scn // rewind
				prfPenTrm, ok := x.PrfPen()
				if ok {
					return x.PenPenXpr(scp, &PenPrfPen{Trm: prfPenTrm}), true
				}
				x.Scn = scn // rewind
			case 's':
				sclTrm, ok := x.Scl()
				if ok {
					return x.FltFltXpr(scp, &FltScl{Trm: sclTrm}), true
				}
				x.Scn = scn // rewind
				stkWidthTrm, ok := x.StkWidth()
				if ok {
					return x.UntUntXpr(scp, &UntStkWidth{Trm: stkWidthTrm}), true
				}
				x.Scn = scn // rewind
				shpRadiusTrm, ok := x.ShpRadius()
				if ok {
					return x.UntUntXpr(scp, &UntShpRadius{Trm: shpRadiusTrm}), true
				}
				x.Scn = scn // rewind
			case 't':
				titleClrTrm, ok := x.TitleClr()
				if ok {
					return x.ClrClrXpr(scp, &ClrTitleClr{Trm: titleClrTrm}), true
				}
				x.Scn = scn // rewind
			}
		}
		x.Panicf("PltPkgXpr: no expression found")
	}
	return nil, false
}
func (x *Xprr) PltPltXpr(scp *Scp, X PltPltXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltPlt)
				return x.PltPltXpr(scp, &PltPltAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'h':
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltPltHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltPltSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltPltSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltPltScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltPltVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltPltXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltPltsXpr(scp *Scp, X PltPltsXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltPlts)
				return x.PltPltsXpr(scp, &PltPltsAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
			atTrm, ok := x.At()
			if ok {
				x.NextLprn()
				cur := &PltPltsAt{Trm: atTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'c':
			cntTrm, ok := x.Cnt()
			if ok {
				x.NextLprn()
				cur := &PltPltsCnt{Trm: cntTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
			cpyTrm, ok := x.Cpy()
			if ok {
				x.NextLprn()
				cur := &PltPltsCpy{Trm: cpyTrm, X: X}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			clrTrm, ok := x.Clr()
			if ok {
				x.NextLprn()
				cur := &PltPltsClr{Trm: clrTrm, X: X}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'd':
			dqueTrm, ok := x.Dque()
			if ok {
				x.NextLprn()
				cur := &PltPltsDque{Trm: dqueTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			delTrm, ok := x.Del()
			if ok {
				x.NextLprn()
				cur := &PltPltsDel{Trm: delTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'e':
			eachTrm, ok := x.Each()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt 'each' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				eachScp := NewScp(scp)
				eachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltPlt)
				var xprs []Xpr
				for {
					cur := x.Xpr(eachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &PltPltsEach{Trm: eachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: eachScp}
			}
			x.Scn = scn
		case 'f':
			fromTrm, ok := x.From()
			if ok {
				x.NextLprn()
				cur := &PltPltsFrom{Trm: fromTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstTrm, ok := x.Fst()
			if ok {
				x.NextLprn()
				cur := &PltPltsFst{Trm: fstTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			fstIdxTrm, ok := x.FstIdx()
			if ok {
				x.NextLprn()
				cur := &PltPltsFstIdx{Trm: fstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'i':
			insTrm, ok := x.Ins()
			if ok {
				x.NextLprn()
				cur := &PltPltsIns{Trm: insTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(PltPltXpr)}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inTrm, ok := x.In()
			if ok {
				x.NextLprn()
				cur := &PltPltsIn{Trm: inTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			inBndTrm, ok := x.InBnd()
			if ok {
				x.NextLprn()
				cur := &PltPltsInBnd{Trm: inBndTrm, X: X, I0: x.Xpr(scp).(BndBndXpr)}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'l':
			lstTrm, ok := x.Lst()
			if ok {
				x.NextLprn()
				cur := &PltPltsLst{Trm: lstTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			lstIdxTrm, ok := x.LstIdx()
			if ok {
				x.NextLprn()
				cur := &PltPltsLstIdx{Trm: lstIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'm':
			mrgTrm, ok := x.Mrg()
			if ok {
				x.NextLprn()
				var i0 []PltPltsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PltPltsXpr)
					if !ok {
						x.Panicf("PltPltsXpr: Mrg: non PltPltsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PltPltsMrg{Trm: mrgTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlTrm, ok := x.Mdl()
			if ok {
				x.NextLprn()
				cur := &PltPltsMdl{Trm: mdlTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			mdlIdxTrm, ok := x.MdlIdx()
			if ok {
				x.NextLprn()
				cur := &PltPltsMdlIdx{Trm: mdlIdxTrm, X: X}
				x.NextRprn()
				return x.UntUntXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pllEachTrm, ok := x.PllEach()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt 'pllEach' xpr: missing idn parameter")
				}
				x.SkpSpceCmnt()
				pllEachScp := NewScp(scp)
				pllEachScp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltPlt)
				var xprs []Xpr
				for {
					cur := x.Xpr(pllEachScp, true)
					if cur == nil {
						break
					}
					xprs = append(xprs, cur)
				}
				x.NextRprn()
				return &PltPltsPllEach{Trm: pllEachTrm, X: X, Idn: idn.Bnd, Xprs: xprs, Scp: pllEachScp}
			}
			x.Scn = scn
			pushTrm, ok := x.Push()
			if ok {
				x.NextLprn()
				var i0 []PltPltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PltPltXpr)
					if !ok {
						x.Panicf("PltPltsXpr: Push: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PltPltsPush{Trm: pushTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			popTrm, ok := x.Pop()
			if ok {
				x.NextLprn()
				cur := &PltPltsPop{Trm: popTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'q':
			queTrm, ok := x.Que()
			if ok {
				x.NextLprn()
				var i0 []PltPltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PltPltXpr)
					if !ok {
						x.Panicf("PltPltsXpr: Que: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PltPltsQue{Trm: queTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'r':
			randTrm, ok := x.Rand()
			if ok {
				x.NextLprn()
				cur := &PltPltsRand{Trm: randTrm, X: X}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
			revTrm, ok := x.Rev()
			if ok {
				x.NextLprn()
				cur := &PltPltsRev{Trm: revTrm, X: X}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			toTrm, ok := x.To()
			if ok {
				x.NextLprn()
				cur := &PltPltsTo{Trm: toTrm, X: X, I0: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'u':
			updTrm, ok := x.Upd()
			if ok {
				x.NextLprn()
				cur := &PltPltsUpd{Trm: updTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(PltPltXpr)}
				x.NextRprn()
				return x.PltPltsXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltPltsXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltTmeAxisXXpr(scp *Scp, X PltTmeAxisXXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'v':
			visTrm, ok := x.Vis()
			if ok {
				x.NextLprn()
				cur := &PltTmeAxisXVis{Trm: visTrm, X: X, I0: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.PltTmeAxisXXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltTmeAxisXXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltFltAxisYXpr(scp *Scp, X PltFltAxisYXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'e':
			eqiDstTrm, ok := x.EqiDst()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 FltFltXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(FltFltXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &PltFltAxisYEqiDstSetGet{Trm: eqiDstTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		case 'm':
			minTrm, ok := x.Min()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 FltFltXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(FltFltXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &PltFltAxisYMinSetGet{Trm: minTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
			maxTrm, ok := x.Max()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 FltFltXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(FltFltXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.FltFltXpr(scp, &PltFltAxisYMaxSetGet{Trm: maxTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		case 'v':
			visTrm, ok := x.Vis()
			if ok {
				x.NextLprn()
				cur := &PltFltAxisYVis{Trm: visTrm, X: X, I0: x.Xpr(scp).(BolBolXpr)}
				x.NextRprn()
				return x.PltFltAxisYXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltFltAxisYXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltStmXpr(scp *Scp, X PltStmXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltStm)
				return x.PltStmXpr(scp, &PltStmAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'c':
			cndTrm, ok := x.Cnd()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(PenPenXpr)
				var i1 []HstCndXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstCndXpr)
					if !ok {
						x.Panicf("PltStmXpr: Cnd: non HstCndXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &PltStmCnd{Trm: cndTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hrzLnTrm, ok := x.HrzLn()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(PenPenXpr)
				var i1 []FltFltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(FltFltXpr)
					if !ok {
						x.Panicf("PltStmXpr: HrzLn: non FltFltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &PltStmHrzLn{Trm: hrzLnTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			hrzBndTrm, ok := x.HrzBnd()
			if ok {
				x.NextLprn()
				cur := &PltStmHrzBnd{Trm: hrzBndTrm, X: X, I0: x.Xpr(scp).(ClrClrXpr), I1: x.Xpr(scp).(PenPenXpr), I2: x.Xpr(scp).(FltFltXpr), I3: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			hrzSclValTrm, ok := x.HrzSclVal()
			if ok {
				x.NextLprn()
				cur := &PltStmHrzSclVal{Trm: hrzSclValTrm, X: X, I0: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltStmHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			stmTrm, ok := x.Stm()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(PenPenXpr)
				var i1 []HstStmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStmXpr)
					if !ok {
						x.Panicf("PltStmXpr: Stm: non HstStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &PltStmStm{Trm: stmTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			stmBndTrm, ok := x.StmBnd()
			if ok {
				x.NextLprn()
				cur := &PltStmStmBnd{Trm: stmBndTrm, X: X, I0: x.Xpr(scp).(ClrClrXpr), I1: x.Xpr(scp).(PenPenXpr), I2: x.Xpr(scp).(HstStmXpr), I3: x.Xpr(scp).(HstStmXpr)}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltStmSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltStmSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltStmScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			titleTrm, ok := x.Title()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 StrStrXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(StrStrXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.StrStrXpr(scp, &PltStmTitleSetGet{Trm: titleTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		case 'v':
			vrtLnTrm, ok := x.VrtLn()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(PenPenXpr)
				var i1 []TmeTmeXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(TmeTmeXpr)
					if !ok {
						x.Panicf("PltStmXpr: VrtLn: non TmeTmeXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &PltStmVrtLn{Trm: vrtLnTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			vrtBndTrm, ok := x.VrtBnd()
			if ok {
				x.NextLprn()
				cur := &PltStmVrtBnd{Trm: vrtBndTrm, X: X, I0: x.Xpr(scp).(ClrClrXpr), I1: x.Xpr(scp).(PenPenXpr), I2: x.Xpr(scp).(TmeTmeXpr), I3: x.Xpr(scp).(TmeTmeXpr)}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			vrtSclValTrm, ok := x.VrtSclVal()
			if ok {
				x.NextLprn()
				cur := &PltStmVrtSclVal{Trm: vrtSclValTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltStmXpr(scp, cur)
			}
			x.Scn = scn // rewind
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltStmVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'x':
			xTrm, ok := x.X()
			if ok {
				x.NextLprn()
				cur := &PltStmX{Trm: xTrm, X: X}
				x.NextRprn()
				return x.PltTmeAxisXXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'y':
			yTrm, ok := x.Y()
			if ok {
				x.NextLprn()
				cur := &PltStmY{Trm: yTrm, X: X}
				x.NextRprn()
				return x.PltFltAxisYXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltStmXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltFltsSctrXpr(scp *Scp, X PltFltsSctrXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltFltsSctr)
				return x.PltFltsSctrXpr(scp, &PltFltsSctrAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'f':
			fltsTrm, ok := x.Flts()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(ClrClrXpr)
				var i1 []FltsFltsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(FltsFltsXpr)
					if !ok {
						x.Panicf("PltFltsSctrXpr: Flts: non FltsFltsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i1 = append(i1, v)
				}
				cur := &PltFltsSctrFlts{Trm: fltsTrm, X: X, I0: i0, I1: i1}
				x.NextRprn()
				return x.PltFltsSctrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'o':
			outlierTrm, ok := x.Outlier()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 BolBolXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(BolBolXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.BolBolXpr(scp, &PltFltsSctrOutlierSetGet{Trm: outlierTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		case 'p':
			prfLosTrm, ok := x.PrfLos()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(TmesTmesXpr)
				i1 := x.Xpr(scp).(TmesTmesXpr)
				var i2 []HstStmXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(HstStmXpr)
					if !ok {
						x.Panicf("PltFltsSctrXpr: PrfLos: non HstStmXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i2 = append(i2, v)
				}
				cur := &PltFltsSctrPrfLos{Trm: prfLosTrm, X: X, I0: i0, I1: i1, I2: i2}
				x.NextRprn()
				return x.PltFltsSctrXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 't':
			titleTrm, ok := x.Title()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				var i0 StrStrXpr
				i0Xpr := x.Xpr(scp, true)
				if i0Xpr != nil {
					i0 = i0Xpr.(StrStrXpr) // nil indicates get only
				}
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.StrStrXpr(scp, &PltFltsSctrTitleSetGet{Trm: titleTrm, X: X, I0: i0})
			}
			x.Scn = scn // rewind
		case 'v':
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'y':
			yTrm, ok := x.Y()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.PltFltAxisYXpr(scp, &PltFltsSctrYGet{Trm: yTrm, X: X})
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltFltsSctrXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltFltsSctrDistXpr(scp *Scp, X PltFltsSctrDistXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltFltsSctrDist)
				return x.PltFltsSctrDistXpr(scp, &PltFltsSctrDistAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'f':
			fltsTrm, ok := x.Flts()
			if ok {
				x.NextLprn()
				i0 := x.Xpr(scp).(ClrClrXpr)
				i1 := x.Xpr(scp).(UntUntXpr)
				var i2 []FltsFltsXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(FltsFltsXpr)
					if !ok {
						x.Panicf("PltFltsSctrDistXpr: Flts: non FltsFltsXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i2 = append(i2, v)
				}
				cur := &PltFltsSctrDistFlts{Trm: fltsTrm, X: X, I0: i0, I1: i1, I2: i2}
				x.NextRprn()
				return x.PltFltsSctrDistXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'h':
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrDistHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 's':
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrDistSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrDistSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrDistScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltFltsSctrDistVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltFltsSctrDistXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltHrzXpr(scp *Scp, X PltHrzXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltHrz)
				return x.PltHrzXpr(scp, &PltHrzAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'h':
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltHrzHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pltTrm, ok := x.Plt()
			if ok {
				x.NextLprn()
				var i0 []PltPltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PltPltXpr)
					if !ok {
						x.Panicf("PltHrzXpr: Plt: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PltHrzPlt{Trm: pltTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PltHrzXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pltsTrm, ok := x.Plts()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.PltPltsXpr(scp, &PltHrzPltsGet{Trm: pltsTrm, X: X})
			}
			x.Scn = scn // rewind
		case 's':
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltHrzSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltHrzSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltHrzScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltHrzVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltHrzXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltVrtXpr(scp *Scp, X PltVrtXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltVrt)
				return x.PltVrtXpr(scp, &PltVrtAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'h':
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltVrtHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pltTrm, ok := x.Plt()
			if ok {
				x.NextLprn()
				var i0 []PltPltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PltPltXpr)
					if !ok {
						x.Panicf("PltVrtXpr: Plt: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PltVrtPlt{Trm: pltTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PltVrtXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pltsTrm, ok := x.Plts()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.PltPltsXpr(scp, &PltVrtPltsGet{Trm: pltsTrm, X: X})
			}
			x.Scn = scn // rewind
		case 's':
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltVrtSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltVrtSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltVrtScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltVrtVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltVrtXpr: no expression found")
	}
	return X
}
func (x *Xprr) PltDpthXpr(scp *Scp, X PltDpthXpr) Xpr {
	if x.HasMem() {
		scn := x.Scn
		switch x.Ch {
		case 'a':
			asnTrm, ok := x.Asn()
			if ok {
				x.NextLprn()
				idn, ok := x.IdnLit()
				if !ok {
					x.Panicf("Plt asn xpr: missing Idn parameter")
				}
				x.SkpSpceCmnt()
				lclScn := x.Scn
				var depth int
				depthTrm, ok := x.UntLit() // optional
				if ok {
					depth = int(prs.UntTrm(depthTrm, x.Txt))
					if depth == 0 {
						x.Panicf("Plt asn xpr: depth may not equal zero")
					}
					for d := depth; scp != nil && d != 0; d-- { // recurse up scp by depth
						scp = scp.Prnt
					}
					if scp == nil {
						x.Panicf("Plt asn xpr: depth traversal too deep (depth:%v)", depth)
					}
				} else {
					x.Scn = lclScn
				}
				x.NextRprn()
				scp.Decl(x.Txt[idn.Idx:idn.Lim], knd.PltDpth)
				return x.PltDpthXpr(scp, &PltDpthAsn{Trm: asnTrm, X: X, Idn: idn.Bnd, Depth: depth})
			}
			x.Scn = scn
		case 'h':
			hrzSclTrm, ok := x.HrzScl()
			if ok {
				x.NextLprn()
				cur := &PltDpthHrzScl{Trm: hrzSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'p':
			pltTrm, ok := x.Plt()
			if ok {
				x.NextLprn()
				var i0 []PltPltXpr
				for {
					cur := x.Xpr(scp, true)
					if cur == nil {
						break
					}
					v, ok := cur.(PltPltXpr)
					if !ok {
						x.Panicf("PltDpthXpr: Plt: non PltPltXpr in variadic parameters (actual:%v)", reflect.TypeOf(cur).Elem().Name())
					}
					i0 = append(i0, v)
				}
				cur := &PltDpthPlt{Trm: pltTrm, X: X, I0: i0}
				x.NextRprn()
				return x.PltDpthXpr(scp, cur)
			}
			x.Scn = scn // rewind
			pltsTrm, ok := x.Plts()
			if ok {
				x.NextLprn()
				x.SkpSpceCmnt()
				x.NextRprn()
				return x.PltPltsXpr(scp, &PltDpthPltsGet{Trm: pltsTrm, X: X})
			}
			x.Scn = scn // rewind
		case 's':
			shoTrm, ok := x.Sho()
			if ok {
				x.NextLprn()
				cur := &PltDpthSho{Trm: shoTrm, X: X}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sizTrm, ok := x.Siz()
			if ok {
				x.NextLprn()
				cur := &PltDpthSiz{Trm: sizTrm, X: X, I0: x.Xpr(scp).(UntUntXpr), I1: x.Xpr(scp).(UntUntXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
			sclTrm, ok := x.Scl()
			if ok {
				x.NextLprn()
				cur := &PltDpthScl{Trm: sclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		case 'v':
			vrtSclTrm, ok := x.VrtScl()
			if ok {
				x.NextLprn()
				cur := &PltDpthVrtScl{Trm: vrtSclTrm, X: X, I0: x.Xpr(scp).(FltFltXpr)}
				x.NextRprn()
				return x.PltPltXpr(scp, cur)
			}
			x.Scn = scn // rewind
		}
		x.Panicf("PltDpthXpr: no expression found")
	}
	return X
}
func (x *Xprr) HasMem() bool {
	scn := x.Scn
	x.SkpSpceCmnt()
	if x.Ch == '.' {
		x.NextRune()
		x.SkpSpceCmnt()
		return true
	}
	x.Scn = scn
	return false
}
func (x *Xprr) NextLprn() {
	x.SkpSpceCmnt()
	if x.Ch != '(' {
		x.Panicf("xprr: missing opening parenthesis '('")
	}
	x.NextRune()
	x.SkpSpceCmnt()
}
func (x *Xprr) NextRprn() {
	x.SkpSpceCmnt()
	if x.Ch != ')' {
		x.Panicf("xprr: missing closing parenthesis '('")
	}
	x.NextRune()
	x.SkpSpceCmnt()
}
func (x *Xprr) Erf(format string, args ...interface{}) (r *err.Err) {
	return err.Fmt("%v\nxpr pos: ln:%v col:%v ch:%q\nxpr src: %v", err.Fmt(format, args...), x.Ln, x.Col, x.Ch, x.Txt)
}
func (x *Xprr) Panicf(format string, args ...interface{}) {
	err.PanicXprf("%v\nxpr pos: ln:%v col:%v ch:%q\nxpr src: %v", uint32(x.Ln), uint32(x.Col), x.Ch, err.Fmt(format, args...), x.Ln, x.Col, x.Ch, x.Txt)
}
